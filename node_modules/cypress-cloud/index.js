"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var cypress_cloud_exports = {};
__export(cypress_cloud_exports, {
  run: () => run2
});
module.exports = __toCommonJS(cypress_cloud_exports);

// ../../node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// index.ts
var import_register = require("source-map-support/register.js");

// lib/require.ts
var import_module = require("module");
var require2 = (0, import_module.createRequire)(importMetaUrl);

// lib/stdout.ts
var import_child_process = __toESM(require("child_process"));
var orginal = import_child_process.default.spawn;
import_child_process.default.spawn = function(command, args, options) {
  if (command.match(/Cypress/)) {
    const process2 = orginal(command, args, {
      ...options,
      // using pipe enables capturing stdout and stderr
      stdio: ["pipe", "pipe", "pipe"]
    });
    return process2;
  }
  return orginal(command, args, options);
};

// lib/ws/ws.ts
var import_debug = __toESM(require("debug"));
var import_http = __toESM(require("http"));
var import_lil_http_terminator = __toESM(require("lil-http-terminator"));
var import_ts_pattern = require("ts-pattern");
var WebSocket = __toESM(require("ws"));

// lib/pubsub.ts
var import_events = __toESM(require("events"));
var pubsub = new import_events.default();

// lib/ws/ws.ts
var debug = (0, import_debug.default)("currents:ws");
var server = null;
var wss = null;
var httpTerminator = null;
var getWSSPort = () => (0, import_ts_pattern.match)(server?.address()).with({ port: import_ts_pattern.P.number }, (address) => address.port).otherwise(() => 0);
var stopWSS = async () => {
  debug("terminating wss server: %d", getWSSPort());
  if (!httpTerminator) {
    debug("no wss server");
    return;
  }
  const { success, code, message, error: error2 } = await httpTerminator.terminate();
  if (!success) {
    if (code === "TIMED_OUT")
      error2(message);
    if (code === "SERVER_ERROR")
      error2(message, error2);
    if (code === "INTERNAL_ERROR")
      error2(message, error2);
  }
  debug("terminated wss server: %d", getWSSPort());
};
var startWSS = () => {
  if (wss) {
    return;
  }
  server = import_http.default.createServer().on("listening", () => {
    if (!server) {
      throw new Error("Server not initialized");
    }
    wss = new WebSocket.WebSocketServer({
      server
    });
    debug("starting wss on port %d", getWSSPort());
    wss.on("connection", function connection(ws) {
      ws.on("message", function incoming(event) {
        const message = JSON.parse(event.toString());
        pubsub.emit(message.type, message.payload);
      });
    });
  }).listen();
  httpTerminator = (0, import_lil_http_terminator.default)({
    server
  });
};

// lib/capture.ts
var import_debug2 = __toESM(require("debug"));
var debug2 = (0, import_debug2.default)("currents:capture");
var _write = process.stdout.write;
var _log = process.log;
var restore = function() {
  process.stdout.write = _write;
  process.log = _log;
};
var stdout = function() {
  debug2("capturing stdout");
  let logs = [];
  const { write } = process.stdout;
  const { log: log2 } = process;
  if (log2) {
    process.log = function(str) {
      logs.push(str);
      return log2.apply(this, arguments);
    };
  }
  process.stdout.write = function(str) {
    logs.push(str);
    return write.apply(this, arguments);
  };
  return {
    toString() {
      return logs.join("");
    },
    data: logs,
    restore,
    reset: () => {
      debug2("resetting captured stdout");
      logs = [];
    }
  };
};
var initialOutput = "";
var capturedOutput = null;
var initCapture = () => capturedOutput = stdout();
var cutInitialOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  initialOutput = capturedOutput.toString();
  capturedOutput.reset();
};
var resetCapture = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  capturedOutput.reset();
};
var getCapturedOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  return capturedOutput.toString();
};
var getInitialOutput = () => initialOutput;

// lib/httpClient/config.ts
var import_axios = require("axios");
var isRetriableError = (err) => {
  if (err.code === "ECONNABORTED") {
    return true;
  }
  if (err.code === "ECONNREFUSED") {
    return true;
  }
  if (err.code === "ETIMEDOUT") {
    return true;
  }
  if (!(0, import_axios.isAxiosError)(err)) {
    return false;
  }
  return !!(err?.response?.status && 500 <= err.response.status && err.response.status < 600);
};
var getDelay = (i) => [5 * 1e3, 10 * 1e3, 30 * 1e3][i - 1];
var baseURL = "https://cy.currents.dev";
var getAPIBaseUrl = () => baseURL ?? "https://cy.currents.dev";
var setAPIBaseUrl = (url) => baseURL = url ?? "https://cy.currents.dev";

// lib/httpClient/httpClient.ts
var import_axios2 = __toESM(require("axios"));
var import_axios_retry = __toESM(require("axios-retry"));
var import_debug7 = __toESM(require("debug"));
var import_lodash5 = __toESM(require("lodash"));
var import_pretty_ms = __toESM(require("pretty-ms"));

// lib/config/config.ts
var import_debug5 = __toESM(require("debug"));
var import_ts_pattern2 = require("ts-pattern");

// lib/bootstrap/bootstrap.ts
var import_cy2 = require("cy2");
var import_debug4 = __toESM(require("debug"));
var import_execa = __toESM(require("execa"));
var import_fs = __toESM(require("fs"));

// lib/errors.ts
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "";
  }
};

// lib/fs.ts
var import_tmp_promise = require("tmp-promise");
var createTempFile = async () => {
  const { path: path4 } = await (0, import_tmp_promise.file)();
  return path4;
};

// lib/log.ts
var import_chalk = __toESM(require("chalk"));
var import_util = __toESM(require("util"));
var log = (...args) => console.log(import_util.default.format(...args));
var info = log;
var format = import_util.default.format;
var withError = (msg) => import_chalk.default.bgRed.white(" ERROR ") + " " + msg;
var withWarning = (msg) => import_chalk.default.bgYellow.black(" WARNING ") + " " + msg;
var warn = (...args) => log(withWarning(import_util.default.format(...args)));
var error = (...args) => log(withError(import_util.default.format(...args)) + "\n");
var title = (color, ...args) => info("\n  " + import_chalk.default[color].bold(import_util.default.format(...args)) + "  \n");
var divider = () => console.log("\n" + import_chalk.default.gray(Array(100).fill("=").join("")) + "\n");
var spacer = (n = 0) => console.log(Array(n).fill("").join("\n"));
var cyan = import_chalk.default.cyan;
var blue = import_chalk.default.blueBright;
var red = import_chalk.default.red;
var green = import_chalk.default.greenBright;
var gray = import_chalk.default.gray;
var white = import_chalk.default.white;
var magenta = import_chalk.default.magenta;
var bold = import_chalk.default.bold;
var yellow = import_chalk.default.yellow;
var dim = import_chalk.default.dim;

// lib/bootstrap/serializer.ts
var import_debug3 = __toESM(require("debug"));
var import_lodash = __toESM(require("lodash"));
var import_nanoid = require("nanoid");
var debug3 = (0, import_debug3.default)("currents:boot");
var getDummySpec = (0, import_nanoid.customAlphabet)("abcdefghijklmnopqrstuvwxyz", 10);
function getBootstrapArgs({
  params,
  tempFilePath
}) {
  return import_lodash.default.chain(getCypressCLIParams(params)).thru((opts) => ({
    ...opts,
    // merge the env with the currents specific env variables
    env: {
      ...opts.env ?? {},
      currents_temp_file: tempFilePath,
      currents_debug_enabled: process.env.DEBUG?.includes("currents:") ? true : false
    }
  })).tap((opts) => {
    debug3("cypress bootstrap params: %o", opts);
  }).thru(serializeOptions).tap((opts) => {
    debug3("cypress bootstrap serialized params: %o", opts);
  }).thru((args) => {
    return [
      ...args,
      "--spec",
      getDummySpec(),
      params.testingType === "component" ? "--component" : "--e2e"
    ];
  }).value();
}
function getCypressCLIParams(params) {
  const result = getCypressRunAPIParams(params);
  const testingType = result.testingType === "component" ? {
    component: true
  } : {};
  return {
    ...import_lodash.default.omit(result, "testingType"),
    ...testingType
  };
}
function serializeOptions(options) {
  return Object.entries(options).flatMap(([key, value]) => {
    const _key = dashed(key);
    if (typeof value === "boolean") {
      return value === true ? [`--${_key}`] : [`--${_key}`, false];
    }
    if (import_lodash.default.isObject(value)) {
      return [`--${_key}`, serializeComplexParam(value)];
    }
    return [`--${_key}`, value.toString()];
  });
}
function serializeComplexParam(param) {
  return JSON.stringify(param);
}
var dashed = (v) => v.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());

// lib/bootstrap/bootstrap.ts
var debug4 = (0, import_debug4.default)("currents:boot");
var bootCypress = async (params) => {
  debug4("booting cypress...");
  const tempFilePath = await createTempFile();
  const cypressBin = await (0, import_cy2.getBinPath)(require2.resolve("cypress"));
  debug4("cypress executable location: %s", cypressBin);
  const args = getBootstrapArgs({ tempFilePath, params });
  debug4("booting cypress with args: %o", args);
  const { stdout: stdout2, stderr } = await execCypress(cypressBin, args);
  if (!import_fs.default.existsSync(tempFilePath)) {
    throw new Error(
      `Cannot resolve cypress configuration from ${tempFilePath}. Please report the issue.`
    );
  }
  try {
    const f = import_fs.default.readFileSync(tempFilePath, "utf-8");
    if (!f) {
      throw new Error("Is cypress-cloud/plugin installed?");
    }
    debug4("cypress config '%s': '%s'", tempFilePath, f);
    return JSON.parse(f);
  } catch (err) {
    debug4("read config temp file failed: %o", err);
    info(bold("Cypress stdout:\n"), stdout2);
    info(bold("Cypress stderr:\n"), stderr);
    throw new ValidationError(`Unable to resolve cypress configuration
- make sure that 'cypress-cloud/plugin' is installed
- report the issue together with cypress stdout and stderr
`);
  }
};
async function execCypress(cypressBin, args) {
  let stdout2 = "";
  let stderr = "";
  try {
    await (0, import_execa.default)(cypressBin, ["run", ...args], {
      stdio: "pipe",
      env: {
        ...process.env,
        // prevent warnings about recording mode
        CYPRESS_RECORD_KEY: void 0,
        CYPRESS_PROJECT_ID: void 0
      }
    });
  } catch (err) {
    debug4("exec cypress failed (certain failures are expected): %o", err);
    stdout2 = err.stdout;
    stderr = err.stderr;
  }
  return { stdout: stdout2, stderr };
}

// lib/config/path.ts
var import_is_absolute = __toESM(require("is-absolute"));
var import_lodash2 = __toESM(require("lodash"));
var import_path = __toESM(require("path"));
var defaultFilenames = [
  "currents.config.js",
  "currents.config.cjs",
  "currents.config.mjs"
];
function getConfigFilePath(projectRoot = null, explicitConfigFilePath) {
  const prefix = projectRoot ?? process.cwd();
  if (import_lodash2.default.isString(explicitConfigFilePath) && (0, import_is_absolute.default)(explicitConfigFilePath)) {
    return [explicitConfigFilePath];
  }
  if (import_lodash2.default.isString(explicitConfigFilePath)) {
    return [normalizePath(prefix, explicitConfigFilePath)];
  }
  return defaultFilenames.map((p) => normalizePath(prefix, p));
}
function normalizePath(prefix, filename) {
  return `file://${import_path.default.resolve(prefix, filename)}`;
}

// lib/config/config.ts
var debug5 = (0, import_debug5.default)("currents:config");
var _config = null;
var defaultConfig = {
  e2e: {
    batchSize: 3
  },
  component: {
    batchSize: 5
  },
  cloudServiceUrl: "https://cy.currents.dev",
  networkHeaders: void 0
};
async function getCurrentsConfig(projectRoot, explicitConfigFilePath) {
  if (_config) {
    return _config;
  }
  const configFilePath = getConfigFilePath(projectRoot, explicitConfigFilePath);
  for (const filepath of configFilePath) {
    const config = (0, import_ts_pattern2.match)(await loadConfigFile(filepath)).with({ default: import_ts_pattern2.P.not(import_ts_pattern2.P.nullish) }, (c) => c.default).with(import_ts_pattern2.P.not(import_ts_pattern2.P.nullish), (c) => c).otherwise(() => null);
    if (config) {
      debug5("loaded currents config from '%s'\n%O", filepath, config);
      info("Using config file: '%s'", filepath);
      _config = {
        ...defaultConfig,
        ...config
      };
      return _config;
    }
  }
  warn(
    "Failed to load config file, falling back to the default config. Attempted locations: %s",
    configFilePath
  );
  _config = defaultConfig;
  return _config;
}
async function loadConfigFile(filepath) {
  try {
    debug5("loading currents config file from '%s'", filepath);
    return await import(filepath);
  } catch (e) {
    debug5("failed loading config file from: %s", e);
    return null;
  }
}
async function getMergedConfig(params) {
  debug5("resolving cypress config");
  const cypressResolvedConfig = await bootCypress(params);
  debug5("cypress resolvedConfig: %O", cypressResolvedConfig);
  const rawE2EPattern = cypressResolvedConfig.rawJson?.e2e?.specPattern;
  let additionalIgnorePattern = [];
  if (params.testingType === "component" && rawE2EPattern) {
    additionalIgnorePattern = rawE2EPattern;
  }
  const result = {
    projectRoot: cypressResolvedConfig?.projectRoot || process.cwd(),
    projectId: params.projectId,
    specPattern: cypressResolvedConfig?.specPattern || "**/*.*",
    excludeSpecPattern: (
      // @ts-ignore
      cypressResolvedConfig?.resolved.excludeSpecPattern.value ?? []
    ),
    additionalIgnorePattern,
    resolved: cypressResolvedConfig,
    experimentalCoverageRecording: params.experimentalCoverageRecording
  };
  debug5("merged config: %O", result);
  return result;
}

// lib/config/params.ts
var import_debug6 = __toESM(require("debug"));
var import_lodash3 = __toESM(require("lodash"));
var debug6 = (0, import_debug6.default)("currents:validateParams");
async function resolveCurrentsParams(params) {
  const configFromFile = await getCurrentsConfig(
    params.project,
    params.cloudConfigFile
  );
  debug6("resolving currents params: %o", params);
  debug6("resolving currents config file: %o", configFromFile);
  const cloudServiceUrl = params.cloudServiceUrl ?? process.env.CURRENTS_API_URL ?? configFromFile.cloudServiceUrl;
  const recordKey = params.recordKey ?? process.env.CURRENTS_RECORD_KEY ?? configFromFile.recordKey;
  const projectId = params.projectId ?? process.env.CURRENTS_PROJECT_ID ?? configFromFile.projectId;
  const testingType = params.testingType ?? "e2e";
  const batchSize = testingType === "e2e" ? configFromFile.e2e.batchSize : configFromFile.component.batchSize;
  return {
    ...params,
    cloudServiceUrl,
    recordKey,
    projectId,
    batchSize,
    testingType
  };
}
var projectIdError = `Cannot resolve projectId. Please use one of the following:
- provide it as a "projectId" property for "run" API method
- set CURRENTS_PROJECT_ID environment variable
- set "projectId" in "currents.config.{c}js" file`;
var cloudServiceUrlError = `Cannot resolve cloud service URL. Please use one of the following:
- provide it as a "cloudServiceUrl" property for "run" API method
- set CURRENTS_API_URL environment variable
- set "cloudServiceUrl" in "currents.config.{c}js" file`;
var cloudServiceInvalidUrlError = `Invalid cloud service URL provided`;
var recordKeyError = `Cannot resolve record key. Please use one of the following:

- pass it as a CLI flag '-k, --key <record-key>'
- provide it as a "recordKey" property for "run" API method
- set CURRENTS_RECORD_KEY environment variable
- set "recordKey" in "currents.config.{c}js" file
`;
async function validateParams(_params) {
  const params = await resolveCurrentsParams(_params);
  debug6("validating currents params: %o", params);
  if (!params.cloudServiceUrl) {
    throw new ValidationError(cloudServiceUrlError);
  }
  if (!params.projectId) {
    throw new ValidationError(projectIdError);
  }
  if (!params.recordKey) {
    throw new ValidationError(recordKeyError);
  }
  validateURL(params.cloudServiceUrl);
  const requiredParameters = [
    "testingType",
    "batchSize",
    "projectId"
  ];
  requiredParameters.forEach((key) => {
    if (typeof params[key] === "undefined") {
      error('Missing required parameter "%s"', key);
      throw new Error("Missing required parameter");
    }
  });
  params.tag = parseTags(params.tag);
  params.autoCancelAfterFailures = getAutoCancelValue(
    params.autoCancelAfterFailures
  );
  debug6("validated currents params: %o", params);
  return params;
}
function getAutoCancelValue(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value ? 1 : false;
  }
  if (typeof value === "number" && value > 0) {
    return value;
  }
  throw new ValidationError(
    `autoCancelAfterFailures: should be a positive integer or "false". Got: "${value}"`
  );
}
function isOffline(params) {
  return params.record === false;
}
function parseTags(tagString) {
  if (!tagString) {
    return [];
  }
  if (Array.isArray(tagString)) {
    return tagString.filter(Boolean);
  }
  return tagString.split(",").map((tag) => tag.trim()).filter(Boolean);
}
function validateURL(url) {
  try {
    new URL(url);
  } catch (err) {
    throw new ValidationError(`${cloudServiceInvalidUrlError}: "${url}"`);
  }
}
function getCypressRunAPIParams(params) {
  return {
    ...import_lodash3.default.pickBy(
      import_lodash3.default.omit(params, [
        "cloudDebug",
        "cloudConfigFile",
        "autoCancelAfterFailures",
        "cloudServiceUrl",
        "batchSize",
        "projectId",
        "key",
        "recordKey",
        "record",
        "group",
        "parallel",
        "tag",
        "ciBuildId",
        "spec",
        "exit",
        "headless",
        "experimentalCoverageRecording"
      ]),
      Boolean
    ),
    record: false
  };
}
function preprocessParams(params) {
  return {
    ...params,
    spec: processSpecParam(params.spec)
  };
}
function processSpecParam(spec) {
  if (!spec) {
    return void 0;
  }
  if (Array.isArray(spec)) {
    return import_lodash3.default.flatten(spec.map((i) => i.split(",")));
  }
  return spec.split(",");
}

// lib/httpClient/printErrors.ts
var import_lodash4 = __toESM(require("lodash"));
function maybePrintErrors(err) {
  if (!err.response?.data || !err.response?.status) {
    return;
  }
  const { message, errors } = err.response.data;
  switch (err.response.status) {
    case 401:
      warn("Received 401 Unauthorized");
      break;
    case 422:
      spacer(1);
      warn(...formatGenericError(message, errors));
      spacer(1);
      break;
    default:
      break;
  }
}
function formatGenericError(message, errors) {
  if (!import_lodash4.default.isString(message)) {
    return ["Unexpected error from the cloud service"];
  }
  if (errors?.length === 0) {
    return [message];
  }
  return [
    message,
    `
${(errors ?? []).map((e) => `  - ${e}`).join("\n")}
`
  ];
}

// lib/httpClient/httpClient.ts
var debug7 = (0, import_debug7.default)("currents:api");
var MAX_RETRIES = 3;
var TIMEOUT_MS = 30 * 1e3;
var _client = null;
async function getClient() {
  if (_client) {
    return _client;
  }
  const currentsConfig = await getCurrentsConfig();
  _client = import_axios2.default.create({
    baseURL: getAPIBaseUrl(),
    timeout: TIMEOUT_MS
  });
  _client.interceptors.request.use((config) => {
    const ccyVerson = _currentsVersion ?? "0.0.0";
    const headers = {
      ...config.headers,
      // @ts-ignore
      "x-cypress-request-attempt": config["axios-retry"]?.retryCount ?? 0,
      "x-cypress-version": _cypressVersion ?? "0.0.0",
      "x-ccy-version": ccyVerson,
      "User-Agent": `cypress-cloud/${ccyVerson}`
    };
    if (_runId) {
      headers["x-cypress-run-id"] = _runId;
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/json";
    }
    if (currentsConfig.networkHeaders) {
      const filteredHeaders = import_lodash5.default.omit(currentsConfig.networkHeaders, [
        "x-cypress-request-attempt",
        "x-cypress-version",
        "x-ccy-version",
        "x-cypress-run-id",
        "Content-Type"
      ]);
      debug7("using custom network headers: %o", filteredHeaders);
      Object.assign(headers, filteredHeaders);
    }
    const req = {
      ...config,
      headers
    };
    debug7("network request: %o", {
      ...import_lodash5.default.pick(req, "method", "url", "headers"),
      data: Buffer.isBuffer(req.data) ? "buffer" : req.data
    });
    return req;
  });
  (0, import_axios_retry.default)(_client, {
    retries: MAX_RETRIES,
    retryCondition: isRetriableError,
    retryDelay: getDelay,
    // @ts-ignore
    onRetry,
    shouldResetTimeout: true
  });
  return _client;
}
var _runId = void 0;
var setRunId = (runId) => {
  _runId = runId;
};
var _cypressVersion = void 0;
var setCypressVersion = (cypressVersion) => {
  _cypressVersion = cypressVersion;
};
var _currentsVersion = void 0;
var setCurrentsVersion = (v) => {
  _currentsVersion = v;
};
function onRetry(retryCount, err, config) {
  warn(
    "Network request '%s' failed: '%s'. Next attempt is in %s (%d/%d).",
    `${config.method} ${config.url}`,
    err.message,
    (0, import_pretty_ms.default)(getDelay(retryCount)),
    retryCount,
    MAX_RETRIES
  );
}
var makeRequest = async (config) => {
  return (await getClient())(config).then((res) => {
    debug7("network response: %o", import_lodash5.default.omit(res, "request", "config"));
    return res;
  }).catch((error2) => {
    maybePrintErrors(error2);
    throw new ValidationError(error2.message);
  });
};

// lib/init.ts
var cypressPkg = require2("cypress/package.json");
var pkg = require2("cypress-cloud/package.json");
initCapture();
setCypressVersion(cypressPkg.version);
setCurrentsVersion(pkg.version);

// lib/run.ts
var import_debug22 = __toESM(require("debug"));
var import_plur = __toESM(require("plur"));

// legal.ts
function getLegalNotice() {
  return `
Copyright (C) ${(/* @__PURE__ */ new Date()).getFullYear()} Currents Software Inc https://currents.dev
This is free software, and you are welcome to redistribute it under certain
conditions. This program comes with no warranty. Parts of this program are MIT
licensed. Refer to the license for details
https://github.com/currents-dev/cypress-cloud/blob/main/LICENSE.md
`;
}

// lib/api/warnings.ts
var import_lodash6 = __toESM(require("lodash"));
function printWarnings(warnings) {
  warn("Notice from cloud service:");
  warnings.map((w) => {
    spacer(1);
    info(magenta.bold(w.message));
    Object.entries(import_lodash6.default.omit(w, "message")).map(([key, value]) => {
      info("- %s: %s", key, value);
    });
    spacer(1);
  });
}

// lib/api/api.ts
var createRun = async (payload) => {
  const response = await makeRequest({
    method: "POST",
    url: "/runs",
    data: payload
  });
  if ((response.data.warnings?.length ?? 0) > 0) {
    printWarnings(response.data.warnings);
  }
  return response.data;
};
var createInstance = async ({
  runId,
  groupId,
  machineId,
  platform: platform2
}) => {
  const response = await makeRequest({
    method: "POST",
    url: `runs/${runId}/instances`,
    data: {
      runId,
      groupId,
      machineId,
      platform: platform2
    }
  });
  return response.data;
};
var createBatchedInstances = async (data) => {
  const respone = await makeRequest({
    method: "POST",
    url: `runs/${data.runId}/cy/instances`,
    data
  });
  return respone.data;
};
var setInstanceTests = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/tests`,
  data: payload
}).then((result) => result.data);
var updateInstanceResults = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/results`,
  data: payload
}).then((result) => result.data);
var reportInstanceResultsMerged = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/cy/results`,
  data: payload
}).then((result) => result.data);
var updateInstanceStdout = (instanceId, stdout2) => makeRequest({
  method: "PUT",
  url: `instances/${instanceId}/stdout`,
  data: {
    stdout: stdout2
  }
});

// lib/ciProvider/ciProvider.ts
var import_debug8 = __toESM(require("debug"));
var import_lodash7 = __toESM(require("lodash"));
var debug8 = (0, import_debug8.default)("currents:ci");
var join = (char, ...pieces) => {
  return import_lodash7.default.chain(pieces).compact().join(char).value();
};
var toCamelObject = (obj, key) => {
  return import_lodash7.default.set(obj, import_lodash7.default.camelCase(key), process.env[key]);
};
var extract = (envKeys) => {
  return import_lodash7.default.transform(envKeys, toCamelObject, {});
};
var isTeamFoundation = () => {
  return process.env.TF_BUILD && process.env.TF_BUILD_BUILDNUMBER;
};
var isAzureCi = () => {
  return process.env.TF_BUILD && process.env.AZURE_HTTP_USER_AGENT;
};
var isAWSCodeBuild = () => {
  return import_lodash7.default.some(process.env, (val, key) => {
    return /^CODEBUILD_/.test(key);
  });
};
var isBamboo = () => {
  return process.env.bamboo_buildNumber;
};
var isCodeshipBasic = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && process.env.CODESHIP;
};
var isCodeshipPro = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && !process.env.CODESHIP;
};
var isConcourse = () => {
  return import_lodash7.default.some(process.env, (val, key) => {
    return /^CONCOURSE_/.test(key);
  });
};
var isGitlab = () => {
  return process.env.GITLAB_CI || process.env.CI_SERVER_NAME && /^GitLab/.test(process.env.CI_SERVER_NAME);
};
var isGoogleCloud = () => {
  return process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT;
};
var isJenkins = () => {
  return process.env.JENKINS_URL || process.env.JENKINS_HOME || process.env.JENKINS_VERSION || process.env.HUDSON_URL || process.env.HUDSON_HOME;
};
var isWercker = () => {
  return process.env.WERCKER || process.env.WERCKER_MAIN_PIPELINE_STARTED;
};
var CI_PROVIDERS = {
  appveyor: "APPVEYOR",
  azure: isAzureCi,
  awsCodeBuild: isAWSCodeBuild,
  bamboo: isBamboo,
  bitbucket: "BITBUCKET_BUILD_NUMBER",
  buildkite: "BUILDKITE",
  circle: "CIRCLECI",
  codeshipBasic: isCodeshipBasic,
  codeshipPro: isCodeshipPro,
  concourse: isConcourse,
  codeFresh: "CF_BUILD_ID",
  drone: "DRONE",
  githubActions: "GITHUB_ACTIONS",
  gitlab: isGitlab,
  goCD: "GO_JOB_NAME",
  googleCloud: isGoogleCloud,
  jenkins: isJenkins,
  semaphore: "SEMAPHORE",
  shippable: "SHIPPABLE",
  teamcity: "TEAMCITY_VERSION",
  teamfoundation: isTeamFoundation,
  travis: "TRAVIS",
  wercker: isWercker,
  netlify: "NETLIFY",
  layerci: "LAYERCI"
};
function _detectProviderName() {
  const { env } = process;
  return import_lodash7.default.findKey(CI_PROVIDERS, (value) => {
    if (import_lodash7.default.isString(value)) {
      return env[value];
    }
    if (import_lodash7.default.isFunction(value)) {
      return value();
    }
  });
}
var _providerCiParams = () => {
  return {
    appveyor: extract([
      "APPVEYOR_JOB_ID",
      "APPVEYOR_ACCOUNT_NAME",
      "APPVEYOR_PROJECT_SLUG",
      "APPVEYOR_BUILD_NUMBER",
      "APPVEYOR_BUILD_VERSION",
      "APPVEYOR_PULL_REQUEST_NUMBER",
      "APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH"
    ]),
    azure: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID",
      "BUILD_REPOSITORY_URI"
    ]),
    awsCodeBuild: extract([
      "CODEBUILD_BUILD_ID",
      "CODEBUILD_BUILD_NUMBER",
      "CODEBUILD_RESOLVED_SOURCE_VERSION",
      "CODEBUILD_SOURCE_REPO_URL",
      "CODEBUILD_SOURCE_VERSION"
    ]),
    bamboo: extract([
      "bamboo_buildNumber",
      "bamboo_buildResultsUrl",
      "bamboo_planRepository_repositoryUrl",
      "bamboo_buildKey"
    ]),
    bitbucket: extract([
      "BITBUCKET_REPO_SLUG",
      "BITBUCKET_REPO_OWNER",
      "BITBUCKET_BUILD_NUMBER",
      "BITBUCKET_PARALLEL_STEP",
      "BITBUCKET_STEP_RUN_NUMBER",
      // the PR variables are only set on pull request builds
      "BITBUCKET_PR_ID",
      "BITBUCKET_PR_DESTINATION_BRANCH",
      "BITBUCKET_PR_DESTINATION_COMMIT"
    ]),
    buildkite: extract([
      "BUILDKITE_REPO",
      "BUILDKITE_SOURCE",
      "BUILDKITE_JOB_ID",
      "BUILDKITE_BUILD_ID",
      "BUILDKITE_BUILD_URL",
      "BUILDKITE_BUILD_NUMBER",
      "BUILDKITE_PULL_REQUEST",
      "BUILDKITE_PULL_REQUEST_REPO",
      "BUILDKITE_PULL_REQUEST_BASE_BRANCH"
    ]),
    circle: extract([
      "CIRCLE_JOB",
      "CIRCLE_BUILD_NUM",
      "CIRCLE_BUILD_URL",
      "CIRCLE_PR_NUMBER",
      "CIRCLE_PR_REPONAME",
      "CIRCLE_PR_USERNAME",
      "CIRCLE_COMPARE_URL",
      "CIRCLE_WORKFLOW_ID",
      "CIRCLE_PULL_REQUEST",
      "CIRCLE_REPOSITORY_URL",
      "CI_PULL_REQUEST"
    ]),
    codeshipBasic: extract([
      "CI_BUILD_ID",
      "CI_REPO_NAME",
      "CI_BUILD_URL",
      "CI_PROJECT_ID",
      "CI_BUILD_NUMBER",
      "CI_PULL_REQUEST"
    ]),
    // CodeshipPro provides very few CI variables
    // https://documentation.codeship.com/pro/builds-and-configuration/environment-variables/
    codeshipPro: extract(["CI_BUILD_ID", "CI_REPO_NAME", "CI_PROJECT_ID"]),
    // https://concourse-ci.org/implementing-resource-types.html#resource-metadata
    concourse: extract([
      "BUILD_ID",
      "BUILD_NAME",
      "BUILD_JOB_NAME",
      "BUILD_PIPELINE_NAME",
      "BUILD_TEAM_NAME",
      "ATC_EXTERNAL_URL"
    ]),
    // https://codefresh.io/docs/docs/codefresh-yaml/variables/
    codeFresh: extract([
      "CF_BUILD_ID",
      "CF_BUILD_URL",
      "CF_CURRENT_ATTEMPT",
      "CF_STEP_NAME",
      "CF_PIPELINE_NAME",
      "CF_PIPELINE_TRIGGER_ID",
      // variables added for pull requests
      "CF_PULL_REQUEST_ID",
      "CF_PULL_REQUEST_IS_FORK",
      "CF_PULL_REQUEST_NUMBER",
      "CF_PULL_REQUEST_TARGET"
    ]),
    drone: extract([
      "DRONE_JOB_NUMBER",
      "DRONE_BUILD_LINK",
      "DRONE_BUILD_NUMBER",
      "DRONE_PULL_REQUEST"
    ]),
    // https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
    githubActions: extract([
      "GITHUB_WORKFLOW",
      "GITHUB_ACTION",
      "GITHUB_EVENT_NAME",
      "GITHUB_RUN_ID",
      "GITHUB_RUN_ATTEMPT",
      "GITHUB_REPOSITORY"
    ]),
    // see https://docs.gitlab.com/ee/ci/variables/
    gitlab: extract([
      // pipeline is common among all jobs
      "CI_PIPELINE_ID",
      "CI_PIPELINE_URL",
      // individual jobs
      "CI_BUILD_ID",
      // build id and job id are aliases
      "CI_JOB_ID",
      "CI_JOB_URL",
      "CI_JOB_NAME",
      // other information
      "GITLAB_HOST",
      "CI_PROJECT_ID",
      "CI_PROJECT_URL",
      "CI_REPOSITORY_URL",
      "CI_ENVIRONMENT_URL",
      "CI_DEFAULT_BRANCH"
      // for PRs: https://gitlab.com/gitlab-org/gitlab-ce/issues/23902
    ]),
    // https://docs.gocd.org/current/faq/dev_use_current_revision_in_build.html#standard-gocd-environment-variables
    goCD: extract([
      "GO_SERVER_URL",
      "GO_ENVIRONMENT_NAME",
      "GO_PIPELINE_NAME",
      "GO_PIPELINE_COUNTER",
      "GO_PIPELINE_LABEL",
      "GO_STAGE_NAME",
      "GO_STAGE_COUNTER",
      "GO_JOB_NAME",
      "GO_TRIGGER_USER",
      "GO_REVISION",
      "GO_TO_REVISION",
      "GO_FROM_REVISION",
      "GO_MATERIAL_HAS_CHANGED"
    ]),
    googleCloud: extract([
      // individual jobs
      "BUILD_ID",
      "PROJECT_ID",
      // other information
      "REPO_NAME",
      "BRANCH_NAME",
      "TAG_NAME",
      "COMMIT_SHA",
      "SHORT_SHA"
      // https://cloud.google.com/cloud-build/docs/api/reference/rest/Shared.Types/Build
    ]),
    jenkins: extract(["BUILD_ID", "BUILD_URL", "BUILD_NUMBER", "ghprbPullId"]),
    // https://semaphoreci.com/docs/available-environment-variables.html
    // some come from v1, some from v2 of semaphore
    semaphore: extract([
      "SEMAPHORE_BRANCH_ID",
      "SEMAPHORE_BUILD_NUMBER",
      "SEMAPHORE_CURRENT_JOB",
      "SEMAPHORE_CURRENT_THREAD",
      "SEMAPHORE_EXECUTABLE_UUID",
      "SEMAPHORE_GIT_BRANCH",
      "SEMAPHORE_GIT_DIR",
      "SEMAPHORE_GIT_REF",
      "SEMAPHORE_GIT_REF_TYPE",
      "SEMAPHORE_GIT_REPO_SLUG",
      "SEMAPHORE_GIT_SHA",
      "SEMAPHORE_GIT_URL",
      "SEMAPHORE_JOB_COUNT",
      "SEMAPHORE_JOB_ID",
      // v2
      "SEMAPHORE_JOB_NAME",
      "SEMAPHORE_JOB_UUID",
      // v1
      "SEMAPHORE_PIPELINE_ID",
      "SEMAPHORE_PLATFORM",
      "SEMAPHORE_PROJECT_DIR",
      "SEMAPHORE_PROJECT_HASH_ID",
      "SEMAPHORE_PROJECT_ID",
      // v2
      "SEMAPHORE_PROJECT_NAME",
      "SEMAPHORE_PROJECT_UUID",
      // v1
      "SEMAPHORE_REPO_SLUG",
      "SEMAPHORE_TRIGGER_SOURCE",
      "SEMAPHORE_WORKFLOW_ID",
      "PULL_REQUEST_NUMBER"
      // pull requests from forks ONLY
    ]),
    // see http://docs.shippable.com/ci/env-vars/
    shippable: extract([
      // build variables
      "SHIPPABLE_BUILD_ID",
      // "5b93354cabfabb07007f01fd"
      "SHIPPABLE_BUILD_NUMBER",
      // "4"
      "SHIPPABLE_COMMIT_RANGE",
      // "sha1...sha2"
      "SHIPPABLE_CONTAINER_NAME",
      // "c.exec.cypress-example-kitchensink.4.1"
      "SHIPPABLE_JOB_ID",
      // "1"
      "SHIPPABLE_JOB_NUMBER",
      // "1"
      "SHIPPABLE_REPO_SLUG",
      // "<username>/<repo>"
      // additional information that Shippable provides
      "IS_FORK",
      // "true"
      "IS_GIT_TAG",
      // "false"
      "IS_PRERELEASE",
      // "false"
      "IS_RELEASE",
      // "false"
      "REPOSITORY_URL",
      // "https://github.com/....git"
      "REPO_FULL_NAME",
      // "<username>/<repo>"
      "REPO_NAME",
      // "cypress-example-kitchensink"
      "BUILD_URL",
      // "https://app.shippable.com/github/<username>/<repo>/runs/1"
      // Pull request information
      "BASE_BRANCH",
      // Name of the target branch into which the pull request changes will be merged.
      "HEAD_BRANCH",
      // This is only set for pull requests and is the name of the branch the pull request was opened from.
      "IS_PULL_REQUEST",
      // "false" or "true"
      "PULL_REQUEST",
      // Pull request number if the job is a pull request. If not, this will be set to false.
      "PULL_REQUEST_BASE_BRANCH",
      // Name of the branch that the pull request will be merged into. It should be the same as BASE_BRANCH.
      "PULL_REQUEST_REPO_FULL_NAME"
      // Full name of the repository from where the pull request originated.
    ]),
    teamcity: null,
    teamfoundation: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID"
    ]),
    travis: extract([
      "TRAVIS_JOB_ID",
      "TRAVIS_BUILD_ID",
      "TRAVIS_BUILD_WEB_URL",
      "TRAVIS_REPO_SLUG",
      "TRAVIS_JOB_NUMBER",
      "TRAVIS_EVENT_TYPE",
      "TRAVIS_COMMIT_RANGE",
      "TRAVIS_BUILD_NUMBER",
      "TRAVIS_PULL_REQUEST",
      "TRAVIS_PULL_REQUEST_BRANCH",
      "TRAVIS_PULL_REQUEST_SHA"
    ]),
    wercker: null,
    // https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata
    netlify: extract([
      "BUILD_ID",
      "CONTEXT",
      "URL",
      "DEPLOY_URL",
      "DEPLOY_PRIME_URL",
      "DEPLOY_ID"
    ]),
    // https://layerci.com/docs/layerfile-reference/build-env
    layerci: extract([
      "LAYERCI_JOB_ID",
      "LAYERCI_RUNNER_ID",
      "RETRY_INDEX",
      "LAYERCI_PULL_REQUEST",
      "LAYERCI_REPO_NAME",
      "LAYERCI_REPO_OWNER",
      "LAYERCI_BRANCH",
      "GIT_TAG"
      // short hex for commits
    ])
  };
};
var _providerCommitParams = () => {
  const { env } = process;
  return {
    appveyor: {
      sha: env.APPVEYOR_REPO_COMMIT,
      // since APPVEYOR_REPO_BRANCH will be the target branch on a PR
      // we need to use PULL_REQUEST_HEAD_REPO_BRANCH if it exists.
      // e.g. if you have a PR: develop <- my-feature-branch
      // my-feature-branch is APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH
      // develop           is APPVEYOR_REPO_BRANCH
      branch: env.APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || env.APPVEYOR_REPO_BRANCH,
      message: join(
        "\n",
        env.APPVEYOR_REPO_COMMIT_MESSAGE,
        env.APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      ),
      authorName: env.APPVEYOR_REPO_COMMIT_AUTHOR,
      authorEmail: env.APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    awsCodeBuild: {
      sha: env.CODEBUILD_RESOLVED_SOURCE_VERSION,
      // branch: ???,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.CODEBUILD_SOURCE_REPO_URL
      // defaultBranch: ???
    },
    azure: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR,
      authorEmail: env.BUILD_REQUESTEDFOREMAIL
    },
    bamboo: {
      sha: env.bamboo_planRepository_revision,
      branch: env.bamboo_planRepository_branch,
      // message: ???
      authorName: env.bamboo_planRepository_username,
      // authorEmail: ???
      remoteOrigin: env.bamboo_planRepository_repositoryURL
      // defaultBranch: ???
    },
    bitbucket: {
      sha: env.BITBUCKET_COMMIT,
      branch: env.BITBUCKET_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    buildkite: {
      sha: env.BUILDKITE_COMMIT,
      branch: env.BUILDKITE_BRANCH,
      message: env.BUILDKITE_MESSAGE,
      authorName: env.BUILDKITE_BUILD_CREATOR,
      authorEmail: env.BUILDKITE_BUILD_CREATOR_EMAIL,
      remoteOrigin: env.BUILDKITE_REPO,
      defaultBranch: env.BUILDKITE_PIPELINE_DEFAULT_BRANCH
    },
    circle: {
      sha: env.CIRCLE_SHA1,
      branch: env.CIRCLE_BRANCH,
      // message: ???
      authorName: env.CIRCLE_USERNAME,
      // authorEmail: ???
      remoteOrigin: env.CIRCLE_REPOSITORY_URL
      // defaultBranch: ???
    },
    codeshipBasic: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeshipPro: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeFresh: {
      sha: env.CF_REVISION,
      branch: env.CF_BRANCH,
      message: env.CF_COMMIT_MESSAGE,
      authorName: env.CF_COMMIT_AUTHOR
    },
    drone: {
      sha: env.DRONE_COMMIT_SHA,
      // https://docs.drone.io/pipeline/environment/reference/drone-source-branch/
      branch: env.DRONE_SOURCE_BRANCH,
      message: env.DRONE_COMMIT_MESSAGE,
      authorName: env.DRONE_COMMIT_AUTHOR,
      authorEmail: env.DRONE_COMMIT_AUTHOR_EMAIL,
      remoteOrigin: env.DRONE_GIT_HTTP_URL,
      defaultBranch: env.DRONE_REPO_BRANCH
    },
    githubActions: {
      sha: env.GITHUB_SHA,
      branch: env.GH_BRANCH || env.GITHUB_REF,
      defaultBranch: env.GITHUB_BASE_REF,
      remoteBranch: env.GITHUB_HEAD_REF,
      runAttempt: env.GITHUB_RUN_ATTEMPT
    },
    gitlab: {
      sha: env.CI_COMMIT_SHA,
      branch: env.CI_COMMIT_REF_NAME,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.GITLAB_USER_NAME,
      authorEmail: env.GITLAB_USER_EMAIL,
      remoteOrigin: env.CI_REPOSITORY_URL,
      defaultBranch: env.CI_DEFAULT_BRANCH
    },
    googleCloud: {
      sha: env.COMMIT_SHA,
      branch: env.BRANCH_NAME
      // message: ??
      // authorName: ??
      // authorEmail: ??
      // remoteOrigin: ???
      // defaultBranch: ??
    },
    jenkins: {
      sha: env.GIT_COMMIT,
      branch: env.GIT_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    // Only from forks? https://semaphoreci.com/docs/available-environment-variables.html
    semaphore: {
      sha: env.SEMAPHORE_GIT_SHA,
      branch: env.SEMAPHORE_GIT_BRANCH,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.SEMAPHORE_GIT_REPO_SLUG
      // defaultBranch: ???
    },
    shippable: {
      sha: env.COMMIT,
      branch: env.BRANCH,
      message: env.COMMIT_MESSAGE,
      authorName: env.COMMITTER
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    snap: null,
    teamcity: null,
    teamfoundation: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR
    },
    travis: {
      sha: env.TRAVIS_PULL_REQUEST_SHA || env.TRAVIS_COMMIT,
      // for PRs, TRAVIS_BRANCH is the base branch being merged into
      branch: env.TRAVIS_PULL_REQUEST_BRANCH || env.TRAVIS_BRANCH,
      // authorName: ???
      // authorEmail: ???
      message: env.TRAVIS_COMMIT_MESSAGE
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    wercker: null,
    netlify: {
      sha: env.COMMIT_REF,
      branch: env.BRANCH,
      remoteOrigin: env.REPOSITORY_URL
    },
    layerci: {
      sha: env.GIT_COMMIT,
      branch: env.LAYERCI_BRANCH,
      message: env.GIT_COMMIT_TITLE
    }
  };
};
var _get = (fn) => {
  const providerName = getCiProvider();
  if (!providerName)
    return {};
  return import_lodash7.default.chain(fn()).get(providerName).value();
};
function checkForCiBuildFromCi(ciProvider) {
  if (ciProvider && detectableCiBuildIdProviders().includes(ciProvider))
    return true;
  throw new ValidationError(
    `Could not determine CI build ID from the environment. Please provide a unique CI build ID using the --ci-build-id CLI flag or 'ciBuildId' parameter for 'run' method.`
  );
}
function detectableCiBuildIdProviders() {
  return import_lodash7.default.chain(_providerCiParams()).omitBy(import_lodash7.default.isNull).keys().value();
}
function getCiProvider() {
  return _detectProviderName() || null;
}
function getCiParams() {
  return _get(_providerCiParams);
}
function getCommitParams() {
  return _get(_providerCommitParams);
}
function getCI(ciBuildId) {
  const params = getCiParams();
  const provider = getCiProvider();
  if (!ciBuildId)
    checkForCiBuildFromCi(provider);
  debug8("detected CI provider: %s", provider);
  debug8("detected CI params: %O", params);
  return {
    params,
    provider
  };
}

// lib/ciProvider/merge.ts
var import_debug9 = __toESM(require("debug"));
var import_lodash8 = __toESM(require("lodash"));
var debug9 = (0, import_debug9.default)("currents:ci");
function getCommitDefaults(existingInfo) {
  debug9("git commit existing info");
  debug9(existingInfo);
  const commitParamsObj = getCommitParams();
  debug9("commit info from provider environment variables: %O", commitParamsObj);
  const combined = import_lodash8.default.transform(
    existingInfo,
    (memo, value, key) => {
      return memo[key] = import_lodash8.default.defaultTo(
        value || (commitParamsObj ? commitParamsObj[key] : null),
        null
      );
    }
  );
  debug9("combined git and environment variables from provider");
  debug9(combined);
  return combined;
}

// lib/coverage/index.ts
var import_promises = __toESM(require("fs/promises"));
var import_path3 = require("path");
var getCoverageFilePath = async (coverageFile = "./.nyc_output/out.json") => {
  const path4 = (0, import_path3.join)(process.cwd(), coverageFile);
  try {
    await import_promises.default.access(path4);
    return {
      path: path4,
      error: false
    };
  } catch (error2) {
    return {
      path: path4,
      error: error2
    };
  }
};

// lib/cypress/cypress.ts
var import_cypress = __toESM(require("cypress"));
var import_debug10 = __toESM(require("debug"));
var import_lodash9 = __toESM(require("lodash"));

// lib/lang.ts
var import_bluebird = __toESM(require("bluebird"));
import_bluebird.default.Promise.config({
  cancellation: true
});
var BPromise = import_bluebird.default.Promise;
var safe = (fn, ifFaled, ifSucceed) => async (...args) => {
  try {
    const r = await fn(...args);
    ifSucceed();
    return r;
  } catch (e) {
    return ifFaled(e);
  }
};

// lib/cypress/cypress.ts
var debug10 = (0, import_debug10.default)("currents:cypress");
function runBareCypress(params = {}) {
  const p = {
    ...params,
    ciBuildId: void 0,
    tag: void 0,
    parallel: void 0,
    record: false,
    group: void 0,
    spec: import_lodash9.default.flatten(params.spec).join(",")
  };
  debug10("Running bare Cypress with params %o", p);
  return import_cypress.default.run(p);
}
async function runSpecFile({ spec }, cypressRunOptions) {
  const runAPIOptions = getCypressRunAPIParams(cypressRunOptions);
  const options = {
    ...runAPIOptions,
    config: {
      ...runAPIOptions.config,
      trashAssetsBeforeRuns: false
    },
    env: {
      ...runAPIOptions.env,
      currents_ws: getWSSPort()
    },
    spec
  };
  debug10("running cypress with options %o", options);
  const result = await import_cypress.default.run(options);
  if (result.status === "failed") {
    warn('Cypress runner failed with message: "%s"', result.message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
  }
  debug10("cypress run result %o", result);
  return result;
}
var runSpecFileSafe = (spec, cypressRunOptions) => safe(
  runSpecFile,
  (error2) => {
    const message = `Cypress runnner crashed with an error:
${error2.message}
${error2.stack}}`;
    debug10("cypress run exception %o", error2);
    warn('Cypress runner crashed: "%s"', message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    return {
      status: "failed",
      failures: 1,
      message
    };
  },
  () => {
  }
)(spec, cypressRunOptions);

// lib/debug/index.ts
var import_debug11 = __toESM(require("debug"));
var import_ts_pattern3 = require("ts-pattern");
function activateDebug(mode) {
  (0, import_ts_pattern3.match)(mode).with(import_ts_pattern3.P.instanceOf(Array), (i) => i.forEach(setDebugMode)).with(true, () => setDebugMode("all" /* All */)).with(
    import_ts_pattern3.P.union(
      "all" /* All */,
      "currents" /* Currents */,
      "cypress" /* Cypress */,
      "commit-info" /* CommitInfo */
    ),
    (i) => setDebugMode(i)
  ).otherwise(() => setDebugMode("none" /* None */));
}
function setDebugMode(mode) {
  if (mode === "none" /* None */) {
    return;
  }
  const tokens = new Set(process.env.DEBUG ? process.env.DEBUG.split(",") : []);
  (0, import_ts_pattern3.match)(mode).with("all" /* All */, () => {
    tokens.add("commit-info" /* CommitInfo */);
    tokens.add("currents:*" /* Currents */);
    tokens.add("cypress:*" /* Cypress */);
  }).with("currents" /* Currents */, () => tokens.add("currents:*" /* Currents */)).with("cypress" /* Cypress */, () => tokens.add("cypress:*" /* Cypress */)).with("commit-info" /* CommitInfo */, () => tokens.add("commit-info" /* CommitInfo */)).otherwise(() => {
  });
  import_debug11.default.enable(Array.from(tokens).join(","));
}

// lib/env.ts
var isCurrents = () => !!process.env.CURRENTS_ENFORCE_IS_CURRENTS || getAPIBaseUrl() === "https://cy.currents.dev";

// lib/git.ts
var import_commit_info = require("@currents/commit-info");
var getGitInfo = async (projectRoot) => {
  const commit = await (0, import_commit_info.commitInfo)(projectRoot);
  return getCommitDefaults({
    branch: commit.branch,
    remoteOrigin: commit.remote,
    authorEmail: commit.email,
    authorName: commit.author,
    message: commit.message,
    sha: commit.sha,
    ghaEventData: commit.ghaEventData
  });
};

// lib/platform/browser.ts
var import_debug12 = __toESM(require("debug"));
var debug12 = (0, import_debug12.default)("currents:browser");
function guessBrowser(browser, availableBrowsers = []) {
  debug12(
    "guessing browser from '%s', available browsers: %o",
    browser,
    availableBrowsers
  );
  let result = availableBrowsers.find((b) => b.name === browser);
  if (result) {
    debug12("identified browser by name: %o", result);
    return {
      browserName: result.displayName,
      browserVersion: result.version
    };
  }
  result = availableBrowsers.find((b) => b.path === browser);
  if (result) {
    debug12("identified browser by path: %o", result);
    return {
      browserName: result.displayName ?? result.name,
      browserVersion: result.version
    };
  }
  warn("Unable to identify browser name and version");
  return {
    browserName: "unknown",
    browserVersion: "unknown"
  };
}

// lib/platform/platform.ts
var import_debug13 = __toESM(require("debug"));
var import_getos = __toESM(require("getos"));
var import_os = require("os");
var import_util2 = require("util");
var debug13 = (0, import_debug13.default)("currents:platform");
var getOsVersion = async () => {
  if ((0, import_os.platform)() === "linux") {
    try {
      const linuxOs = await (0, import_util2.promisify)(import_getos.default)();
      if ("dist" in linuxOs && "release" in linuxOs) {
        return [linuxOs.dist, linuxOs.release].join(" - ");
      } else {
        return (0, import_os.release)();
      }
    } catch {
      return (0, import_os.release)();
    }
  }
  return (0, import_os.release)();
};
var getPlatformInfo = async () => {
  const osVersion = await getOsVersion();
  const result = {
    osName: (0, import_os.platform)(),
    osVersion,
    osCpus: (0, import_os.cpus)(),
    osMemory: {
      free: (0, import_os.freemem)(),
      total: (0, import_os.totalmem)()
    }
  };
  debug13("platform info: %o", result);
  return result;
};

// lib/platform/index.ts
async function getPlatform({
  browser,
  config
}) {
  return {
    ...await getPlatformInfo(),
    ...guessBrowser(browser ?? "electron", config.resolved?.browsers)
  };
}

// lib/results/results.ts
var import_debug14 = __toESM(require("debug"));
var import_lodash10 = __toESM(require("lodash"));
var import_nanoid2 = require("nanoid");
var debug14 = (0, import_debug14.default)("currents:results");
var isSuccessResult = (result) => {
  return result.status === "finished";
};
var getScreenshotsSummary = (tests = []) => {
  return tests.flatMap(
    (test, i) => test.attempts.flatMap(
      (a, ai) => a.screenshots.flatMap((s) => ({
        ...s,
        testId: `r${i}`,
        testAttemptIndex: ai,
        screenshotId: (0, import_nanoid2.nanoid)()
      }))
    )
  );
};
var getStats = (stats) => {
  return {
    ...stats,
    wallClockDuration: stats.duration,
    wallClockStartedAt: stats.startedAt,
    wallClockEndedAt: stats.endedAt
  };
};
var getTestAttempt = (attempt) => {
  return {
    ...attempt,
    state: attempt.state,
    wallClockDuration: attempt.duration,
    wallClockStartedAt: attempt.startedAt
  };
};
var getInstanceResultPayload = (runResult, coverageFilePath) => {
  return {
    stats: getStats(runResult.stats),
    reporterStats: runResult.reporterStats,
    exception: runResult.error ?? null,
    video: !!runResult.video,
    // Did the instance generate a video?
    screenshots: getScreenshotsSummary(runResult.tests ?? []),
    hasCoverage: !!coverageFilePath,
    tests: runResult.tests?.map((test, i) => ({
      displayError: test.displayError,
      state: test.state,
      hooks: runResult.hooks,
      attempts: test.attempts?.map(getTestAttempt) ?? [],
      clientId: `r${i}`
    })) ?? []
  };
};
function getFakeTestFromException(error2, stats) {
  return {
    title: ["Unknown"],
    body: "",
    displayError: error2.split("\n")[0],
    state: "failed",
    hooks: [],
    attempts: [
      getTestAttempt({
        state: "failed",
        duration: 0,
        error: {
          name: "Error",
          message: error2.split("\n")[0],
          stack: error2
        },
        screenshots: [],
        startedAt: stats.startedAt,
        videoTimestamp: 0
      })
    ],
    clientId: "r0"
  };
}
var getInstanceTestsPayload = (runResult, config) => {
  return {
    config,
    tests: runResult.tests?.map((test, i) => ({
      title: test.title,
      config: null,
      body: test.body,
      clientId: `r${i}`,
      hookIds: []
    })) ?? [],
    hooks: runResult.hooks
  };
};
var summarizeTestResults = (input, config) => {
  if (!input.length) {
    return getEmptyCypressResults(config);
  }
  const overall = input.reduce(
    (acc, {
      totalDuration,
      totalFailed,
      totalPassed,
      totalPending,
      totalSkipped,
      totalTests,
      totalSuites
    }) => ({
      totalDuration: acc.totalDuration + totalDuration,
      totalSuites: acc.totalSuites + totalSuites,
      totalPending: acc.totalPending + totalPending,
      totalFailed: acc.totalFailed + totalFailed,
      totalSkipped: acc.totalSkipped + totalSkipped,
      totalPassed: acc.totalPassed + totalPassed,
      totalTests: acc.totalTests + totalTests
    }),
    emptyStats
  );
  const firstResult = input[0];
  const startItems = input.map((i) => i.startedTestsAt).sort();
  const endItems = input.map((i) => i.endedTestsAt).sort();
  const runs = input.map((i) => i.runs).flat();
  return {
    ...overall,
    runs,
    startedTestsAt: import_lodash10.default.first(startItems),
    endedTestsAt: import_lodash10.default.last(endItems),
    ...import_lodash10.default.pick(
      firstResult,
      "browserName",
      "browserVersion",
      "browserPath",
      "osName",
      "osVersion",
      "cypressVersion",
      "config"
    ),
    status: "finished"
  };
};
function getEmptyCypressResults(config) {
  return {
    ...emptyStats,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    runs: [],
    // @ts-ignore
    config
  };
}
var emptyStats = {
  totalDuration: 0,
  totalSuites: 0,
  totalPending: 0,
  totalFailed: 0,
  totalSkipped: 0,
  totalPassed: 0,
  totalTests: 0
};
var getDummyFailedTest = (start, error2) => ({
  title: ["Unknown"],
  state: "failed",
  body: "// This test is automatically generated due to execution failure",
  displayError: error2,
  attempts: [
    {
      state: "failed",
      startedAt: start,
      duration: 0,
      videoTimestamp: 0,
      screenshots: [],
      error: {
        name: "CypressExecutionError",
        message: error2,
        stack: ""
      }
    }
  ]
});
function getFailedDummyResult(configState, {
  specs,
  error: error2
}) {
  const start = (/* @__PURE__ */ new Date()).toISOString();
  const end = (/* @__PURE__ */ new Date()).toISOString();
  return {
    // @ts-ignore
    config: configState.getConfig() ?? {},
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    totalDuration: 0,
    totalSuites: 1,
    totalFailed: 1,
    totalPassed: 0,
    totalPending: 0,
    totalSkipped: 0,
    totalTests: 1,
    browserName: "unknown",
    browserVersion: "unknown",
    browserPath: "unknown",
    osName: "unknown",
    osVersion: "unknown",
    cypressVersion: "unknown",
    runs: specs.map((s) => ({
      stats: {
        suites: 1,
        tests: 1,
        passes: 0,
        pending: 0,
        skipped: 0,
        failures: 1,
        startedAt: start,
        endedAt: end,
        duration: 0
      },
      reporter: "spec",
      reporterStats: {},
      hooks: [],
      error: error2,
      video: null,
      spec: {
        name: s,
        relative: s,
        absolute: s,
        relativeToCommonRoot: s
      },
      tests: [getDummyFailedTest(start, error2)],
      shouldUploadVideo: false,
      skippedSpec: false
    }))
  };
}
function getCypressRunResultForSpec(spec, cypressResult) {
  if (!isSuccessResult(cypressResult)) {
    return;
  }
  const run3 = cypressResult.runs.find((r) => r.spec.relative === spec);
  if (!run3) {
    return;
  }
  const stats = getStats(run3.stats);
  return {
    ...cypressResult,
    runs: [run3],
    totalSuites: 1,
    totalDuration: stats.wallClockDuration,
    totalTests: stats.tests,
    totalFailed: stats.failures,
    totalPassed: stats.passes,
    totalPending: stats.pending,
    totalSkipped: stats.skipped,
    startedTestsAt: stats.wallClockStartedAt,
    endedTestsAt: stats.wallClockEndedAt
  };
}

// lib/results/table.ts
var import_lodash11 = __toESM(require("lodash"));
var import_pretty_ms2 = __toESM(require("pretty-ms"));
var import_table = require("table");
var failureIcon = red("\u2716");
var successIcon = green("\u2714");
var summaryTable = (r) => {
  const overallSpecCount = r.runs.length;
  const failedSpecsCount = import_lodash11.default.sum(
    r.runs.filter((v) => v.stats.failures + v.stats.skipped > 0).map(() => 1)
  );
  const hasFailed = failedSpecsCount > 0;
  const verdict = hasFailed ? red(`${failedSpecsCount} of ${overallSpecCount} failed`) : overallSpecCount > 0 ? "All specs passed!" : "No specs executed";
  const data = r.runs.map((r2) => [
    r2.stats.failures + r2.stats.skipped > 0 ? failureIcon : successIcon,
    r2.spec.relativeToCommonRoot,
    gray((0, import_pretty_ms2.default)(r2.stats.duration)),
    white(r2.stats.tests ?? 0),
    r2.stats.passes ? green(r2.stats.passes) : gray("-"),
    r2.stats.failures ? red(r2.stats.failures) : gray("-"),
    r2.stats.pending ? cyan(r2.stats.pending) : gray("-"),
    r2.stats.skipped ? red(r2.stats.skipped) : gray("-")
  ]);
  return (0, import_table.table)(
    [
      [
        "",
        // marker
        gray("Spec"),
        "",
        gray("Tests"),
        gray("Passing"),
        gray("Failing"),
        gray("Pending"),
        gray("Skipped")
      ],
      ...data,
      [
        hasFailed ? failureIcon : successIcon,
        // marker
        verdict,
        gray((0, import_pretty_ms2.default)(r.totalDuration ?? 0)),
        overallSpecCount > 0 ? white(r.totalTests ?? 0) : gray("-"),
        r.totalPassed ? green(r.totalPassed) : gray("-"),
        r.totalFailed ? red(r.totalFailed) : gray("-"),
        r.totalPending ? cyan(r.totalPending) : gray("-"),
        r.totalSkipped ? red(r.totalSkipped) : gray("-")
      ]
    ],
    {
      border,
      columnDefault: {
        width: 8
      },
      columns: [
        { alignment: "left", width: 2 },
        { alignment: "left", width: 30 },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" }
      ],
      // singleLine: true,
      drawHorizontalLine: (lineIndex, rowCount) => {
        return lineIndex === 1 || lineIndex === 0 || lineIndex === rowCount - 1 || lineIndex === rowCount;
      },
      drawVerticalLine: (lineIndex, rowCount) => {
        return lineIndex === 0 || rowCount === lineIndex;
      }
    }
  );
};
var border = import_lodash11.default.mapValues(
  {
    topBody: `\u2500`,
    topJoin: `\u252C`,
    topLeft: `  \u250C`,
    topRight: `\u2510`,
    bottomBody: `\u2500`,
    bottomJoin: `\u2534`,
    bottomLeft: `  \u2514`,
    bottomRight: `\u2518`,
    bodyLeft: `  \u2502`,
    bodyRight: `\u2502`,
    bodyJoin: `\u2502`,
    joinBody: `\u2500`,
    joinLeft: `  \u251C`,
    joinRight: `\u2524`,
    joinJoin: `\u253C`
  },
  (v) => gray(v)
);

// lib/results/uploadResults.ts
var import_debug17 = __toESM(require("debug"));

// lib/artifacts.ts
var import_debug16 = __toESM(require("debug"));

// lib/upload.ts
var import_debug15 = __toESM(require("debug"));
var import_fs3 = __toESM(require("fs"));
var readFile = import_fs3.default.promises.readFile;
var debug15 = (0, import_debug15.default)("currents:upload");
function uploadVideo(file2, url) {
  return uploadFile(file2, url, "video/mp4");
}
function uploadImage(file2, url) {
  return uploadFile(file2, url, "image/png");
}
function uploadJson(file2, url) {
  return uploadFile(file2, url, "application/json");
}
async function uploadFile(file2, url, type) {
  debug15('uploading file "%s" to "%s"', file2, url);
  const f = await readFile(file2);
  await makeRequest({
    url,
    method: "PUT",
    data: f,
    headers: {
      "Content-Type": type,
      "Content-Disposition": `inline`
    }
  });
}

// lib/artifacts.ts
var debug16 = (0, import_debug16.default)("currents:artifacts");
async function uploadArtifacts({
  executionState,
  videoPath,
  videoUploadUrl,
  screenshots,
  screenshotUploadUrls,
  coverageFilePath,
  coverageUploadUrl
}) {
  debug16("uploading artifacts: %o", {
    videoPath,
    videoUploadUrl,
    screenshots,
    screenshotUploadUrls,
    coverageFilePath,
    coverageUploadUrl
  });
  const totalUploads = (videoPath ? 1 : 0) + screenshots.length + (coverageUploadUrl ? 1 : 0);
  if (totalUploads === 0) {
    return;
  }
  if (videoUploadUrl && videoPath) {
    await safe(
      uploadVideo,
      (e) => {
        debug16("failed uploading video %s. Error: %o", videoPath, e);
        executionState.addWarning(
          `Failed uploading video ${videoPath}.
${dim(e)}`
        );
      },
      () => debug16("success uploading", videoPath)
    )(videoPath, videoUploadUrl);
  }
  if (screenshotUploadUrls && screenshotUploadUrls.length) {
    await Promise.all(
      screenshots.map((screenshot) => {
        const url = screenshotUploadUrls.find(
          (urls) => urls.screenshotId === screenshot.screenshotId
        )?.uploadUrl;
        if (!url) {
          debug16(
            "No upload url for screenshot %o, screenshotUploadUrls: %o",
            screenshot,
            screenshotUploadUrls
          );
          executionState.addWarning(
            `No upload URL for screenshot ${screenshot.path}`
          );
          return Promise.resolve();
        }
        return safe(
          uploadImage,
          (e) => {
            debug16(
              "failed uploading screenshot %s. Error: %o",
              screenshot.path,
              e
            );
            executionState.addWarning(
              `Failed uploading screenshot ${screenshot.path}.
${dim(e)}`
            );
          },
          () => debug16("success uploading", screenshot.path)
        )(screenshot.path, url);
      })
    );
  }
  if (coverageUploadUrl && coverageFilePath) {
    await safe(
      uploadJson,
      (e) => {
        debug16(
          "failed uploading coverage file %s. Error: %o",
          coverageFilePath,
          e
        );
        executionState.addWarning(
          `Failed uploading coverage file ${coverageFilePath}.
${dim(e)}`
        );
      },
      () => debug16("success uploading", coverageFilePath)
    )(coverageFilePath, coverageUploadUrl);
  }
}
var uploadStdoutSafe = safe(
  updateInstanceStdout,
  () => {
  },
  () => {
  }
);

// lib/cancellation/cancellation.ts
var state = {
  cancellationReason: null
};
var setCancellationReason = (reason) => {
  if (state.cancellationReason) {
    return;
  }
  state.cancellationReason = reason;
  pubsub.emit("runCancelled" /* RUN_CANCELLED */, reason);
};

// lib/results/uploadResults.ts
var debug17 = (0, import_debug17.default)("currents:results");
async function getReportResultsTask(instanceId, configState, executionState, stdout2, coverageFilePath) {
  const results = executionState.getInstanceResults(configState, instanceId);
  const run3 = results.runs[0];
  if (!run3) {
    throw new Error("No run found in Cypress results");
  }
  const instanceResults = getInstanceResultPayload(run3, coverageFilePath);
  const instanceTests = getInstanceTestsPayload(run3, results.config);
  const { videoUploadUrl, screenshotUploadUrls, coverageUploadUrl, cloud } = await reportResults(instanceId, instanceTests, instanceResults);
  if (cloud?.shouldCancel) {
    debug17("instance %s should cancel", instanceId);
    setCancellationReason(cloud.shouldCancel);
  }
  debug17("instance %s artifact upload instructions %o", instanceId, {
    videoUploadUrl,
    screenshotUploadUrls,
    coverageUploadUrl
  });
  return Promise.all([
    uploadArtifacts({
      executionState,
      videoUploadUrl,
      videoPath: run3.video,
      screenshotUploadUrls,
      screenshots: instanceResults.screenshots,
      coverageUploadUrl,
      coverageFilePath
    }),
    uploadStdoutSafe(instanceId, getInitialOutput() + stdout2)
  ]);
}
async function reportResults(instanceId, instanceTests, instanceResults) {
  debug17("reporting instance %s results...", instanceId);
  if (isCurrents()) {
    return reportInstanceResultsMerged(instanceId, {
      tests: instanceTests,
      results: instanceResults
    });
  }
  await setInstanceTests(instanceId, instanceTests);
  return updateInstanceResults(instanceId, instanceResults);
}

// lib/runner/runner.ts
var import_debug19 = __toESM(require("debug"));

// lib/runner/reportTask.ts
var import_debug18 = __toESM(require("debug"));
var debug18 = (0, import_debug18.default)("currents:reportTask");
var reportTasks = [];
var createReportTask = (configState, executionState, instanceId) => {
  const instance = executionState.getInstance(instanceId);
  if (!instance) {
    error("Cannot find execution state for instance %s", instanceId);
    return;
  }
  if (instance.reportStartedAt) {
    debug18("Report task already created for instance %s", instanceId);
    return;
  }
  instance.reportStartedAt = /* @__PURE__ */ new Date();
  debug18("Creating report task for instanceId %s", instanceId);
  reportTasks.push(
    getReportResultsTask(
      instanceId,
      configState,
      executionState,
      instance.output ?? "no output captured",
      instance.coverageFilePath
    ).catch(error)
  );
};
var createReportTaskSpec = (configState, executionState, spec) => {
  const i = executionState.getSpec(spec);
  if (!i) {
    error("Cannot find execution state for spec %s", spec);
    return;
  }
  debug18("Creating report task for spec %s", spec);
  return createReportTask(configState, executionState, i.instanceId);
};

// lib/runner/runner.ts
var debug19 = (0, import_debug19.default)("currents:runner");
async function runTillDone(executionState, configState, {
  runId,
  groupId,
  machineId,
  platform: platform2,
  specs: allSpecs
}, params) {
  let hasMore = true;
  while (hasMore) {
    const newTasks = await runBatch(executionState, configState, {
      runMeta: {
        runId,
        groupId,
        machineId,
        platform: platform2
      },
      allSpecs,
      params
    });
    if (!newTasks.length) {
      debug19("No more tasks to run. Uploads queue: %d", reportTasks.length);
      hasMore = false;
      break;
    }
    newTasks.forEach(
      (t) => createReportTask(configState, executionState, t.instanceId)
    );
  }
}
async function runBatch(executionState, configState, {
  runMeta,
  params,
  allSpecs
}) {
  let batch = {
    specs: [],
    claimedInstances: 0,
    totalInstances: 0
  };
  if (isCurrents()) {
    debug19("Getting batched tasks: %d", params.batchSize);
    batch = await createBatchedInstances({
      ...runMeta,
      batchSize: params.batchSize
    });
    debug19("Got batched tasks: %o", batch);
  } else {
    const response = await createInstance(runMeta);
    if (response.spec !== null && response.instanceId !== null) {
      batch.specs.push({
        spec: response.spec,
        instanceId: response.instanceId
      });
    }
    batch.claimedInstances = response.claimedInstances;
    batch.totalInstances = response.totalInstances;
  }
  if (batch.specs.length === 0) {
    return [];
  }
  batch.specs.forEach((i) => executionState.initInstance(i));
  divider();
  info(
    "Running: %s (%d/%d)",
    batch.specs.map((s) => s.spec).join(", "),
    batch.claimedInstances,
    batch.totalInstances
  );
  const rawResult = await runSpecFileSafe(
    {
      // use absolute paths - user can run the program from a different directory, e.g. nx or a monorepo workspace
      // cypress still report the path relative to the project root
      spec: batch.specs.map((bs) => getSpecAbsolutePath(allSpecs, bs.spec)).join(",")
    },
    params
  );
  title("blue", "Reporting results and artifacts in background...");
  const output = getCapturedOutput();
  batch.specs.forEach((spec) => {
    executionState.setInstanceOutput(spec.instanceId, output);
    const specRunResult = getCypressRunResultForSpec(spec.spec, rawResult);
    if (!specRunResult) {
      return;
    }
    executionState.setInstanceResult(
      configState,
      spec.instanceId,
      specRunResult
    );
  });
  resetCapture();
  return batch.specs;
}
function getSpecAbsolutePath(allSpecs, relative) {
  const absolutePath = allSpecs.find((i) => i.relative === relative)?.absolute;
  if (!absolutePath) {
    warn(
      'Cannot find absolute path for spec. Spec: "%s", candidates: %o',
      relative,
      allSpecs
    );
    throw new Error(`Cannot find absolute path for spec`);
  }
  return absolutePath;
}

// lib/runner/cancellable.ts
var cancellable = null;
function onRunCancelled(reason) {
  warn(
    `Run cancelled: %s. Waiting for uploads to complete and stopping execution...`,
    reason
  );
  cancellable?.cancel();
}
async function runTillDoneOrCancelled(...args) {
  return new Promise((_resolve, _reject) => {
    cancellable = new BPromise((resolve, reject, onCancel) => {
      if (!onCancel) {
        _reject(new Error("BlueBird is misconfigured: onCancel is undefined"));
        return;
      }
      onCancel(() => _resolve(void 0));
      runTillDone(...args).then(
        () => {
          resolve();
          _resolve(void 0);
        },
        (error2) => {
          reject();
          _reject(error2);
        }
      );
    });
    pubsub.addListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  }).finally(() => {
    pubsub.removeListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  });
}

// lib/shutdown.ts
async function shutdown() {
  await stopWSS();
}

// lib/specMatcher/specMatcher.ts
var import_debug20 = __toESM(require("debug"));
var import_path5 = __toESM(require("path"));
var import_common_path_prefix = __toESM(require("common-path-prefix"));
var import_globby = __toESM(require("globby"));
var import_lodash12 = __toESM(require("lodash"));
var import_os2 = __toESM(require("os"));

// lib/utils.ts
var import_path4 = __toESM(require("path"));
function toArray(val) {
  return val ? typeof val === "string" ? [val] : val : [];
}
function toPosix(file2, sep = import_path4.default.sep) {
  return file2.split(sep).join(import_path4.default.posix.sep);
}

// lib/specMatcher/specMatcher.ts
var debug20 = (0, import_debug20.default)("currents:specs");
async function findSpecs({
  projectRoot,
  testingType,
  specPattern,
  configSpecPattern,
  excludeSpecPattern,
  additionalIgnorePattern
}) {
  configSpecPattern = toArray(configSpecPattern);
  specPattern = toArray(specPattern);
  excludeSpecPattern = toArray(excludeSpecPattern) || [];
  additionalIgnorePattern = toArray(additionalIgnorePattern) || [];
  debug20("exploring spec files for execution %O", {
    testingType,
    projectRoot,
    specPattern,
    configSpecPattern,
    excludeSpecPattern,
    additionalIgnorePattern
  });
  if (!specPattern || !configSpecPattern) {
    throw Error("Could not find glob patterns for exploring specs");
  }
  let specAbsolutePaths = await getFilesByGlob(projectRoot, specPattern, {
    absolute: true,
    ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
  });
  if (!import_lodash12.default.isEqual(specPattern, configSpecPattern)) {
    const defaultSpecAbsolutePaths = await getFilesByGlob(
      projectRoot,
      configSpecPattern,
      {
        absolute: true,
        ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
      }
    );
    specAbsolutePaths = import_lodash12.default.intersection(
      specAbsolutePaths,
      defaultSpecAbsolutePaths
    );
  }
  return matchedSpecs({
    projectRoot,
    testingType,
    specAbsolutePaths,
    specPattern
  });
}
async function getFilesByGlob(projectRoot, glob, globOptions) {
  const workingDirectoryPrefix = import_path5.default.join(projectRoot, import_path5.default.sep);
  const globs = [].concat(glob).map(
    (globPattern) => globPattern.startsWith("./") ? globPattern.replace("./", "") : globPattern
  ).map((globPattern) => {
    if (globPattern.startsWith(workingDirectoryPrefix)) {
      return globPattern.replace(workingDirectoryPrefix, "");
    }
    return globPattern;
  });
  if (import_os2.default.platform() === "win32") {
    debug20("updating glob patterns to POSIX");
    for (const i in globs) {
      const cur = globs[i];
      if (!cur)
        throw new Error("undefined glob received");
      globs[i] = toPosix(cur);
    }
  }
  try {
    debug20("globbing pattern(s): %o", globs);
    debug20("within directory: %s", projectRoot);
    return matchGlobs(globs, {
      onlyFiles: true,
      absolute: true,
      cwd: projectRoot,
      ...globOptions,
      ignore: (globOptions?.ignore ?? []).concat("**/node_modules/**")
    });
  } catch (e) {
    debug20("error in getFilesByGlob %o", e);
    return [];
  }
}
var matchGlobs = async (globs, globbyOptions) => {
  return await (0, import_globby.default)(globs, globbyOptions);
};
function matchedSpecs({
  projectRoot,
  testingType,
  specAbsolutePaths
}) {
  debug20("found specs %o", specAbsolutePaths);
  let commonRoot = "";
  if (specAbsolutePaths.length === 1) {
    commonRoot = import_path5.default.dirname(specAbsolutePaths[0]);
  } else {
    commonRoot = (0, import_common_path_prefix.default)(specAbsolutePaths);
  }
  return specAbsolutePaths.map(
    (absolute) => transformSpec({
      projectRoot,
      absolute,
      testingType,
      commonRoot,
      platform: import_os2.default.platform(),
      sep: import_path5.default.sep
    })
  );
}
function transformSpec({
  projectRoot,
  absolute,
  testingType,
  commonRoot,
  platform: platform2,
  sep
}) {
  if (platform2 === "win32") {
    absolute = toPosix(absolute, sep);
    projectRoot = toPosix(projectRoot, sep);
  }
  const relative = import_path5.default.relative(projectRoot, absolute);
  const parsedFile = import_path5.default.parse(absolute);
  const fileExtension = import_path5.default.extname(absolute);
  const specFileExtension = [".spec", ".test", "-spec", "-test", ".cy"].map((ext) => ext + fileExtension).find((ext) => absolute.endsWith(ext)) || fileExtension;
  const parts = absolute.split(projectRoot);
  let name = parts[parts.length - 1] || "";
  if (name.startsWith("/")) {
    name = name.slice(1);
  }
  const LEADING_SLASH = /^\/|/g;
  const relativeToCommonRoot = absolute.replace(commonRoot, "").replace(LEADING_SLASH, "");
  return {
    fileExtension,
    baseName: parsedFile.base,
    fileName: parsedFile.base.replace(specFileExtension, ""),
    specFileExtension,
    relativeToCommonRoot,
    specType: testingType === "component" ? "component" : "integration",
    name,
    relative,
    absolute
  };
}

// lib/specMatcher/getSpecFiles.ts
var getSpecFiles = async ({
  config,
  params
}) => {
  const specPattern = getSpecPattern(config.specPattern, params.spec);
  const specs = await findSpecs({
    // https://docs.cypress.io/guides/guides/command-line#cypress-run-spec-lt-spec-gt
    projectRoot: params.project ?? config.projectRoot,
    testingType: params.testingType,
    specPattern,
    configSpecPattern: config.specPattern,
    excludeSpecPattern: config.excludeSpecPattern,
    additionalIgnorePattern: config.additionalIgnorePattern
  });
  if (specs.length === 0) {
    warn(
      "Found no spec files. Was looking for spec files that match both configSpecPattern and specPattern relative to projectRoot. Configuration: %O",
      {
        projectRoot: config.projectRoot,
        specPattern,
        configSpecPattern: config.specPattern,
        excludeSpecPattern: [
          config.excludeSpecPattern,
          config.additionalIgnorePattern
        ].flat(2),
        testingType: params.testingType
      }
    );
  }
  return { specs, specPattern };
};
function getSpecPattern(configPattern, explicit) {
  return explicit || configPattern;
}

// lib/state/config.ts
var ConfigState = class {
  constructor() {
    this._config = void 0;
  }
  setConfig(c) {
    this._config = c;
  }
  getConfig() {
    return this._config;
  }
};

// lib/results/mapResult.ts
function getScreenshot(s) {
  return {
    ...s,
    name: s.name ?? "screenshot"
  };
}
function getTestAttempt2(attempt, screenshots) {
  return {
    ...attempt,
    startedAt: attempt.wallClockStartedAt,
    duration: attempt.wallClockDuration,
    screenshots: screenshots.map(getScreenshot)
  };
}
function getTest(t, screenshots) {
  const _screenshots = screenshots.filter((s) => s.testId === t.testId);
  return {
    ...t,
    attempts: t.attempts.map(
      (a, i) => getTestAttempt2(
        a,
        _screenshots.filter((s) => s.testAttemptIndex === i)
      )
    )
  };
}
function specResultsToCypressResults(configState, specAfterResult) {
  return {
    status: "finished",
    // @ts-ignore
    config: configState.getConfig(),
    totalDuration: specAfterResult.stats.wallClockDuration,
    totalSuites: specAfterResult.stats.suites,
    totalTests: specAfterResult.stats.tests,
    totalFailed: specAfterResult.stats.failures,
    totalPassed: specAfterResult.stats.passes,
    totalPending: specAfterResult.stats.pending,
    totalSkipped: specAfterResult.stats.skipped,
    startedTestsAt: specAfterResult.stats.wallClockStartedAt,
    endedTestsAt: specAfterResult.stats.wallClockEndedAt,
    runs: [
      {
        stats: {
          ...specAfterResult.stats,
          startedAt: specAfterResult.stats.wallClockStartedAt,
          endedAt: specAfterResult.stats.wallClockEndedAt,
          duration: specAfterResult.stats.wallClockDuration
        },
        reporter: specAfterResult.reporter,
        reporterStats: specAfterResult.reporterStats ?? {},
        spec: specAfterResult.spec,
        error: specAfterResult.error,
        video: specAfterResult.video,
        shouldUploadVideo: true,
        // not really used
        // @ts-ignore
        // wrong typedef for CypressCommandLine.CypressRunResult
        // actual HookName is "before all" | "before each" | "after all" | "after each"
        hooks: specAfterResult.hooks,
        tests: (specAfterResult.tests ?? []).map(
          (t) => getTest(t, specAfterResult.screenshots)
        )
      }
    ]
  };
}
var backfillException = (result) => {
  return {
    ...result,
    runs: result.runs.map(backfillExceptionRun)
  };
};
var backfillExceptionRun = (run3) => {
  if (!run3.error) {
    return run3;
  }
  return {
    ...run3,
    tests: [getFakeTestFromException(run3.error, run3.stats)]
  };
};

// lib/state/execution.ts
var import_debug21 = __toESM(require("debug"));
var debug21 = (0, import_debug21.default)("currents:state");
var ExecutionState = class {
  constructor() {
    this.warnings = /* @__PURE__ */ new Set();
    this.state = {};
  }
  getWarnings() {
    return this.warnings;
  }
  addWarning(warning) {
    this.warnings.add(warning);
  }
  getResults(configState) {
    return Object.values(this.state).map(
      (i) => this.getInstanceResults(configState, i.instanceId)
    );
  }
  getInstance(instanceId) {
    return this.state[instanceId];
  }
  getSpec(spec) {
    return Object.values(this.state).find((i) => i.spec === spec);
  }
  initInstance({
    instanceId,
    spec
  }) {
    debug21('Init execution state for "%s"', spec);
    this.state[instanceId] = {
      instanceId,
      spec,
      createdAt: /* @__PURE__ */ new Date()
    };
  }
  setSpecBefore(spec) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specBefore = /* @__PURE__ */ new Date();
  }
  setSpecCoverage(spec, coverageFilePath) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    debug21("Experimental: coverageFilePath was set");
    i.coverageFilePath = coverageFilePath;
  }
  setSpecAfter(spec, results) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specAfter = /* @__PURE__ */ new Date();
    i.specAfterResults = results;
  }
  setSpecOutput(spec, output) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    this.setInstanceOutput(i.instanceId, output);
  }
  setInstanceOutput(instanceId, output) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    if (i.output) {
      debug21('Instance "%s" already has output', instanceId);
      return;
    }
    i.output = output;
  }
  setInstanceResult(configState, instanceId, results) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    i.runResults = results;
    i.runResultsReportedAt = /* @__PURE__ */ new Date();
  }
  getInstanceResults(configState, instanceId) {
    const i = this.getInstance(instanceId);
    if (!i) {
      error('Cannot find execution state for instance "%s"', instanceId);
      return getFailedDummyResult(configState, {
        specs: ["unknown"],
        error: "Cannot find execution state for instance"
      });
    }
    if (i.specAfterResults) {
      return backfillException(
        specResultsToCypressResults(configState, i.specAfterResults)
      );
    }
    if (i.runResults) {
      return backfillException(i.runResults);
    }
    debug21('No results detected for "%s"', i.spec);
    return getFailedDummyResult(configState, {
      specs: [i.spec],
      error: `No results detected for the spec file. That usually happens because of cypress crash. See the console output for details.`
    });
  }
};

// lib/run.ts
var debug22 = (0, import_debug22.default)("currents:run");
async function run(params = {}) {
  const executionState = new ExecutionState();
  const configState = new ConfigState();
  activateDebug(params.cloudDebug);
  debug22("run params %o", params);
  params = preprocessParams(params);
  debug22("params after preprocess %o", params);
  if (isOffline(params)) {
    info(`Skipping cloud orchestration because --record is set to false`);
    return runBareCypress(params);
  }
  const validatedParams = await validateParams(params);
  setAPIBaseUrl(validatedParams.cloudServiceUrl);
  if (!isCurrents()) {
    console.log(getLegalNotice());
  }
  const {
    recordKey,
    projectId,
    group,
    parallel,
    ciBuildId,
    tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    experimentalCoverageRecording
  } = validatedParams;
  const config = await getMergedConfig(validatedParams);
  configState.setConfig(config?.resolved);
  const { specs, specPattern } = await getSpecFiles({
    config,
    params: validatedParams
  });
  if (specs.length === 0) {
    return;
  }
  const platform2 = await getPlatform({
    config,
    browser: validatedParams.browser
  });
  info("Discovered %d spec files", specs.length);
  info(
    `Tags: ${tag.length > 0 ? tag.join(",") : false}; Group: ${group ?? false}; Parallel: ${parallel ?? false}; Batch Size: ${batchSize}`
  );
  info("Connecting to cloud orchestration service...");
  const run3 = await createRun({
    ci: getCI(ciBuildId),
    specs: specs.map((spec) => spec.relative),
    commit: await getGitInfo(config.projectRoot),
    group,
    platform: platform2,
    parallel: parallel ?? false,
    ciBuildId,
    projectId,
    recordKey,
    specPattern: [specPattern].flat(2),
    tags: tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    coverageEnabled: experimentalCoverageRecording
  });
  setRunId(run3.runId);
  info("\u{1F3A5} Run URL:", bold(run3.runUrl));
  cutInitialOutput();
  await startWSS();
  listenToSpecEvents(
    configState,
    executionState,
    config.experimentalCoverageRecording
  );
  await runTillDoneOrCancelled(
    executionState,
    configState,
    {
      runId: run3.runId,
      groupId: run3.groupId,
      machineId: run3.machineId,
      platform: platform2,
      specs
    },
    validatedParams
  );
  divider();
  await Promise.allSettled(reportTasks);
  const _summary = summarizeTestResults(
    executionState.getResults(configState),
    config
  );
  title("white", "Cloud Run Finished");
  console.log(summaryTable(_summary));
  printWarnings2(executionState);
  info("\n\u{1F3C1} Recorded Run:", bold(run3.runUrl));
  await shutdown();
  spacer();
  if (_summary.status === "finished") {
    return {
      ..._summary,
      runUrl: run3.runUrl
    };
  }
  return _summary;
}
function listenToSpecEvents(configState, executionState, experimentalCoverageRecording) {
  const config = configState.getConfig();
  pubsub.on("before:spec", async ({ spec }) => {
    debug22("before:spec %o", spec);
    executionState.setSpecBefore(spec.relative);
  });
  pubsub.on(
    "after:spec",
    async ({ spec, results }) => {
      debug22("after:spec %o %o", spec, results);
      executionState.setSpecAfter(spec.relative, results);
      executionState.setSpecOutput(spec.relative, getCapturedOutput());
      if (experimentalCoverageRecording) {
        const { path: path4, error: error2 } = await getCoverageFilePath(
          config?.env?.coverageFile
        );
        if (!error2) {
          executionState.setSpecCoverage(spec.relative, path4);
        } else {
          executionState.addWarning(
            `Could not process coverage file "${path4}"
${dim(error2)}`
          );
        }
      }
      createReportTaskSpec(configState, executionState, spec.relative);
    }
  );
}
function printWarnings2(executionState) {
  const warnings = Array.from(executionState.getWarnings());
  if (warnings.length > 0) {
    warn(
      `${warnings.length} ${(0, import_plur.default)(
        "Warning",
        warnings.length
      )} encountered during the execution:
${warnings.map((w, i) => `
${yellow(`[${i + 1}/${warnings.length}]`)} ${w}`).join("\n")}`
    );
  }
}

// index.ts
function run2(params) {
  return run(params);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  run
});
/*! @preserve

### MIT

Parts of this code was copied from https://github.com/cypress-io/cypress and is subject to MIT license.

MIT License

Copyright (c) 2022 Cypress.io

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaW5kZXgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzdXAvYXNzZXRzL2Nqc19zaGltcy5qcyIsICIuLi9saWIvcmVxdWlyZS50cyIsICIuLi9saWIvc3Rkb3V0LnRzIiwgIi4uL2xpYi93cy93cy50cyIsICIuLi9saWIvcHVic3ViLnRzIiwgIi4uL2xpYi9jYXB0dXJlLnRzIiwgIi4uL2xpYi9odHRwQ2xpZW50L2NvbmZpZy50cyIsICIuLi9saWIvaHR0cENsaWVudC9odHRwQ2xpZW50LnRzIiwgIi4uL2xpYi9jb25maWcvY29uZmlnLnRzIiwgIi4uL2xpYi9ib290c3RyYXAvYm9vdHN0cmFwLnRzIiwgIi4uL2xpYi9lcnJvcnMudHMiLCAiLi4vbGliL2ZzLnRzIiwgIi4uL2xpYi9sb2cudHMiLCAiLi4vbGliL2Jvb3RzdHJhcC9zZXJpYWxpemVyLnRzIiwgIi4uL2xpYi9jb25maWcvcGF0aC50cyIsICIuLi9saWIvY29uZmlnL3BhcmFtcy50cyIsICIuLi9saWIvaHR0cENsaWVudC9wcmludEVycm9ycy50cyIsICIuLi9saWIvaW5pdC50cyIsICIuLi9saWIvcnVuLnRzIiwgIi4uL2xlZ2FsLnRzIiwgIi4uL2xpYi9hcGkvd2FybmluZ3MudHMiLCAiLi4vbGliL2FwaS9hcGkudHMiLCAiLi4vbGliL2NpUHJvdmlkZXIvY2lQcm92aWRlci50cyIsICIuLi9saWIvY2lQcm92aWRlci9tZXJnZS50cyIsICIuLi9saWIvY292ZXJhZ2UvaW5kZXgudHMiLCAiLi4vbGliL2N5cHJlc3MvY3lwcmVzcy50cyIsICIuLi9saWIvbGFuZy50cyIsICIuLi9saWIvZGVidWcvaW5kZXgudHMiLCAiLi4vbGliL2Vudi50cyIsICIuLi9saWIvZ2l0LnRzIiwgIi4uL2xpYi9wbGF0Zm9ybS9icm93c2VyLnRzIiwgIi4uL2xpYi9wbGF0Zm9ybS9wbGF0Zm9ybS50cyIsICIuLi9saWIvcGxhdGZvcm0vaW5kZXgudHMiLCAiLi4vbGliL3Jlc3VsdHMvcmVzdWx0cy50cyIsICIuLi9saWIvcmVzdWx0cy90YWJsZS50cyIsICIuLi9saWIvcmVzdWx0cy91cGxvYWRSZXN1bHRzLnRzIiwgIi4uL2xpYi9hcnRpZmFjdHMudHMiLCAiLi4vbGliL3VwbG9hZC50cyIsICIuLi9saWIvY2FuY2VsbGF0aW9uL2NhbmNlbGxhdGlvbi50cyIsICIuLi9saWIvcnVubmVyL3J1bm5lci50cyIsICIuLi9saWIvcnVubmVyL3JlcG9ydFRhc2sudHMiLCAiLi4vbGliL3J1bm5lci9jYW5jZWxsYWJsZS50cyIsICIuLi9saWIvc2h1dGRvd24udHMiLCAiLi4vbGliL3NwZWNNYXRjaGVyL3NwZWNNYXRjaGVyLnRzIiwgIi4uL2xpYi91dGlscy50cyIsICIuLi9saWIvc3BlY01hdGNoZXIvZ2V0U3BlY0ZpbGVzLnRzIiwgIi4uL2xpYi9zdGF0ZS9jb25maWcudHMiLCAiLi4vbGliL3Jlc3VsdHMvbWFwUmVzdWx0LnRzIiwgIi4uL2xpYi9zdGF0ZS9leGVjdXRpb24udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiY3lwcmVzc1wiIC8+XG5pbXBvcnQgXCJzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXIuanNcIjtcblxuaW1wb3J0IHsgcnVuIGFzIGludGVybmFsUnVuIH0gZnJvbSBcIi4vbGliL3J1blwiO1xuaW1wb3J0IHsgQ3VycmVudHNSdW5BUEkgfSBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0IHR5cGUgeyBDdXJyZW50c1J1bkFQSSB9IGZyb20gXCIuL3R5cGVzXCI7XG4vKipcbiAqIFJ1biBDeXByZXNzIHRlc3RzIHdpdGggYSBjbG91ZCBzZXJ2aWNlIG9mIHlvdXIgY2hvaWNlIGFuZCByZXR1cm4gdGhlIHJlc3VsdHNcbiAqXG4gKiBAYXVnbWVudHMgQ3VycmVudHNSdW5BUElcbiAqIEByZXR1cm5zIHtDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB8IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzRmFpbGVkUnVuUmVzdWx0IHwgdW5kZWZpbmVkfSBUaGUgdGVzdCByZXN1bHRzLCBvciB1bmRlZmluZWQgaWYgbm8gdGVzdHMgd2VyZSBydW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bihwYXJhbXM/OiBDdXJyZW50c1J1bkFQSSkge1xuICByZXR1cm4gaW50ZXJuYWxSdW4ocGFyYW1zKTtcbn1cbiIsICIvLyBTaGltIGdsb2JhbHMgaW4gY2pzIGJ1bmRsZVxuLy8gVGhlcmUncyBhIHdlaXJkIGJ1ZyB0aGF0IGVzYnVpbGQgd2lsbCBhbHdheXMgaW5qZWN0IGltcG9ydE1ldGFVcmxcbi8vIGlmIHdlIGV4cG9ydCBpdCBhcyBgY29uc3QgaW1wb3J0TWV0YVVybCA9IC4uLiBfX2ZpbGVuYW1lIC4uLmBcbi8vIEJ1dCB1c2luZyBhIGZ1bmN0aW9uIHdpbGwgbm90IGNhdXNlIHRoaXMgaXNzdWVcblxuY29uc3QgZ2V0SW1wb3J0TWV0YVVybCA9ICgpID0+XG4gIHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IG5ldyBVUkwoJ2ZpbGU6JyArIF9fZmlsZW5hbWUpLmhyZWZcbiAgICA6IChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSB8fFxuICAgICAgbmV3IFVSTCgnbWFpbi5qcycsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWZcblxuZXhwb3J0IGNvbnN0IGltcG9ydE1ldGFVcmwgPSAvKiBAX19QVVJFX18gKi8gZ2V0SW1wb3J0TWV0YVVybCgpXG4iLCAiaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJtb2R1bGVcIjtcbi8vIHJlcXVpcmVzIHNoaW09dHJ1ZSBpbiBwYWNrYWdlLmpzb25cbmV4cG9ydCBjb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuIiwgImltcG9ydCBjcCBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuY29uc3Qgb3JnaW5hbCA9IGNwLnNwYXduO1xuXG4vLyBAdHMtaWdub3JlXG5jcC5zcGF3biA9IGZ1bmN0aW9uIChjb21tYW5kLCBhcmdzLCBvcHRpb25zKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGNvbW1hbmQubWF0Y2goL0N5cHJlc3MvKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBwcm9jZXNzID0gb3JnaW5hbChjb21tYW5kLCBhcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLy8gdXNpbmcgcGlwZSBlbmFibGVzIGNhcHR1cmluZyBzdGRvdXQgYW5kIHN0ZGVyclxuICAgICAgc3RkaW86IFtcInBpcGVcIiwgXCJwaXBlXCIsIFwicGlwZVwiXSxcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvY2VzcztcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIG9yZ2luYWwoY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG59O1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBodHRwIGZyb20gXCJodHRwXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgSHR0cFRlcm1pbmF0b3IgZnJvbSBcImxpbC1odHRwLXRlcm1pbmF0b3JcIjtcbmltcG9ydCB7IG1hdGNoLCBQIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCAqIGFzIFdlYlNvY2tldCBmcm9tIFwid3NcIjtcbmltcG9ydCB7IHB1YnN1YiB9IGZyb20gXCIuLi9wdWJzdWJcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOndzXCIpO1xuXG5sZXQgc2VydmVyOiBodHRwLlNlcnZlciB8IG51bGwgPSBudWxsO1xubGV0IHdzczogV2ViU29ja2V0LlNlcnZlciB8IG51bGwgPSBudWxsO1xubGV0IGh0dHBUZXJtaW5hdG9yOiBIdHRwVGVybWluYXRvciB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgY29uc3QgZ2V0V1NTUG9ydCA9ICgpID0+XG4gIG1hdGNoKHNlcnZlcj8uYWRkcmVzcygpKVxuICAgIC53aXRoKHsgcG9ydDogUC5udW1iZXIgfSwgKGFkZHJlc3MpID0+IGFkZHJlc3MucG9ydClcbiAgICAub3RoZXJ3aXNlKCgpID0+IDApO1xuXG5leHBvcnQgY29uc3Qgc3RvcFdTUyA9IGFzeW5jICgpID0+IHtcbiAgZGVidWcoXCJ0ZXJtaW5hdGluZyB3c3Mgc2VydmVyOiAlZFwiLCBnZXRXU1NQb3J0KCkpO1xuICBpZiAoIWh0dHBUZXJtaW5hdG9yKSB7XG4gICAgZGVidWcoXCJubyB3c3Mgc2VydmVyXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHN1Y2Nlc3MsIGNvZGUsIG1lc3NhZ2UsIGVycm9yIH0gPSBhd2FpdCBodHRwVGVybWluYXRvci50ZXJtaW5hdGUoKTtcbiAgaWYgKCFzdWNjZXNzKSB7XG4gICAgaWYgKGNvZGUgPT09IFwiVElNRURfT1VUXCIpIGVycm9yKG1lc3NhZ2UpO1xuICAgIGlmIChjb2RlID09PSBcIlNFUlZFUl9FUlJPUlwiKSBlcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgaWYgKGNvZGUgPT09IFwiSU5URVJOQUxfRVJST1JcIikgZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG4gIGRlYnVnKFwidGVybWluYXRlZCB3c3Mgc2VydmVyOiAlZFwiLCBnZXRXU1NQb3J0KCkpO1xufTtcbmV4cG9ydCBjb25zdCBzdGFydFdTUyA9ICgpID0+IHtcbiAgaWYgKHdzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXJ2ZXIgPSBodHRwXG4gICAgLmNyZWF0ZVNlcnZlcigpXG4gICAgLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHtcbiAgICAgIGlmICghc2VydmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZlciBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICB9XG4gICAgICB3c3MgPSBuZXcgV2ViU29ja2V0LldlYlNvY2tldFNlcnZlcih7XG4gICAgICAgIHNlcnZlcixcbiAgICAgIH0pO1xuICAgICAgZGVidWcoXCJzdGFydGluZyB3c3Mgb24gcG9ydCAlZFwiLCBnZXRXU1NQb3J0KCkpO1xuICAgICAgd3NzLm9uKFwiY29ubmVjdGlvblwiLCBmdW5jdGlvbiBjb25uZWN0aW9uKHdzKSB7XG4gICAgICAgIHdzLm9uKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBpbmNvbWluZyhldmVudCkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHB1YnN1Yi5lbWl0KG1lc3NhZ2UudHlwZSwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC5saXN0ZW4oKTtcblxuICBodHRwVGVybWluYXRvciA9IEh0dHBUZXJtaW5hdG9yKHtcbiAgICBzZXJ2ZXIsXG4gIH0pO1xufTtcbiIsICJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIjtcbmV4cG9ydCBlbnVtIEV2ZW50IHtcbiAgUlVOX0NBTkNFTExFRCA9IFwicnVuQ2FuY2VsbGVkXCIsXG59XG5leHBvcnQgY29uc3QgcHVic3ViID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjYXB0dXJlXCIpO1xuXG5jb25zdCBfd3JpdGUgPSBwcm9jZXNzLnN0ZG91dC53cml0ZTtcbmNvbnN0IF9sb2cgPSBwcm9jZXNzLmxvZztcblxuZXhwb3J0IGNvbnN0IHJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsc1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSA9IF93cml0ZTtcbiAgcHJvY2Vzcy5sb2cgPSBfbG9nO1xufTtcblxuY29uc3QgbG9nczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG5cbmNvbnN0IHN0ZG91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoXCJjYXB0dXJpbmcgc3Rkb3V0XCIpO1xuICBsZXQgbG9nczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBsYXppbHkgYmFja3VwIHdyaXRlIHRvIGVuYWJsZSBpbmplY3Rpb25cbiAgY29uc3QgeyB3cml0ZSB9ID0gcHJvY2Vzcy5zdGRvdXQ7XG4gIGNvbnN0IHsgbG9nIH0gPSBwcm9jZXNzO1xuXG4gIC8vIGVsZWN0cm9uIGFkZHMgYSBuZXcgcHJvY2Vzcy5sb2dcbiAgLy8gbWV0aG9kIGZvciB3aW5kb3dzIGluc3RlYWQgb2YgcHJvY2Vzcy5zdGRvdXQud3JpdGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9pc3N1ZXMvOTc3XG4gIGlmIChsb2cpIHtcbiAgICBwcm9jZXNzLmxvZyA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZykge1xuICAgICAgbG9ncy5wdXNoKHN0cik7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIHJldHVybiBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpIHtcbiAgICBsb2dzLnB1c2goc3RyKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgcmV0dXJuIHdyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBsb2dzLmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICBkYXRhOiBsb2dzLFxuICAgIHJlc3RvcmUsXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIGRlYnVnKFwicmVzZXR0aW5nIGNhcHR1cmVkIHN0ZG91dFwiKTtcbiAgICAgIGxvZ3MgPSBbXTtcbiAgICB9LFxuICB9O1xufTtcblxubGV0IGluaXRpYWxPdXRwdXQ6IHN0cmluZyA9IFwiXCI7XG5sZXQgY2FwdHVyZWRPdXRwdXQ6IG51bGwgfCBSZXR1cm5UeXBlPHR5cGVvZiBzdGRvdXQ+ID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IGluaXRDYXB0dXJlID0gKCkgPT4gKGNhcHR1cmVkT3V0cHV0ID0gc3Rkb3V0KCkpO1xuXG5leHBvcnQgY29uc3QgY3V0SW5pdGlhbE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgaW5pdGlhbE91dHB1dCA9IGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG4gIGNhcHR1cmVkT3V0cHV0LnJlc2V0KCk7XG59O1xuZXhwb3J0IGNvbnN0IHJlc2V0Q2FwdHVyZSA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgY2FwdHVyZWRPdXRwdXQucmVzZXQoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYXB0dXJlZE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgcmV0dXJuIGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxPdXRwdXQgPSAoKSA9PiBpbml0aWFsT3V0cHV0O1xuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IsIGlzQXhpb3NFcnJvciB9IGZyb20gXCJheGlvc1wiO1xuXG5leHBvcnQgY29uc3QgaXNSZXRyaWFibGVFcnJvciA9IChlcnI6IEF4aW9zRXJyb3IpOiBib29sZWFuID0+IHtcbiAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVyci5jb2RlID09PSBcIkVUSU1FRE9VVFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWlzQXhpb3NFcnJvcihlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKFxuICAgIGVycj8ucmVzcG9uc2U/LnN0YXR1cyAmJlxuICAgIDUwMCA8PSBlcnIucmVzcG9uc2Uuc3RhdHVzICYmXG4gICAgZXJyLnJlc3BvbnNlLnN0YXR1cyA8IDYwMFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldERlbGF5ID0gKGk6IG51bWJlcikgPT4gWzUgKiAxMDAwLCAxMCAqIDEwMDAsIDMwICogMTAwMF1baSAtIDFdO1xuXG5sZXQgYmFzZVVSTCA9IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIjtcbmV4cG9ydCBjb25zdCBnZXRBUElCYXNlVXJsID0gKCkgPT4gYmFzZVVSTCA/PyBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCI7XG5leHBvcnQgY29uc3Qgc2V0QVBJQmFzZVVybCA9ICh1cmw/OiBzdHJpbmcpID0+XG4gIChiYXNlVVJMID0gdXJsID8/IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIik7XG4iLCAiaW1wb3J0IGF4aW9zLCB7XG4gIEF4aW9zRXJyb3IsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZyxcbiAgQXhpb3NSZXNwb25zZSxcbiAgUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyxcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgYXhpb3NSZXRyeSBmcm9tIFwiYXhpb3MtcmV0cnlcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNaWxsaXNlY29uZHMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudHNDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCwgZ2V0RGVsYXksIGlzUmV0cmlhYmxlRXJyb3IgfSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IG1heWJlUHJpbnRFcnJvcnMgfSBmcm9tIFwiLi9wcmludEVycm9yc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6YXBpXCIpO1xuXG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5jb25zdCBUSU1FT1VUX01TID0gMzAgKiAxMDAwO1xubGV0IF9jbGllbnQ6IEF4aW9zSW5zdGFuY2UgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENsaWVudCgpIHtcbiAgaWYgKF9jbGllbnQpIHtcbiAgICByZXR1cm4gX2NsaWVudDtcbiAgfVxuICBjb25zdCBjdXJyZW50c0NvbmZpZyA9IGF3YWl0IGdldEN1cnJlbnRzQ29uZmlnKCk7XG4gIF9jbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICAgIGJhc2VVUkw6IGdldEFQSUJhc2VVcmwoKSxcbiAgICB0aW1lb3V0OiBUSU1FT1VUX01TLFxuICB9KTtcblxuICBfY2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZSgoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY2N5VmVyc29uID0gX2N1cnJlbnRzVmVyc2lvbiA/PyBcIjAuMC4wXCI7XG4gICAgY29uc3QgaGVhZGVyczogUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAgIC4uLmNvbmZpZy5oZWFkZXJzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgXCJ4LWN5cHJlc3MtcmVxdWVzdC1hdHRlbXB0XCI6IGNvbmZpZ1tcImF4aW9zLXJldHJ5XCJdPy5yZXRyeUNvdW50ID8/IDAsXG4gICAgICBcIngtY3lwcmVzcy12ZXJzaW9uXCI6IF9jeXByZXNzVmVyc2lvbiA/PyBcIjAuMC4wXCIsXG4gICAgICBcIngtY2N5LXZlcnNpb25cIjogY2N5VmVyc29uLFxuICAgICAgXCJVc2VyLUFnZW50XCI6IGBjeXByZXNzLWNsb3VkLyR7Y2N5VmVyc29ufWAsXG4gICAgfTtcbiAgICBpZiAoX3J1bklkKSB7XG4gICAgICBoZWFkZXJzW1wieC1jeXByZXNzLXJ1bi1pZFwiXSA9IF9ydW5JZDtcbiAgICB9XG4gICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRzQ29uZmlnLm5ldHdvcmtIZWFkZXJzKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEhlYWRlcnMgPSBfLm9taXQoY3VycmVudHNDb25maWcubmV0d29ya0hlYWRlcnMsIFtcbiAgICAgICAgXCJ4LWN5cHJlc3MtcmVxdWVzdC1hdHRlbXB0XCIsXG4gICAgICAgIFwieC1jeXByZXNzLXZlcnNpb25cIixcbiAgICAgICAgXCJ4LWNjeS12ZXJzaW9uXCIsXG4gICAgICAgIFwieC1jeXByZXNzLXJ1bi1pZFwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiLFxuICAgICAgXSk7XG4gICAgICBkZWJ1ZyhcInVzaW5nIGN1c3RvbSBuZXR3b3JrIGhlYWRlcnM6ICVvXCIsIGZpbHRlcmVkSGVhZGVycyk7XG4gICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIGZpbHRlcmVkSGVhZGVycyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaGVhZGVycyxcbiAgICB9O1xuXG4gICAgZGVidWcoXCJuZXR3b3JrIHJlcXVlc3Q6ICVvXCIsIHtcbiAgICAgIC4uLl8ucGljayhyZXEsIFwibWV0aG9kXCIsIFwidXJsXCIsIFwiaGVhZGVyc1wiKSxcbiAgICAgIGRhdGE6IEJ1ZmZlci5pc0J1ZmZlcihyZXEuZGF0YSkgPyBcImJ1ZmZlclwiIDogcmVxLmRhdGEsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVxO1xuICB9KTtcblxuICBheGlvc1JldHJ5KF9jbGllbnQsIHtcbiAgICByZXRyaWVzOiBNQVhfUkVUUklFUyxcbiAgICByZXRyeUNvbmRpdGlvbjogaXNSZXRyaWFibGVFcnJvcixcbiAgICByZXRyeURlbGF5OiBnZXREZWxheSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb25SZXRyeSxcbiAgICBzaG91bGRSZXNldFRpbWVvdXQ6IHRydWUsXG4gIH0pO1xuICByZXR1cm4gX2NsaWVudDtcbn1cblxubGV0IF9ydW5JZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IHNldFJ1bklkID0gKHJ1bklkOiBzdHJpbmcpID0+IHtcbiAgX3J1bklkID0gcnVuSWQ7XG59O1xuXG5sZXQgX2N5cHJlc3NWZXJzaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0Q3lwcmVzc1ZlcnNpb24gPSAoY3lwcmVzc1ZlcnNpb246IHN0cmluZykgPT4ge1xuICBfY3lwcmVzc1ZlcnNpb24gPSBjeXByZXNzVmVyc2lvbjtcbn07XG5cbmxldCBfY3VycmVudHNWZXJzaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0Q3VycmVudHNWZXJzaW9uID0gKHY6IHN0cmluZykgPT4ge1xuICBfY3VycmVudHNWZXJzaW9uID0gdjtcbn07XG5cbmZ1bmN0aW9uIG9uUmV0cnkoXG4gIHJldHJ5Q291bnQ6IG51bWJlcixcbiAgZXJyOiBBeGlvc0Vycm9yPHsgbWVzc2FnZTogc3RyaW5nOyBlcnJvcnM/OiBzdHJpbmdbXSB9PixcbiAgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWdcbikge1xuICB3YXJuKFxuICAgIFwiTmV0d29yayByZXF1ZXN0ICclcycgZmFpbGVkOiAnJXMnLiBOZXh0IGF0dGVtcHQgaXMgaW4gJXMgKCVkLyVkKS5cIixcbiAgICBgJHtjb25maWcubWV0aG9kfSAke2NvbmZpZy51cmx9YCxcbiAgICBlcnIubWVzc2FnZSxcbiAgICBwcmV0dHlNaWxsaXNlY29uZHMoZ2V0RGVsYXkocmV0cnlDb3VudCkpLFxuICAgIHJldHJ5Q291bnQsXG4gICAgTUFYX1JFVFJJRVNcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2VSZXF1ZXN0ID0gYXN5bmMgPFQgPSBhbnksIEQgPSBhbnk+KFxuICBjb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZzxEPlxuKSA9PiB7XG4gIHJldHVybiAoYXdhaXQgZ2V0Q2xpZW50KCkpPEQsIEF4aW9zUmVzcG9uc2U8VD4+KGNvbmZpZylcbiAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICBkZWJ1ZyhcIm5ldHdvcmsgcmVzcG9uc2U6ICVvXCIsIF8ub21pdChyZXMsIFwicmVxdWVzdFwiLCBcImNvbmZpZ1wiKSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgbWF5YmVQcmludEVycm9ycyhlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0pO1xufTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5cbmltcG9ydCB7IFAsIG1hdGNoIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCB7IERldGVjdGVkQnJvd3NlciwgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyBib290Q3lwcmVzcyB9IGZyb20gXCIuLi9ib290c3RyYXBcIjtcbmltcG9ydCB7IGluZm8sIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRDb25maWdGaWxlUGF0aCB9IGZyb20gXCIuL3BhdGhcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmNvbmZpZ1wiKTtcblxuZXhwb3J0IHR5cGUgRTJFQ29uZmlnID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbn07XG5leHBvcnQgdHlwZSBDb21wb25lbnRDb25maWcgPSB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIEN1cnJlbnRzQ29uZmlnID0ge1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIHJlY29yZEtleT86IHN0cmluZztcbiAgY2xvdWRTZXJ2aWNlVXJsOiBzdHJpbmc7XG4gIGUyZTogRTJFQ29uZmlnO1xuICBjb21wb25lbnQ6IENvbXBvbmVudENvbmZpZztcbiAgbmV0d29ya0hlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufTtcblxubGV0IF9jb25maWc6IEN1cnJlbnRzQ29uZmlnIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IGRlZmF1bHRDb25maWc6IEN1cnJlbnRzQ29uZmlnID0ge1xuICBlMmU6IHtcbiAgICBiYXRjaFNpemU6IDMsXG4gIH0sXG4gIGNvbXBvbmVudDoge1xuICAgIGJhdGNoU2l6ZTogNSxcbiAgfSxcbiAgY2xvdWRTZXJ2aWNlVXJsOiBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCIsXG4gIG5ldHdvcmtIZWFkZXJzOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudHNDb25maWcoXG4gIHByb2plY3RSb290Pzogc3RyaW5nLFxuICBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoPzogc3RyaW5nXG4pOiBQcm9taXNlPEN1cnJlbnRzQ29uZmlnPiB7XG4gIGlmIChfY29uZmlnKSB7XG4gICAgcmV0dXJuIF9jb25maWc7XG4gIH1cblxuICBjb25zdCBjb25maWdGaWxlUGF0aCA9IGdldENvbmZpZ0ZpbGVQYXRoKHByb2plY3RSb290LCBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKTtcbiAgLy8gdHJ5IGxvYWRpbmcgcG9zc2libGUgY29uZmlnIGZpbGVzXG4gIGZvciAoY29uc3QgZmlsZXBhdGggb2YgY29uZmlnRmlsZVBhdGgpIHtcbiAgICBjb25zdCBjb25maWcgPSBtYXRjaChhd2FpdCBsb2FkQ29uZmlnRmlsZShmaWxlcGF0aCkpXG4gICAgICAud2l0aCh7IGRlZmF1bHQ6IFAubm90KFAubnVsbGlzaCkgfSwgKGMpID0+IGMuZGVmYXVsdClcbiAgICAgIC53aXRoKFAubm90KFAubnVsbGlzaCksIChjKSA9PiBjKVxuICAgICAgLm90aGVyd2lzZSgoKSA9PiBudWxsKTtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGRlYnVnKFwibG9hZGVkIGN1cnJlbnRzIGNvbmZpZyBmcm9tICclcydcXG4lT1wiLCBmaWxlcGF0aCwgY29uZmlnKTtcbiAgICAgIGluZm8oXCJVc2luZyBjb25maWcgZmlsZTogJyVzJ1wiLCBmaWxlcGF0aCk7XG4gICAgICBfY29uZmlnID0ge1xuICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAuLi5jb25maWcsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgfVxuICB9XG5cbiAgd2FybihcbiAgICBcIkZhaWxlZCB0byBsb2FkIGNvbmZpZyBmaWxlLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgY29uZmlnLiBBdHRlbXB0ZWQgbG9jYXRpb25zOiAlc1wiLFxuICAgIGNvbmZpZ0ZpbGVQYXRoXG4gICk7XG4gIF9jb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICByZXR1cm4gX2NvbmZpZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZENvbmZpZ0ZpbGUoZmlsZXBhdGg6IHN0cmluZykge1xuICB0cnkge1xuICAgIGRlYnVnKFwibG9hZGluZyBjdXJyZW50cyBjb25maWcgZmlsZSBmcm9tICclcydcIiwgZmlsZXBhdGgpO1xuICAgIHJldHVybiBhd2FpdCBpbXBvcnQoZmlsZXBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoXCJmYWlsZWQgbG9hZGluZyBjb25maWcgZmlsZSBmcm9tOiAlc1wiLCBlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNZXJnZWRDb25maWcgPSBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGdldE1lcmdlZENvbmZpZz4+O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1lcmdlZENvbmZpZyhwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycykge1xuICBkZWJ1ZyhcInJlc29sdmluZyBjeXByZXNzIGNvbmZpZ1wiKTtcbiAgY29uc3QgY3lwcmVzc1Jlc29sdmVkQ29uZmlnOlxuICAgIHwgKEN5cHJlc3MuUmVzb2x2ZWRDb25maWdPcHRpb25zICYge1xuICAgICAgICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICAgICAgICByYXdKc29uOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgYnJvd3NlcnM6IERldGVjdGVkQnJvd3NlcltdO1xuICAgICAgfSlcbiAgICB8IHVuZGVmaW5lZCA9IGF3YWl0IGJvb3RDeXByZXNzKHBhcmFtcyk7XG5cbiAgZGVidWcoXCJjeXByZXNzIHJlc29sdmVkQ29uZmlnOiAlT1wiLCBjeXByZXNzUmVzb2x2ZWRDb25maWcpO1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgcmF3RTJFUGF0dGVybiA9IGN5cHJlc3NSZXNvbHZlZENvbmZpZy5yYXdKc29uPy5lMmU/LnNwZWNQYXR0ZXJuO1xuICBsZXQgYWRkaXRpb25hbElnbm9yZVBhdHRlcm46IHN0cmluZ1tdID0gW107XG4gIGlmIChwYXJhbXMudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCIgJiYgcmF3RTJFUGF0dGVybikge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybiA9IHJhd0UyRVBhdHRlcm47XG4gIH1cblxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2VkMDY2OGUyNGMyZWU2NzUzYmJkMjVhZTQ2N2NlOTRhZTU4NTc3NDEvcGFja2FnZXMvY29uZmlnL3NyYy9vcHRpb25zLnRzI0w0NTdcbiAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9kZXZlbG9wL3BhY2thZ2VzL2NvbmZpZy9zcmMvcHJvamVjdC91dGlscy50cyNMNDEyXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwcm9qZWN0Um9vdDogY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5wcm9qZWN0Um9vdCB8fCBwcm9jZXNzLmN3ZCgpLFxuICAgIHByb2plY3RJZDogcGFyYW1zLnByb2plY3RJZCxcbiAgICBzcGVjUGF0dGVybjogY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5zcGVjUGF0dGVybiB8fCBcIioqLyouKlwiLFxuICAgIGV4Y2x1ZGVTcGVjUGF0dGVybjpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGN5cHJlc3NSZXNvbHZlZENvbmZpZz8ucmVzb2x2ZWQuZXhjbHVkZVNwZWNQYXR0ZXJuLnZhbHVlID8/IFtdLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICAgIHJlc29sdmVkOiBjeXByZXNzUmVzb2x2ZWRDb25maWcsXG4gICAgZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmc6IHBhcmFtcy5leHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZyxcbiAgfTtcbiAgZGVidWcoXCJtZXJnZWQgY29uZmlnOiAlT1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuIiwgImltcG9ydCB7IGdldEJpblBhdGggfSBmcm9tIFwiY3kyXCI7XG5pbXBvcnQgeyBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IGV4ZWNhLCB7IEV4ZWNhRXJyb3IgfSBmcm9tIFwiZXhlY2FcIjtcbmltcG9ydCBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IGNyZWF0ZVRlbXBGaWxlIH0gZnJvbSBcIi4uL2ZzXCI7XG5pbXBvcnQgeyBib2xkLCBpbmZvIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgcmVxdWlyZSB9IGZyb20gXCIuLi9yZXF1aXJlXCI7XG5pbXBvcnQgeyBnZXRCb290c3RyYXBBcmdzIH0gZnJvbSBcIi4vc2VyaWFsaXplclwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Ym9vdFwiKTtcblxuZXhwb3J0IGNvbnN0IGJvb3RDeXByZXNzID0gYXN5bmMgKHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzKSA9PiB7XG4gIGRlYnVnKFwiYm9vdGluZyBjeXByZXNzLi4uXCIpO1xuICBjb25zdCB0ZW1wRmlsZVBhdGggPSBhd2FpdCBjcmVhdGVUZW1wRmlsZSgpO1xuXG4gIGNvbnN0IGN5cHJlc3NCaW4gPSBhd2FpdCBnZXRCaW5QYXRoKHJlcXVpcmUucmVzb2x2ZShcImN5cHJlc3NcIikpO1xuICBkZWJ1ZyhcImN5cHJlc3MgZXhlY3V0YWJsZSBsb2NhdGlvbjogJXNcIiwgY3lwcmVzc0Jpbik7XG5cbiAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIHBhc3MgdGhlIHNhbWUgYXJncyBpbiBvcmRlciB0byBnZXQgdGhlIHNhbWUgY29uZmlnIGFzIGZvciB0aGUgYWN0dWFsIHJ1blxuICBjb25zdCBhcmdzID0gZ2V0Qm9vdHN0cmFwQXJncyh7IHRlbXBGaWxlUGF0aCwgcGFyYW1zIH0pO1xuICBkZWJ1ZyhcImJvb3RpbmcgY3lwcmVzcyB3aXRoIGFyZ3M6ICVvXCIsIGFyZ3MpO1xuICBjb25zdCB7IHN0ZG91dCwgc3RkZXJyIH0gPSBhd2FpdCBleGVjQ3lwcmVzcyhjeXByZXNzQmluLCBhcmdzKTtcblxuICBpZiAoIWZzLmV4aXN0c1N5bmModGVtcEZpbGVQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcmVzb2x2ZSBjeXByZXNzIGNvbmZpZ3VyYXRpb24gZnJvbSAke3RlbXBGaWxlUGF0aH0uIFBsZWFzZSByZXBvcnQgdGhlIGlzc3VlLmBcbiAgICApO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZiA9IGZzLnJlYWRGaWxlU3luYyh0ZW1wRmlsZVBhdGgsIFwidXRmLThcIik7XG4gICAgaWYgKCFmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJcyBjeXByZXNzLWNsb3VkL3BsdWdpbiBpbnN0YWxsZWQ/XCIpO1xuICAgIH1cbiAgICBkZWJ1ZyhcImN5cHJlc3MgY29uZmlnICclcyc6ICclcydcIiwgdGVtcEZpbGVQYXRoLCBmKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcoXCJyZWFkIGNvbmZpZyB0ZW1wIGZpbGUgZmFpbGVkOiAlb1wiLCBlcnIpO1xuICAgIGluZm8oYm9sZChcIkN5cHJlc3Mgc3Rkb3V0OlxcblwiKSwgc3Rkb3V0KTtcbiAgICBpbmZvKGJvbGQoXCJDeXByZXNzIHN0ZGVycjpcXG5cIiksIHN0ZGVycik7XG5cbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBVbmFibGUgdG8gcmVzb2x2ZSBjeXByZXNzIGNvbmZpZ3VyYXRpb25cbi0gbWFrZSBzdXJlIHRoYXQgJ2N5cHJlc3MtY2xvdWQvcGx1Z2luJyBpcyBpbnN0YWxsZWRcbi0gcmVwb3J0IHRoZSBpc3N1ZSB0b2dldGhlciB3aXRoIGN5cHJlc3Mgc3Rkb3V0IGFuZCBzdGRlcnJcbmApO1xuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiBleGVjQ3lwcmVzcyhjeXByZXNzQmluOiBzdHJpbmcsIGFyZ3M6IHJlYWRvbmx5IHN0cmluZ1tdKSB7XG4gIGxldCBzdGRvdXQgPSBcIlwiO1xuICBsZXQgc3RkZXJyID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjYShjeXByZXNzQmluLCBbXCJydW5cIiwgLi4uYXJnc10sIHtcbiAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIGVudjoge1xuICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgLy8gcHJldmVudCB3YXJuaW5ncyBhYm91dCByZWNvcmRpbmcgbW9kZVxuICAgICAgICBDWVBSRVNTX1JFQ09SRF9LRVk6IHVuZGVmaW5lZCxcbiAgICAgICAgQ1lQUkVTU19QUk9KRUNUX0lEOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZyhcImV4ZWMgY3lwcmVzcyBmYWlsZWQgKGNlcnRhaW4gZmFpbHVyZXMgYXJlIGV4cGVjdGVkKTogJW9cIiwgZXJyKTtcbiAgICBzdGRvdXQgPSAoZXJyIGFzIEV4ZWNhRXJyb3IpLnN0ZG91dDtcbiAgICBzdGRlcnIgPSAoZXJyIGFzIEV4ZWNhRXJyb3IpLnN0ZGVycjtcbiAgfVxuICByZXR1cm4geyBzdGRvdXQsIHN0ZGVyciB9O1xufVxuIiwgImV4cG9ydCBjbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmaWxlIH0gZnJvbSBcInRtcC1wcm9taXNlXCI7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUZW1wRmlsZSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBwYXRoIH0gPSBhd2FpdCBmaWxlKCk7XG4gIHJldHVybiBwYXRoO1xufTtcbiIsICJpbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgdXRpbCBmcm9tIFwidXRpbFwiO1xuXG5jb25zdCBsb2cgPSAoLi4uYXJnczogdW5rbm93bltdKSA9PiBjb25zb2xlLmxvZyh1dGlsLmZvcm1hdCguLi5hcmdzKSk7XG5cbmV4cG9ydCBjb25zdCBpbmZvID0gbG9nO1xuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IHV0aWwuZm9ybWF0O1xuXG5leHBvcnQgY29uc3Qgd2l0aEVycm9yID0gKG1zZzogc3RyaW5nKSA9PlxuICBjaGFsay5iZ1JlZC53aGl0ZShcIiBFUlJPUiBcIikgKyBcIiBcIiArIG1zZztcbmV4cG9ydCBjb25zdCB3aXRoV2FybmluZyA9IChtc2c6IHN0cmluZykgPT5cbiAgY2hhbGsuYmdZZWxsb3cuYmxhY2soXCIgV0FSTklORyBcIikgKyBcIiBcIiArIG1zZztcblxuZXhwb3J0IGNvbnN0IHdhcm4gPSAoLi4uYXJnczogdW5rbm93bltdKSA9PlxuICBsb2cod2l0aFdhcm5pbmcodXRpbC5mb3JtYXQoLi4uYXJncykpKTtcblxuZXhwb3J0IGNvbnN0IHN1Y2Nlc3MgPSAoLi4uYXJnczogdW5rbm93bltdKSA9PlxuICBsb2coY2hhbGsuZ3JlZW4odXRpbC5mb3JtYXQoLi4uYXJncykpKTtcblxuZXhwb3J0IGNvbnN0IGVycm9yID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKHdpdGhFcnJvcih1dGlsLmZvcm1hdCguLi5hcmdzKSkgKyBcIlxcblwiKTtcblxudHlwZSBDb2xvciA9IFwicmVkXCIgfCBcImdyZWVuXCIgfCBcInllbGxvd1wiIHwgXCJibHVlXCIgfCBcIm1hZ2VudGFcIiB8IFwiY3lhblwiIHwgXCJ3aGl0ZVwiO1xuZXhwb3J0IGNvbnN0IHRpdGxlID0gKGNvbG9yOiBDb2xvciwgLi4uYXJnczogdW5rbm93bltdKSA9PlxuICBpbmZvKFwiXFxuXCIgKyBcIiAgXCIgKyBjaGFsa1tjb2xvcl0uYm9sZCh1dGlsLmZvcm1hdCguLi5hcmdzKSkgKyBcIiAgXCIgKyBcIlxcblwiKTtcblxuZXhwb3J0IGNvbnN0IGRpdmlkZXIgPSAoKSA9PlxuICBjb25zb2xlLmxvZyhcIlxcblwiICsgY2hhbGsuZ3JheShBcnJheSgxMDApLmZpbGwoXCI9XCIpLmpvaW4oXCJcIikpICsgXCJcXG5cIik7XG5cbmV4cG9ydCBjb25zdCBzcGFjZXIgPSAobjogbnVtYmVyID0gMCkgPT5cbiAgY29uc29sZS5sb2coQXJyYXkobikuZmlsbChcIlwiKS5qb2luKFwiXFxuXCIpKTtcblxuZXhwb3J0IGNvbnN0IGN5YW4gPSBjaGFsay5jeWFuO1xuZXhwb3J0IGNvbnN0IGJsdWUgPSBjaGFsay5ibHVlQnJpZ2h0O1xuZXhwb3J0IGNvbnN0IHJlZCA9IGNoYWxrLnJlZDtcbmV4cG9ydCBjb25zdCBncmVlbiA9IGNoYWxrLmdyZWVuQnJpZ2h0O1xuZXhwb3J0IGNvbnN0IGdyYXkgPSBjaGFsay5ncmF5O1xuZXhwb3J0IGNvbnN0IHdoaXRlID0gY2hhbGsud2hpdGU7XG5leHBvcnQgY29uc3QgbWFnZW50YSA9IGNoYWxrLm1hZ2VudGE7XG5leHBvcnQgY29uc3QgYm9sZCA9IGNoYWxrLmJvbGQ7XG5leHBvcnQgY29uc3QgeWVsbG93ID0gY2hhbGsueWVsbG93O1xuZXhwb3J0IGNvbnN0IGRpbSA9IGNoYWxrLmRpbTtcbiIsICJpbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIEN5cHJlc3NSdW5QYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkXCI7XG5pbXBvcnQgeyBnZXRDeXByZXNzUnVuQVBJUGFyYW1zIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmJvb3RcIik7XG5cbmNvbnN0IGdldER1bW15U3BlYyA9IGN1c3RvbUFscGhhYmV0KFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIiwgMTApO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm9vdHN0cmFwQXJncyh7XG4gIHBhcmFtcyxcbiAgdGVtcEZpbGVQYXRoLFxufToge1xuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycztcbiAgdGVtcEZpbGVQYXRoOiBzdHJpbmc7XG59KSB7XG4gIHJldHVybiBfLmNoYWluKGdldEN5cHJlc3NDTElQYXJhbXMocGFyYW1zKSlcbiAgICAudGhydSgob3B0cykgPT4gKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICAvLyBtZXJnZSB0aGUgZW52IHdpdGggdGhlIGN1cnJlbnRzIHNwZWNpZmljIGVudiB2YXJpYWJsZXNcbiAgICAgIGVudjoge1xuICAgICAgICAuLi4ob3B0cy5lbnYgPz8ge30pLFxuICAgICAgICBjdXJyZW50c190ZW1wX2ZpbGU6IHRlbXBGaWxlUGF0aCxcbiAgICAgICAgY3VycmVudHNfZGVidWdfZW5hYmxlZDogcHJvY2Vzcy5lbnYuREVCVUc/LmluY2x1ZGVzKFwiY3VycmVudHM6XCIpXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSkpXG4gICAgLnRhcCgob3B0cykgPT4ge1xuICAgICAgZGVidWcoXCJjeXByZXNzIGJvb3RzdHJhcCBwYXJhbXM6ICVvXCIsIG9wdHMpO1xuICAgIH0pXG4gICAgLnRocnUoc2VyaWFsaXplT3B0aW9ucylcbiAgICAudGFwKChvcHRzKSA9PiB7XG4gICAgICBkZWJ1ZyhcImN5cHJlc3MgYm9vdHN0cmFwIHNlcmlhbGl6ZWQgcGFyYW1zOiAlb1wiLCBvcHRzKTtcbiAgICB9KVxuICAgIC50aHJ1KChhcmdzKSA9PiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5hcmdzLFxuICAgICAgICBcIi0tc3BlY1wiLFxuICAgICAgICBnZXREdW1teVNwZWMoKSxcbiAgICAgICAgcGFyYW1zLnRlc3RpbmdUeXBlID09PSBcImNvbXBvbmVudFwiID8gXCItLWNvbXBvbmVudFwiIDogXCItLWUyZVwiLFxuICAgICAgXTtcbiAgICB9KVxuICAgIC52YWx1ZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIEN1cnJlbnRzIG9wdGlvbnMgdG8gQ3lwcmVzcyBDTEkgcGFyYW1zLlxuICogQ3lwcmVzcyBDTEkgb3B0aW9ucyBhcmUgZGlmZmVyZW50IGZyb20gQ3lwcmVzcyBtb2R1bGUgQVBJIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHBhcmFtcyBDdXJyZW50cyBwYXJhbVxuICogQHJldHVybnMgQ3lwcmVzcyBDTEkgcGFyYW1zXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5jeXByZXNzLmlvL2d1aWRlcy9ndWlkZXMvY29tbWFuZC1saW5lI2N5cHJlc3MtcnVuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5jeXByZXNzLmlvL2FwaS9tb2R1bGUtYXBpXG4gKi9cbmZ1bmN0aW9uIGdldEN5cHJlc3NDTElQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBDeXByZXNzUnVuUGFyYW1ldGVycyB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEN5cHJlc3NSdW5BUElQYXJhbXMocGFyYW1zKTtcbiAgY29uc3QgdGVzdGluZ1R5cGUgPVxuICAgIHJlc3VsdC50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIlxuICAgICAgPyB7XG4gICAgICAgICAgY29tcG9uZW50OiB0cnVlLFxuICAgICAgICB9XG4gICAgICA6IHt9O1xuICByZXR1cm4ge1xuICAgIC4uLl8ub21pdChyZXN1bHQsIFwidGVzdGluZ1R5cGVcIiksXG4gICAgLi4udGVzdGluZ1R5cGUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mbGF0TWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBfa2V5ID0gZGFzaGVkKGtleSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/IFtgLS0ke19rZXl9YF0gOiBbYC0tJHtfa2V5fWAsIGZhbHNlXTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbYC0tJHtfa2V5fWAsIHNlcmlhbGl6ZUNvbXBsZXhQYXJhbSh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gW2AtLSR7X2tleX1gLCB2YWx1ZS50b1N0cmluZygpXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNvbXBsZXhQYXJhbShwYXJhbToge30pIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtKTtcbn1cblxuY29uc3QgZGFzaGVkID0gKHY6IHN0cmluZykgPT4gdi5yZXBsYWNlKC9bQS1aXS9nLCAobSkgPT4gXCItXCIgKyBtLnRvTG93ZXJDYXNlKCkpO1xuIiwgImltcG9ydCBpc0Fic29sdXRlIGZyb20gXCJpcy1hYnNvbHV0ZVwiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRGaWxlbmFtZXMgPSBbXG4gIFwiY3VycmVudHMuY29uZmlnLmpzXCIsXG4gIFwiY3VycmVudHMuY29uZmlnLmNqc1wiLFxuICBcImN1cnJlbnRzLmNvbmZpZy5tanNcIixcbl07XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uZmlnRmlsZVBhdGgoXG4gIHByb2plY3RSb290OiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgZXhwbGljaXRDb25maWdGaWxlUGF0aD86IHN0cmluZ1xuKTogc3RyaW5nW10ge1xuICBjb25zdCBwcmVmaXggPSBwcm9qZWN0Um9vdCA/PyBwcm9jZXNzLmN3ZCgpO1xuICBpZiAoXG4gICAgXy5pc1N0cmluZyhleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKSAmJlxuICAgIGlzQWJzb2x1dGUoZXhwbGljaXRDb25maWdGaWxlUGF0aClcbiAgKSB7XG4gICAgcmV0dXJuIFtleHBsaWNpdENvbmZpZ0ZpbGVQYXRoXTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKSkge1xuICAgIHJldHVybiBbbm9ybWFsaXplUGF0aChwcmVmaXgsIGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpXTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0RmlsZW5hbWVzLm1hcCgocCkgPT4gbm9ybWFsaXplUGF0aChwcmVmaXgsIHApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocHJlZml4OiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYGZpbGU6Ly8ke3BhdGgucmVzb2x2ZShwcmVmaXgsIGZpbGVuYW1lKX1gO1xufVxuIiwgImltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1J1blBhcmFtZXRlcnMsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IGVycm9yIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudHNDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czp2YWxpZGF0ZVBhcmFtc1wiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVDdXJyZW50c1BhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IFByb21pc2U8Q3VycmVudHNSdW5QYXJhbWV0ZXJzPiB7XG4gIGNvbnN0IGNvbmZpZ0Zyb21GaWxlID0gYXdhaXQgZ2V0Q3VycmVudHNDb25maWcoXG4gICAgcGFyYW1zLnByb2plY3QsXG4gICAgcGFyYW1zLmNsb3VkQ29uZmlnRmlsZVxuICApO1xuXG4gIGRlYnVnKFwicmVzb2x2aW5nIGN1cnJlbnRzIHBhcmFtczogJW9cIiwgcGFyYW1zKTtcbiAgZGVidWcoXCJyZXNvbHZpbmcgY3VycmVudHMgY29uZmlnIGZpbGU6ICVvXCIsIGNvbmZpZ0Zyb21GaWxlKTtcbiAgY29uc3QgY2xvdWRTZXJ2aWNlVXJsID1cbiAgICBwYXJhbXMuY2xvdWRTZXJ2aWNlVXJsID8/XG4gICAgcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfQVBJX1VSTCA/P1xuICAgIGNvbmZpZ0Zyb21GaWxlLmNsb3VkU2VydmljZVVybDtcblxuICBjb25zdCByZWNvcmRLZXkgPVxuICAgIHBhcmFtcy5yZWNvcmRLZXkgPz9cbiAgICBwcm9jZXNzLmVudi5DVVJSRU5UU19SRUNPUkRfS0VZID8/XG4gICAgY29uZmlnRnJvbUZpbGUucmVjb3JkS2V5O1xuXG4gIGNvbnN0IHByb2plY3RJZCA9XG4gICAgcGFyYW1zLnByb2plY3RJZCA/P1xuICAgIHByb2Nlc3MuZW52LkNVUlJFTlRTX1BST0pFQ1RfSUQgPz9cbiAgICBjb25maWdGcm9tRmlsZS5wcm9qZWN0SWQ7XG5cbiAgY29uc3QgdGVzdGluZ1R5cGUgPSBwYXJhbXMudGVzdGluZ1R5cGUgPz8gXCJlMmVcIjtcblxuICBjb25zdCBiYXRjaFNpemUgPVxuICAgIHRlc3RpbmdUeXBlID09PSBcImUyZVwiXG4gICAgICA/IGNvbmZpZ0Zyb21GaWxlLmUyZS5iYXRjaFNpemVcbiAgICAgIDogY29uZmlnRnJvbUZpbGUuY29tcG9uZW50LmJhdGNoU2l6ZTtcblxuICAvLyBiYXRjaFNpemUgYW5kIGNsb3VkU2VydmljZVVybCBkZWZhdWx0cyBhcmUgaW4gZ2V0Q3VycmVudHNDb25maWcoKVxuICByZXR1cm4ge1xuICAgIC4uLnBhcmFtcyxcbiAgICBjbG91ZFNlcnZpY2VVcmwsXG4gICAgcmVjb3JkS2V5LFxuICAgIHByb2plY3RJZCxcbiAgICBiYXRjaFNpemUsXG4gICAgdGVzdGluZ1R5cGUsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBwcm9qZWN0SWRFcnJvciA9IGBDYW5ub3QgcmVzb2x2ZSBwcm9qZWN0SWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4tIHByb3ZpZGUgaXQgYXMgYSBcInByb2plY3RJZFwiIHByb3BlcnR5IGZvciBcInJ1blwiIEFQSSBtZXRob2Rcbi0gc2V0IENVUlJFTlRTX1BST0pFQ1RfSUQgZW52aXJvbm1lbnQgdmFyaWFibGVcbi0gc2V0IFwicHJvamVjdElkXCIgaW4gXCJjdXJyZW50cy5jb25maWcue2N9anNcIiBmaWxlYDtcblxuZXhwb3J0IGNvbnN0IGNsb3VkU2VydmljZVVybEVycm9yID0gYENhbm5vdCByZXNvbHZlIGNsb3VkIHNlcnZpY2UgVVJMLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLSBwcm92aWRlIGl0IGFzIGEgXCJjbG91ZFNlcnZpY2VVcmxcIiBwcm9wZXJ0eSBmb3IgXCJydW5cIiBBUEkgbWV0aG9kXG4tIHNldCBDVVJSRU5UU19BUElfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlXG4tIHNldCBcImNsb3VkU2VydmljZVVybFwiIGluIFwiY3VycmVudHMuY29uZmlnLntjfWpzXCIgZmlsZWA7XG5cbmV4cG9ydCBjb25zdCBjbG91ZFNlcnZpY2VJbnZhbGlkVXJsRXJyb3IgPSBgSW52YWxpZCBjbG91ZCBzZXJ2aWNlIFVSTCBwcm92aWRlZGA7XG5cbmV4cG9ydCBjb25zdCByZWNvcmRLZXlFcnJvciA9IGBDYW5ub3QgcmVzb2x2ZSByZWNvcmQga2V5LiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuXG4tIHBhc3MgaXQgYXMgYSBDTEkgZmxhZyAnLWssIC0ta2V5IDxyZWNvcmQta2V5Pidcbi0gcHJvdmlkZSBpdCBhcyBhIFwicmVjb3JkS2V5XCIgcHJvcGVydHkgZm9yIFwicnVuXCIgQVBJIG1ldGhvZFxuLSBzZXQgQ1VSUkVOVFNfUkVDT1JEX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuLSBzZXQgXCJyZWNvcmRLZXlcIiBpbiBcImN1cnJlbnRzLmNvbmZpZy57Y31qc1wiIGZpbGVcbmA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtcyhcbiAgX3BhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBQcm9taXNlPFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycz4ge1xuICBjb25zdCBwYXJhbXMgPSBhd2FpdCByZXNvbHZlQ3VycmVudHNQYXJhbXMoX3BhcmFtcyk7XG5cbiAgZGVidWcoXCJ2YWxpZGF0aW5nIGN1cnJlbnRzIHBhcmFtczogJW9cIiwgcGFyYW1zKTtcbiAgaWYgKCFwYXJhbXMuY2xvdWRTZXJ2aWNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihjbG91ZFNlcnZpY2VVcmxFcnJvcik7XG4gIH1cbiAgaWYgKCFwYXJhbXMucHJvamVjdElkKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihwcm9qZWN0SWRFcnJvcik7XG4gIH1cbiAgaWYgKCFwYXJhbXMucmVjb3JkS2V5KSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihyZWNvcmRLZXlFcnJvcik7XG4gIH1cblxuICB2YWxpZGF0ZVVSTChwYXJhbXMuY2xvdWRTZXJ2aWNlVXJsKTtcblxuICBjb25zdCByZXF1aXJlZFBhcmFtZXRlcnM6IEFycmF5PGtleW9mIEN1cnJlbnRzUnVuUGFyYW1ldGVycz4gPSBbXG4gICAgXCJ0ZXN0aW5nVHlwZVwiLFxuICAgIFwiYmF0Y2hTaXplXCIsXG4gICAgXCJwcm9qZWN0SWRcIixcbiAgXTtcbiAgcmVxdWlyZWRQYXJhbWV0ZXJzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zW2tleV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBcIiVzXCInLCBrZXkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXJcIik7XG4gICAgfVxuICB9KTtcblxuICBwYXJhbXMudGFnID0gcGFyc2VUYWdzKHBhcmFtcy50YWcpO1xuICBwYXJhbXMuYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXMgPSBnZXRBdXRvQ2FuY2VsVmFsdWUoXG4gICAgcGFyYW1zLmF1dG9DYW5jZWxBZnRlckZhaWx1cmVzXG4gICk7XG5cbiAgZGVidWcoXCJ2YWxpZGF0ZWQgY3VycmVudHMgcGFyYW1zOiAlb1wiLCBwYXJhbXMpO1xuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIGNhc3QgYWZ0ZXIgZmluZGluZyBhIHdheSB0byBwcm9wZXJseSByZXNvbHZlIHBhcmFtcyB0eXBlIGFmdGVyIHZhbGlkYXRpb25zXG4gIHJldHVybiBwYXJhbXMgYXMgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzO1xufVxuXG5mdW5jdGlvbiBnZXRBdXRvQ2FuY2VsVmFsdWUodmFsdWU6IHVua25vd24pOiBudW1iZXIgfCBmYWxzZSB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gMSA6IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IDApIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgIGBhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlczogc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciBcImZhbHNlXCIuIEdvdDogXCIke3ZhbHVlfVwiYFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPZmZsaW5lKHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBwYXJhbXMucmVjb3JkID09PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUYWdzKHRhZ1N0cmluZzogQ3VycmVudHNSdW5QYXJhbWV0ZXJzW1widGFnXCJdKTogc3RyaW5nW10ge1xuICBpZiAoIXRhZ1N0cmluZykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YWdTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHRhZ1N0cmluZy5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbiAgcmV0dXJuIHRhZ1N0cmluZ1xuICAgIC5zcGxpdChcIixcIilcbiAgICAubWFwKCh0YWcpID0+IHRhZy50cmltKCkpXG4gICAgLmZpbHRlcihCb29sZWFuKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVUkwodXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7Y2xvdWRTZXJ2aWNlSW52YWxpZFVybEVycm9yfTogXCIke3VybH1cImApO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm5zIEN5cHJlc3Mgb3B0aW9ucyB3aXRob3V0IGl0ZW1zIHRoYXQgYWZmZWN0IHJlY29yZGluZyBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDeXByZXNzUnVuQVBJUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3lwcmVzc1J1blBhcmFtZXRlcnMge1xuICByZXR1cm4ge1xuICAgIC4uLl8ucGlja0J5KFxuICAgICAgXy5vbWl0KHBhcmFtcywgW1xuICAgICAgICBcImNsb3VkRGVidWdcIixcbiAgICAgICAgXCJjbG91ZENvbmZpZ0ZpbGVcIixcbiAgICAgICAgXCJhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlc1wiLFxuICAgICAgICBcImNsb3VkU2VydmljZVVybFwiLFxuICAgICAgICBcImJhdGNoU2l6ZVwiLFxuICAgICAgICBcInByb2plY3RJZFwiLFxuICAgICAgICBcImtleVwiLFxuICAgICAgICBcInJlY29yZEtleVwiLFxuICAgICAgICBcInJlY29yZFwiLFxuICAgICAgICBcImdyb3VwXCIsXG4gICAgICAgIFwicGFyYWxsZWxcIixcbiAgICAgICAgXCJ0YWdcIixcbiAgICAgICAgXCJjaUJ1aWxkSWRcIixcbiAgICAgICAgXCJzcGVjXCIsXG4gICAgICAgIFwiZXhpdFwiLFxuICAgICAgICBcImhlYWRsZXNzXCIsXG4gICAgICAgIFwiZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmdcIixcbiAgICAgIF0pLFxuICAgICAgQm9vbGVhblxuICAgICksXG4gICAgcmVjb3JkOiBmYWxzZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXByb2Nlc3NQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBDdXJyZW50c1J1blBhcmFtZXRlcnMge1xuICByZXR1cm4ge1xuICAgIC4uLnBhcmFtcyxcbiAgICBzcGVjOiBwcm9jZXNzU3BlY1BhcmFtKHBhcmFtcy5zcGVjKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1NwZWNQYXJhbShcbiAgc3BlYzogQ3VycmVudHNSdW5QYXJhbWV0ZXJzW1wic3BlY1wiXVxuKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICBpZiAoIXNwZWMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHNwZWMubWFwKChpKSA9PiBpLnNwbGl0KFwiLFwiKSkpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWMuc3BsaXQoXCIsXCIpO1xufVxuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IHNwYWNlciwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUHJpbnRFcnJvcnMoXG4gIGVycjogQXhpb3NFcnJvcjx7IG1lc3NhZ2U6IHN0cmluZzsgZXJyb3JzPzogc3RyaW5nW10gfT5cbikge1xuICBpZiAoIWVyci5yZXNwb25zZT8uZGF0YSB8fCAhZXJyLnJlc3BvbnNlPy5zdGF0dXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IG1lc3NhZ2UsIGVycm9ycyB9ID0gZXJyLnJlc3BvbnNlLmRhdGE7XG5cbiAgc3dpdGNoIChlcnIucmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDE6XG4gICAgICB3YXJuKFwiUmVjZWl2ZWQgNDAxIFVuYXV0aG9yaXplZFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDIyOlxuICAgICAgc3BhY2VyKDEpO1xuICAgICAgd2FybiguLi5mb3JtYXRHZW5lcmljRXJyb3IobWVzc2FnZSwgZXJyb3JzKSk7XG4gICAgICBzcGFjZXIoMSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEdlbmVyaWNFcnJvcihcbiAgbWVzc2FnZT86IHN0cmluZyxcbiAgZXJyb3JzPzogc3RyaW5nW11cbik6IHN0cmluZ1tdIHtcbiAgaWYgKCFfLmlzU3RyaW5nKG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFtcIlVuZXhwZWN0ZWQgZXJyb3IgZnJvbSB0aGUgY2xvdWQgc2VydmljZVwiXTtcbiAgfVxuXG4gIGlmIChlcnJvcnM/Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbbWVzc2FnZSBhcyBzdHJpbmddO1xuICB9XG4gIHJldHVybiBbXG4gICAgbWVzc2FnZSBhcyBzdHJpbmcsXG4gICAgYFxuJHsoZXJyb3JzID8/IFtdKS5tYXAoKGUpID0+IGAgIC0gJHtlfWApLmpvaW4oXCJcXG5cIil9XG5gLFxuICBdO1xufVxuIiwgImltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vbGliL3JlcXVpcmVcIjtcbmltcG9ydCBcIi4vc3Rkb3V0XCI7XG5pbXBvcnQgXCIuL3dzXCI7XG5cbmNvbnN0IGN5cHJlc3NQa2cgPSByZXF1aXJlKFwiY3lwcmVzcy9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBwa2cgPSByZXF1aXJlKFwiY3lwcmVzcy1jbG91ZC9wYWNrYWdlLmpzb25cIik7XG5cbmltcG9ydCB7IGluaXRDYXB0dXJlIH0gZnJvbSBcIi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgc2V0Q3VycmVudHNWZXJzaW9uLCBzZXRDeXByZXNzVmVyc2lvbiB9IGZyb20gXCIuL2h0dHBDbGllbnRcIjtcblxuaW5pdENhcHR1cmUoKTtcbnNldEN5cHJlc3NWZXJzaW9uKGN5cHJlc3NQa2cudmVyc2lvbik7XG5zZXRDdXJyZW50c1ZlcnNpb24ocGtnLnZlcnNpb24pO1xuIiwgImltcG9ydCBcIi4vaW5pdFwiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgcGx1ciBmcm9tIFwicGx1clwiO1xuaW1wb3J0IHsgZ2V0TGVnYWxOb3RpY2UgfSBmcm9tIFwiLi4vbGVnYWxcIjtcbmltcG9ydCB7IEN1cnJlbnRzUnVuUGFyYW1ldGVycyB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlUnVuIH0gZnJvbSBcIi4vYXBpXCI7XG5pbXBvcnQgeyBjdXRJbml0aWFsT3V0cHV0LCBnZXRDYXB0dXJlZE91dHB1dCB9IGZyb20gXCIuL2NhcHR1cmVcIjtcbmltcG9ydCB7IGdldENJIH0gZnJvbSBcIi4vY2lQcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgZ2V0TWVyZ2VkQ29uZmlnLFxuICBpc09mZmxpbmUsXG4gIHByZXByb2Nlc3NQYXJhbXMsXG4gIHZhbGlkYXRlUGFyYW1zLFxufSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IGdldENvdmVyYWdlRmlsZVBhdGggfSBmcm9tIFwiLi9jb3ZlcmFnZVwiO1xuaW1wb3J0IHsgcnVuQmFyZUN5cHJlc3MgfSBmcm9tIFwiLi9jeXByZXNzXCI7XG5pbXBvcnQgeyBhY3RpdmF0ZURlYnVnIH0gZnJvbSBcIi4vZGVidWdcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi9lbnZcIjtcbmltcG9ydCB7IGdldEdpdEluZm8gfSBmcm9tIFwiLi9naXRcIjtcbmltcG9ydCB7IHNldEFQSUJhc2VVcmwsIHNldFJ1bklkIH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuaW1wb3J0IHsgYm9sZCwgZGltLCBkaXZpZGVyLCBpbmZvLCBzcGFjZXIsIHRpdGxlLCB3YXJuLCB5ZWxsb3cgfSBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCB7IGdldFBsYXRmb3JtIH0gZnJvbSBcIi4vcGxhdGZvcm1cIjtcbmltcG9ydCB7IHB1YnN1YiB9IGZyb20gXCIuL3B1YnN1YlwiO1xuaW1wb3J0IHsgc3VtbWFyaXplVGVzdFJlc3VsdHMsIHN1bW1hcnlUYWJsZSB9IGZyb20gXCIuL3Jlc3VsdHNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVJlcG9ydFRhc2tTcGVjLFxuICByZXBvcnRUYXNrcyxcbiAgcnVuVGlsbERvbmVPckNhbmNlbGxlZCxcbn0gZnJvbSBcIi4vcnVubmVyXCI7XG5pbXBvcnQgeyBzaHV0ZG93biB9IGZyb20gXCIuL3NodXRkb3duXCI7XG5pbXBvcnQgeyBnZXRTcGVjRmlsZXMgfSBmcm9tIFwiLi9zcGVjTWF0Y2hlclwiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4vc3RhdGVcIjtcbmltcG9ydCB7IHN0YXJ0V1NTIH0gZnJvbSBcIi4vd3NcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJ1blwiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bihwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycyA9IHt9KSB7XG4gIGNvbnN0IGV4ZWN1dGlvblN0YXRlID0gbmV3IEV4ZWN1dGlvblN0YXRlKCk7XG4gIGNvbnN0IGNvbmZpZ1N0YXRlID0gbmV3IENvbmZpZ1N0YXRlKCk7XG4gIGFjdGl2YXRlRGVidWcocGFyYW1zLmNsb3VkRGVidWcpO1xuICBkZWJ1ZyhcInJ1biBwYXJhbXMgJW9cIiwgcGFyYW1zKTtcbiAgcGFyYW1zID0gcHJlcHJvY2Vzc1BhcmFtcyhwYXJhbXMpO1xuICBkZWJ1ZyhcInBhcmFtcyBhZnRlciBwcmVwcm9jZXNzICVvXCIsIHBhcmFtcyk7XG5cbiAgaWYgKGlzT2ZmbGluZShwYXJhbXMpKSB7XG4gICAgaW5mbyhgU2tpcHBpbmcgY2xvdWQgb3JjaGVzdHJhdGlvbiBiZWNhdXNlIC0tcmVjb3JkIGlzIHNldCB0byBmYWxzZWApO1xuICAgIHJldHVybiBydW5CYXJlQ3lwcmVzcyhwYXJhbXMpO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVkUGFyYW1zID0gYXdhaXQgdmFsaWRhdGVQYXJhbXMocGFyYW1zKTtcbiAgc2V0QVBJQmFzZVVybCh2YWxpZGF0ZWRQYXJhbXMuY2xvdWRTZXJ2aWNlVXJsKTtcblxuICBpZiAoIWlzQ3VycmVudHMoKSkge1xuICAgIGNvbnNvbGUubG9nKGdldExlZ2FsTm90aWNlKCkpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHJlY29yZEtleSxcbiAgICBwcm9qZWN0SWQsXG4gICAgZ3JvdXAsXG4gICAgcGFyYWxsZWwsXG4gICAgY2lCdWlsZElkLFxuICAgIHRhZyxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBiYXRjaFNpemUsXG4gICAgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXMsXG4gICAgZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcsXG4gIH0gPSB2YWxpZGF0ZWRQYXJhbXM7XG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgZ2V0TWVyZ2VkQ29uZmlnKHZhbGlkYXRlZFBhcmFtcyk7XG4gIGNvbmZpZ1N0YXRlLnNldENvbmZpZyhjb25maWc/LnJlc29sdmVkKTtcblxuICBjb25zdCB7IHNwZWNzLCBzcGVjUGF0dGVybiB9ID0gYXdhaXQgZ2V0U3BlY0ZpbGVzKHtcbiAgICBjb25maWcsXG4gICAgcGFyYW1zOiB2YWxpZGF0ZWRQYXJhbXMsXG4gIH0pO1xuXG4gIGlmIChzcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwbGF0Zm9ybSA9IGF3YWl0IGdldFBsYXRmb3JtKHtcbiAgICBjb25maWcsXG4gICAgYnJvd3NlcjogdmFsaWRhdGVkUGFyYW1zLmJyb3dzZXIsXG4gIH0pO1xuXG4gIGluZm8oXCJEaXNjb3ZlcmVkICVkIHNwZWMgZmlsZXNcIiwgc3BlY3MubGVuZ3RoKTtcbiAgaW5mbyhcbiAgICBgVGFnczogJHt0YWcubGVuZ3RoID4gMCA/IHRhZy5qb2luKFwiLFwiKSA6IGZhbHNlfTsgR3JvdXA6ICR7XG4gICAgICBncm91cCA/PyBmYWxzZVxuICAgIH07IFBhcmFsbGVsOiAke3BhcmFsbGVsID8/IGZhbHNlfTsgQmF0Y2ggU2l6ZTogJHtiYXRjaFNpemV9YFxuICApO1xuICBpbmZvKFwiQ29ubmVjdGluZyB0byBjbG91ZCBvcmNoZXN0cmF0aW9uIHNlcnZpY2UuLi5cIik7XG5cbiAgY29uc3QgcnVuID0gYXdhaXQgY3JlYXRlUnVuKHtcbiAgICBjaTogZ2V0Q0koY2lCdWlsZElkKSxcbiAgICBzcGVjczogc3BlY3MubWFwKChzcGVjKSA9PiBzcGVjLnJlbGF0aXZlKSxcbiAgICBjb21taXQ6IGF3YWl0IGdldEdpdEluZm8oY29uZmlnLnByb2plY3RSb290KSxcbiAgICBncm91cCxcbiAgICBwbGF0Zm9ybSxcbiAgICBwYXJhbGxlbDogcGFyYWxsZWwgPz8gZmFsc2UsXG4gICAgY2lCdWlsZElkLFxuICAgIHByb2plY3RJZCxcbiAgICByZWNvcmRLZXksXG4gICAgc3BlY1BhdHRlcm46IFtzcGVjUGF0dGVybl0uZmxhdCgyKSxcbiAgICB0YWdzOiB0YWcsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgYmF0Y2hTaXplLFxuICAgIGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzLFxuICAgIGNvdmVyYWdlRW5hYmxlZDogZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcsXG4gIH0pO1xuXG4gIHNldFJ1bklkKHJ1bi5ydW5JZCk7XG4gIGluZm8oXCJcdUQ4M0NcdURGQTUgUnVuIFVSTDpcIiwgYm9sZChydW4ucnVuVXJsKSk7XG4gIGN1dEluaXRpYWxPdXRwdXQoKTtcblxuICBhd2FpdCBzdGFydFdTUygpO1xuICBsaXN0ZW5Ub1NwZWNFdmVudHMoXG4gICAgY29uZmlnU3RhdGUsXG4gICAgZXhlY3V0aW9uU3RhdGUsXG4gICAgY29uZmlnLmV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nXG4gICk7XG5cbiAgYXdhaXQgcnVuVGlsbERvbmVPckNhbmNlbGxlZChcbiAgICBleGVjdXRpb25TdGF0ZSxcbiAgICBjb25maWdTdGF0ZSxcbiAgICB7XG4gICAgICBydW5JZDogcnVuLnJ1bklkLFxuICAgICAgZ3JvdXBJZDogcnVuLmdyb3VwSWQsXG4gICAgICBtYWNoaW5lSWQ6IHJ1bi5tYWNoaW5lSWQsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNwZWNzLFxuICAgIH0sXG4gICAgdmFsaWRhdGVkUGFyYW1zXG4gICk7XG5cbiAgZGl2aWRlcigpO1xuXG4gIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChyZXBvcnRUYXNrcyk7XG4gIGNvbnN0IF9zdW1tYXJ5ID0gc3VtbWFyaXplVGVzdFJlc3VsdHMoXG4gICAgZXhlY3V0aW9uU3RhdGUuZ2V0UmVzdWx0cyhjb25maWdTdGF0ZSksXG4gICAgY29uZmlnXG4gICk7XG5cbiAgdGl0bGUoXCJ3aGl0ZVwiLCBcIkNsb3VkIFJ1biBGaW5pc2hlZFwiKTtcbiAgY29uc29sZS5sb2coc3VtbWFyeVRhYmxlKF9zdW1tYXJ5KSk7XG5cbiAgcHJpbnRXYXJuaW5ncyhleGVjdXRpb25TdGF0ZSk7XG5cbiAgaW5mbyhcIlxcblx1RDgzQ1x1REZDMSBSZWNvcmRlZCBSdW46XCIsIGJvbGQocnVuLnJ1blVybCkpO1xuXG4gIGF3YWl0IHNodXRkb3duKCk7XG5cbiAgc3BhY2VyKCk7XG4gIGlmIChfc3VtbWFyeS5zdGF0dXMgPT09IFwiZmluaXNoZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5fc3VtbWFyeSxcbiAgICAgIHJ1blVybDogcnVuLnJ1blVybCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9zdW1tYXJ5O1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5Ub1NwZWNFdmVudHMoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZz86IGJvb2xlYW5cbikge1xuICBjb25zdCBjb25maWcgPSBjb25maWdTdGF0ZS5nZXRDb25maWcoKTtcbiAgcHVic3ViLm9uKFwiYmVmb3JlOnNwZWNcIiwgYXN5bmMgKHsgc3BlYyB9OiB7IHNwZWM6IEN5cHJlc3MuU3BlYyB9KSA9PiB7XG4gICAgZGVidWcoXCJiZWZvcmU6c3BlYyAlb1wiLCBzcGVjKTtcbiAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQmVmb3JlKHNwZWMucmVsYXRpdmUpO1xuICB9KTtcblxuICBwdWJzdWIub24oXG4gICAgXCJhZnRlcjpzcGVjXCIsXG4gICAgYXN5bmMgKHsgc3BlYywgcmVzdWx0cyB9OiB7IHNwZWM6IEN5cHJlc3MuU3BlYzsgcmVzdWx0czogYW55IH0pID0+IHtcbiAgICAgIGRlYnVnKFwiYWZ0ZXI6c3BlYyAlbyAlb1wiLCBzcGVjLCByZXN1bHRzKTtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNBZnRlcihzcGVjLnJlbGF0aXZlLCByZXN1bHRzKTtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNPdXRwdXQoc3BlYy5yZWxhdGl2ZSwgZ2V0Q2FwdHVyZWRPdXRwdXQoKSk7XG5cbiAgICAgIGlmIChleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZykge1xuICAgICAgICBjb25zdCB7IHBhdGgsIGVycm9yIH0gPSBhd2FpdCBnZXRDb3ZlcmFnZUZpbGVQYXRoKFxuICAgICAgICAgIGNvbmZpZz8uZW52Py5jb3ZlcmFnZUZpbGVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNDb3ZlcmFnZShzcGVjLnJlbGF0aXZlLCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgICAgYENvdWxkIG5vdCBwcm9jZXNzIGNvdmVyYWdlIGZpbGUgXCIke3BhdGh9XCJcXG4ke2RpbShlcnJvcil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNyZWF0ZVJlcG9ydFRhc2tTcGVjKGNvbmZpZ1N0YXRlLCBleGVjdXRpb25TdGF0ZSwgc3BlYy5yZWxhdGl2ZSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmdzKGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSkge1xuICBjb25zdCB3YXJuaW5ncyA9IEFycmF5LmZyb20oZXhlY3V0aW9uU3RhdGUuZ2V0V2FybmluZ3MoKSk7XG4gIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgd2FybihcbiAgICAgIGAke3dhcm5pbmdzLmxlbmd0aH0gJHtwbHVyKFxuICAgICAgICBcIldhcm5pbmdcIixcbiAgICAgICAgd2FybmluZ3MubGVuZ3RoXG4gICAgICApfSBlbmNvdW50ZXJlZCBkdXJpbmcgdGhlIGV4ZWN1dGlvbjpcXG4ke3dhcm5pbmdzXG4gICAgICAgIC5tYXAoKHcsIGkpID0+IGBcXG4ke3llbGxvdyhgWyR7aSArIDF9LyR7d2FybmluZ3MubGVuZ3RofV1gKX0gJHt3fWApXG4gICAgICAgIC5qb2luKFwiXFxuXCIpfWBcbiAgICApO1xuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldExlZ2FsTm90aWNlKCkge1xuICByZXR1cm4gYFxuQ29weXJpZ2h0IChDKSAke25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX0gQ3VycmVudHMgU29mdHdhcmUgSW5jIGh0dHBzOi8vY3VycmVudHMuZGV2XG5UaGlzIGlzIGZyZWUgc29mdHdhcmUsIGFuZCB5b3UgYXJlIHdlbGNvbWUgdG8gcmVkaXN0cmlidXRlIGl0IHVuZGVyIGNlcnRhaW5cbmNvbmRpdGlvbnMuIFRoaXMgcHJvZ3JhbSBjb21lcyB3aXRoIG5vIHdhcnJhbnR5LiBQYXJ0cyBvZiB0aGlzIHByb2dyYW0gYXJlIE1JVFxubGljZW5zZWQuIFJlZmVyIHRvIHRoZSBsaWNlbnNlIGZvciBkZXRhaWxzXG5odHRwczovL2dpdGh1Yi5jb20vY3VycmVudHMtZGV2L2N5cHJlc3MtY2xvdWQvYmxvYi9tYWluL0xJQ0VOU0UubWRcbmA7XG59XG4iLCAiaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgbWFnZW50YSB9IGZyb20gXCIuLi9sb2dcIjtcblxuaW1wb3J0IHsgaW5mbywgc3BhY2VyLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgQ2xvdWRXYXJuaW5nIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50V2FybmluZ3Mod2FybmluZ3M6IENsb3VkV2FybmluZ1tdKSB7XG4gIHdhcm4oXCJOb3RpY2UgZnJvbSBjbG91ZCBzZXJ2aWNlOlwiKTtcbiAgd2FybmluZ3MubWFwKCh3KSA9PiB7XG4gICAgc3BhY2VyKDEpO1xuICAgIGluZm8obWFnZW50YS5ib2xkKHcubWVzc2FnZSkpO1xuICAgIE9iamVjdC5lbnRyaWVzKF8ub21pdCh3LCBcIm1lc3NhZ2VcIikpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpbmZvKFwiLSAlczogJXNcIiwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgc3BhY2VyKDEpO1xuICB9KTtcbn1cbiIsICJpbXBvcnQgeyBtYWtlUmVxdWVzdCB9IGZyb20gXCIuLi9odHRwQ2xpZW50XCI7XG5pbXBvcnQge1xuICBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCxcbiAgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkLFxuICBDcmVhdGVJbnN0YW5jZVJlc3BvbnNlLFxuICBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSxcbiAgQ3JlYXRlUnVuUGF5bG9hZCxcbiAgQ3JlYXRlUnVuUmVzcG9uc2UsXG4gIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IHByaW50V2FybmluZ3MgfSBmcm9tIFwiLi93YXJuaW5nc1wiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUnVuID0gYXN5bmMgKHBheWxvYWQ6IENyZWF0ZVJ1blBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdDxDcmVhdGVSdW5SZXNwb25zZSwgQ3JlYXRlUnVuUGF5bG9hZD4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ydW5zXCIsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSk7XG5cbiAgaWYgKChyZXNwb25zZS5kYXRhLndhcm5pbmdzPy5sZW5ndGggPz8gMCkgPiAwKSB7XG4gICAgcHJpbnRXYXJuaW5ncyhyZXNwb25zZS5kYXRhLndhcm5pbmdzKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlID0gYXN5bmMgKHtcbiAgcnVuSWQsXG4gIGdyb3VwSWQsXG4gIG1hY2hpbmVJZCxcbiAgcGxhdGZvcm0sXG59OiBDcmVhdGVJbnN0YW5jZVBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdDxcbiAgICBDcmVhdGVJbnN0YW5jZVJlc3BvbnNlLFxuICAgIENyZWF0ZUluc3RhbmNlUGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYHJ1bnMvJHtydW5JZH0vaW5zdGFuY2VzYCxcbiAgICBkYXRhOiB7XG4gICAgICBydW5JZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBtYWNoaW5lSWQsXG4gICAgICBwbGF0Zm9ybSxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVCYXRjaGVkSW5zdGFuY2VzID0gYXN5bmMgKGRhdGE6IENyZWF0ZUluc3RhbmNlQ3lQYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbmUgPSBhd2FpdCBtYWtlUmVxdWVzdDxcbiAgICBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSxcbiAgICBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYHJ1bnMvJHtkYXRhLnJ1bklkfS9jeS9pbnN0YW5jZXNgLFxuICAgIGRhdGEsXG4gIH0pO1xuXG4gIHJldHVybiByZXNwb25lLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0SW5zdGFuY2VUZXN0cyA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDx7fSwgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQ+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3Rlc3RzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUluc3RhbmNlUmVzdWx0cyA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLCBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9yZXN1bHRzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZCA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PFxuICAgIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLFxuICAgIFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9jeS9yZXN1bHRzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUluc3RhbmNlU3Rkb3V0ID0gKGluc3RhbmNlSWQ6IHN0cmluZywgc3Rkb3V0OiBzdHJpbmcpID0+XG4gIG1ha2VSZXF1ZXN0PGFueSwgeyBzdGRvdXQ6IHN0cmluZyB9Pih7XG4gICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3N0ZG91dGAsXG4gICAgZGF0YToge1xuICAgICAgc3Rkb3V0LFxuICAgIH0sXG4gIH0pO1xuIiwgIi8qISBAcHJlc2VydmVcblxuIyMjIE1JVFxuXG5QYXJ0cyBvZiB0aGlzIGNvZGUgd2FzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MgYW5kIGlzIHN1YmplY3QgdG8gTUlUIGxpY2Vuc2UuXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAyMiBDeXByZXNzLmlvXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBkZWJ1Z0ZuIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBHaGFFdmVudERhdGEgfSBmcm9tIFwiLi4vZ2l0XCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGbihcImN1cnJlbnRzOmNpXCIpO1xuXG5jb25zdCBqb2luID0gKGNoYXI6IHN0cmluZywgLi4ucGllY2VzOiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdKSA9PiB7XG4gIHJldHVybiBfLmNoYWluKHBpZWNlcykuY29tcGFjdCgpLmpvaW4oY2hhcikudmFsdWUoKTtcbn07XG5cbmNvbnN0IHRvQ2FtZWxPYmplY3QgPSAob2JqOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBfLnNldChvYmosIF8uY2FtZWxDYXNlKGtleSksIHByb2Nlc3MuZW52W2tleV0pO1xufTtcblxuY29uc3QgZXh0cmFjdCA9IChlbnZLZXlzOiBzdHJpbmdbXSkgPT4ge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZW52S2V5cywgdG9DYW1lbE9iamVjdCwge30pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBUZWFtRm91bmRhdGlvbiBzZXJ2ZXIuXG4gKiBAc2VlIGh0dHBzOi8vdGVjaG5ldC5taWNyb3NvZnQuY29tL2VuLXVzL2hoODUwNDQ4KHY9dnMuOTIpXG4gKi9cbmNvbnN0IGlzVGVhbUZvdW5kYXRpb24gPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5URl9CVUlMRCAmJiBwcm9jZXNzLmVudi5URl9CVUlMRF9CVUlMRE5VTUJFUjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgb24gQXp1cmUgQ0kgcGlwZWxpbmUuXG4gKiBTZWUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIHRoZSBpc3N1ZSAjMzY1N1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2lzc3Vlcy8zNjU3XG4gKi9cbmNvbnN0IGlzQXp1cmVDaSA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LlRGX0JVSUxEICYmIHByb2Nlc3MuZW52LkFaVVJFX0hUVFBfVVNFUl9BR0VOVDtcbn07XG5cbmNvbnN0IGlzQVdTQ29kZUJ1aWxkID0gKCkgPT4ge1xuICByZXR1cm4gXy5zb21lKHByb2Nlc3MuZW52LCAodmFsLCBrZXkpID0+IHtcbiAgICByZXR1cm4gL15DT0RFQlVJTERfLy50ZXN0KGtleSk7XG4gIH0pO1xufTtcblxuY29uc3QgaXNCYW1ib28gPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5iYW1ib29fYnVpbGROdW1iZXI7XG59O1xuXG5jb25zdCBpc0NvZGVzaGlwQmFzaWMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSAmJlxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgPT09IFwiY29kZXNoaXBcIiAmJlxuICAgIHByb2Nlc3MuZW52LkNPREVTSElQXG4gICk7XG59O1xuXG5jb25zdCBpc0NvZGVzaGlwUHJvID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgJiZcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FID09PSBcImNvZGVzaGlwXCIgJiZcbiAgICAhcHJvY2Vzcy5lbnYuQ09ERVNISVBcbiAgKTtcbn07XG5cbmNvbnN0IGlzQ29uY291cnNlID0gKCkgPT4ge1xuICByZXR1cm4gXy5zb21lKHByb2Nlc3MuZW52LCAodmFsLCBrZXkpID0+IHtcbiAgICByZXR1cm4gL15DT05DT1VSU0VfLy50ZXN0KGtleSk7XG4gIH0pO1xufTtcblxuY29uc3QgaXNHaXRsYWIgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuR0lUTEFCX0NJIHx8XG4gICAgKHByb2Nlc3MuZW52LkNJX1NFUlZFUl9OQU1FICYmIC9eR2l0TGFiLy50ZXN0KHByb2Nlc3MuZW52LkNJX1NFUlZFUl9OQU1FKSlcbiAgKTtcbn07XG5cbmNvbnN0IGlzR29vZ2xlQ2xvdWQgPSAoKSA9PiB7XG4gIC8vIHNldCBhdXRvbWF0aWNhbGx5IGZvciB0aGUgTm9kZS5qcyA2LCBOb2RlLmpzIDggcnVudGltZXMgKG5vdCBpbiBOb2RlIDEwKVxuICAvLyBUT0RPOiBtYXkgYWxzbyBwb3RlbnRpYWxseSBoYXZlIFhfR09PR0xFXyogZW52IHZhciBzZXRcbiAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIjZW52aXJvbm1lbnRfdmFyaWFibGVzX3NldF9hdXRvbWF0aWNhbGx5XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuR0NQX1BST0pFQ1QgfHxcbiAgICBwcm9jZXNzLmVudi5HQ0xPVURfUFJPSkVDVCB8fFxuICAgIHByb2Nlc3MuZW52LkdPT0dMRV9DTE9VRF9QUk9KRUNUXG4gICk7XG59O1xuXG5jb25zdCBpc0plbmtpbnMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuSkVOS0lOU19VUkwgfHxcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX0hPTUUgfHxcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX1ZFUlNJT04gfHxcbiAgICBwcm9jZXNzLmVudi5IVURTT05fVVJMIHx8XG4gICAgcHJvY2Vzcy5lbnYuSFVEU09OX0hPTUVcbiAgKTtcbn07XG5cbmNvbnN0IGlzV2VyY2tlciA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LldFUkNLRVIgfHwgcHJvY2Vzcy5lbnYuV0VSQ0tFUl9NQUlOX1BJUEVMSU5FX1NUQVJURUQ7XG59O1xuXG4vKipcbiAqIFdlIGRldGVjdCBDSSBwcm92aWRlcnMgYnkgZGV0ZWN0aW5nIGFuIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiB1bmlxdWUgdG8gdGhlIHByb3ZpZGVyLCBvciBieSBjYWxsaW5nIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWVcbiAqIGZvciB0aGF0IHByb3ZpZGVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBBcHBWZXlvciBDSSBoYXMgZW52aXJvbm1lbnQgdGhlXG4gKiB2YXJpYWJsZSBcIkFQUFZFWU9SXCIgc2V0IGR1cmluZyBydW5cbiAqL1xuY29uc3QgQ0lfUFJPVklERVJTID0ge1xuICBhcHB2ZXlvcjogXCJBUFBWRVlPUlwiLFxuICBhenVyZTogaXNBenVyZUNpLFxuICBhd3NDb2RlQnVpbGQ6IGlzQVdTQ29kZUJ1aWxkLFxuICBiYW1ib286IGlzQmFtYm9vLFxuICBiaXRidWNrZXQ6IFwiQklUQlVDS0VUX0JVSUxEX05VTUJFUlwiLFxuICBidWlsZGtpdGU6IFwiQlVJTERLSVRFXCIsXG4gIGNpcmNsZTogXCJDSVJDTEVDSVwiLFxuICBjb2Rlc2hpcEJhc2ljOiBpc0NvZGVzaGlwQmFzaWMsXG4gIGNvZGVzaGlwUHJvOiBpc0NvZGVzaGlwUHJvLFxuICBjb25jb3Vyc2U6IGlzQ29uY291cnNlLFxuICBjb2RlRnJlc2g6IFwiQ0ZfQlVJTERfSURcIixcbiAgZHJvbmU6IFwiRFJPTkVcIixcbiAgZ2l0aHViQWN0aW9uczogXCJHSVRIVUJfQUNUSU9OU1wiLFxuICBnaXRsYWI6IGlzR2l0bGFiLFxuICBnb0NEOiBcIkdPX0pPQl9OQU1FXCIsXG4gIGdvb2dsZUNsb3VkOiBpc0dvb2dsZUNsb3VkLFxuICBqZW5raW5zOiBpc0plbmtpbnMsXG4gIHNlbWFwaG9yZTogXCJTRU1BUEhPUkVcIixcbiAgc2hpcHBhYmxlOiBcIlNISVBQQUJMRVwiLFxuICB0ZWFtY2l0eTogXCJURUFNQ0lUWV9WRVJTSU9OXCIsXG4gIHRlYW1mb3VuZGF0aW9uOiBpc1RlYW1Gb3VuZGF0aW9uLFxuICB0cmF2aXM6IFwiVFJBVklTXCIsXG4gIHdlcmNrZXI6IGlzV2VyY2tlcixcbiAgbmV0bGlmeTogXCJORVRMSUZZXCIsXG4gIGxheWVyY2k6IFwiTEFZRVJDSVwiLFxufTtcblxuZnVuY3Rpb24gX2RldGVjdFByb3ZpZGVyTmFtZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCB7IGVudiB9ID0gcHJvY2VzcztcbiAgLy8gcmV0dXJuIHRoZSBrZXkgb2YgdGhlIGZpcnN0IHByb3ZpZGVyXG4gIC8vIHdoaWNoIGlzIHRydXRoeVxuXG4gIHJldHVybiBfLmZpbmRLZXkoQ0lfUFJPVklERVJTLCAodmFsdWUpID0+IHtcbiAgICBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBlbnZbdmFsdWVdO1xuICAgIH1cblxuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBkb24ndCBmb3IgYWJvdXQgYnVpbGROdW1iZXIhXG4vLyBsb29rIGF0IHRoZSBvbGQgY29tbWl0IHRoYXQgd2FzIHJlbW92ZWQgdG8gc2VlIGhvdyB3ZSBkaWQgaXRcbmNvbnN0IF9wcm92aWRlckNpUGFyYW1zID0gKCk6IFByb3ZpZGVyQ2lQYXJhbXNSZXMgPT4ge1xuICByZXR1cm4ge1xuICAgIGFwcHZleW9yOiBleHRyYWN0KFtcbiAgICAgIFwiQVBQVkVZT1JfSk9CX0lEXCIsXG4gICAgICBcIkFQUFZFWU9SX0FDQ09VTlRfTkFNRVwiLFxuICAgICAgXCJBUFBWRVlPUl9QUk9KRUNUX1NMVUdcIixcbiAgICAgIFwiQVBQVkVZT1JfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkFQUFZFWU9SX0JVSUxEX1ZFUlNJT05cIixcbiAgICAgIFwiQVBQVkVZT1JfUFVMTF9SRVFVRVNUX05VTUJFUlwiLFxuICAgICAgXCJBUFBWRVlPUl9QVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSFwiLFxuICAgIF0pLFxuICAgIGF6dXJlOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfQlVJTERJRFwiLFxuICAgICAgXCJCVUlMRF9CVUlMRE5VTUJFUlwiLFxuICAgICAgXCJCVUlMRF9DT05UQUlORVJJRFwiLFxuICAgICAgXCJCVUlMRF9SRVBPU0lUT1JZX1VSSVwiLFxuICAgIF0pLFxuICAgIGF3c0NvZGVCdWlsZDogZXh0cmFjdChbXG4gICAgICBcIkNPREVCVUlMRF9CVUlMRF9JRFwiLFxuICAgICAgXCJDT0RFQlVJTERfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkNPREVCVUlMRF9SRVNPTFZFRF9TT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgXCJDT0RFQlVJTERfU09VUkNFX1JFUE9fVVJMXCIsXG4gICAgICBcIkNPREVCVUlMRF9TT1VSQ0VfVkVSU0lPTlwiLFxuICAgIF0pLFxuICAgIGJhbWJvbzogZXh0cmFjdChbXG4gICAgICBcImJhbWJvb19idWlsZE51bWJlclwiLFxuICAgICAgXCJiYW1ib29fYnVpbGRSZXN1bHRzVXJsXCIsXG4gICAgICBcImJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXBvc2l0b3J5VXJsXCIsXG4gICAgICBcImJhbWJvb19idWlsZEtleVwiLFxuICAgIF0pLFxuICAgIGJpdGJ1Y2tldDogZXh0cmFjdChbXG4gICAgICBcIkJJVEJVQ0tFVF9SRVBPX1NMVUdcIixcbiAgICAgIFwiQklUQlVDS0VUX1JFUE9fT1dORVJcIixcbiAgICAgIFwiQklUQlVDS0VUX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJCSVRCVUNLRVRfUEFSQUxMRUxfU1RFUFwiLFxuICAgICAgXCJCSVRCVUNLRVRfU1RFUF9SVU5fTlVNQkVSXCIsXG4gICAgICAvLyB0aGUgUFIgdmFyaWFibGVzIGFyZSBvbmx5IHNldCBvbiBwdWxsIHJlcXVlc3QgYnVpbGRzXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9JRFwiLFxuICAgICAgXCJCSVRCVUNLRVRfUFJfREVTVElOQVRJT05fQlJBTkNIXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9ERVNUSU5BVElPTl9DT01NSVRcIixcbiAgICBdKSxcbiAgICBidWlsZGtpdGU6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMREtJVEVfUkVQT1wiLFxuICAgICAgXCJCVUlMREtJVEVfU09VUkNFXCIsXG4gICAgICBcIkJVSUxES0lURV9KT0JfSURcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX0lEXCIsXG4gICAgICBcIkJVSUxES0lURV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RfUkVQT1wiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUX0JBU0VfQlJBTkNIXCIsXG4gICAgXSksXG4gICAgY2lyY2xlOiBleHRyYWN0KFtcbiAgICAgIFwiQ0lSQ0xFX0pPQlwiLFxuICAgICAgXCJDSVJDTEVfQlVJTERfTlVNXCIsXG4gICAgICBcIkNJUkNMRV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX05VTUJFUlwiLFxuICAgICAgXCJDSVJDTEVfUFJfUkVQT05BTUVcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX1VTRVJOQU1FXCIsXG4gICAgICBcIkNJUkNMRV9DT01QQVJFX1VSTFwiLFxuICAgICAgXCJDSVJDTEVfV09SS0ZMT1dfSURcIixcbiAgICAgIFwiQ0lSQ0xFX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJDSVJDTEVfUkVQT1NJVE9SWV9VUkxcIixcbiAgICAgIFwiQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgY29kZXNoaXBCYXNpYzogZXh0cmFjdChbXG4gICAgICBcIkNJX0JVSUxEX0lEXCIsXG4gICAgICBcIkNJX1JFUE9fTkFNRVwiLFxuICAgICAgXCJDSV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0lfUFJPSkVDVF9JRFwiLFxuICAgICAgXCJDSV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgLy8gQ29kZXNoaXBQcm8gcHJvdmlkZXMgdmVyeSBmZXcgQ0kgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9kb2N1bWVudGF0aW9uLmNvZGVzaGlwLmNvbS9wcm8vYnVpbGRzLWFuZC1jb25maWd1cmF0aW9uL2Vudmlyb25tZW50LXZhcmlhYmxlcy9cbiAgICBjb2Rlc2hpcFBybzogZXh0cmFjdChbXCJDSV9CVUlMRF9JRFwiLCBcIkNJX1JFUE9fTkFNRVwiLCBcIkNJX1BST0pFQ1RfSURcIl0pLFxuICAgIC8vIGh0dHBzOi8vY29uY291cnNlLWNpLm9yZy9pbXBsZW1lbnRpbmctcmVzb3VyY2UtdHlwZXMuaHRtbCNyZXNvdXJjZS1tZXRhZGF0YVxuICAgIGNvbmNvdXJzZTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0lEXCIsXG4gICAgICBcIkJVSUxEX05BTUVcIixcbiAgICAgIFwiQlVJTERfSk9CX05BTUVcIixcbiAgICAgIFwiQlVJTERfUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9URUFNX05BTUVcIixcbiAgICAgIFwiQVRDX0VYVEVSTkFMX1VSTFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vY29kZWZyZXNoLmlvL2RvY3MvZG9jcy9jb2RlZnJlc2gteWFtbC92YXJpYWJsZXMvXG4gICAgY29kZUZyZXNoOiBleHRyYWN0KFtcbiAgICAgIFwiQ0ZfQlVJTERfSURcIixcbiAgICAgIFwiQ0ZfQlVJTERfVVJMXCIsXG4gICAgICBcIkNGX0NVUlJFTlRfQVRURU1QVFwiLFxuICAgICAgXCJDRl9TVEVQX05BTUVcIixcbiAgICAgIFwiQ0ZfUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJDRl9QSVBFTElORV9UUklHR0VSX0lEXCIsXG4gICAgICAvLyB2YXJpYWJsZXMgYWRkZWQgZm9yIHB1bGwgcmVxdWVzdHNcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX0lEXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9JU19GT1JLXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9OVU1CRVJcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX1RBUkdFVFwiLFxuICAgIF0pLFxuICAgIGRyb25lOiBleHRyYWN0KFtcbiAgICAgIFwiRFJPTkVfSk9CX05VTUJFUlwiLFxuICAgICAgXCJEUk9ORV9CVUlMRF9MSU5LXCIsXG4gICAgICBcIkRST05FX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJEUk9ORV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICAvLyBodHRwczovL2hlbHAuZ2l0aHViLmNvbS9lbi9hY3Rpb25zL2F1dG9tYXRpbmcteW91ci13b3JrZmxvdy13aXRoLWdpdGh1Yi1hY3Rpb25zL3VzaW5nLWVudmlyb25tZW50LXZhcmlhYmxlcyNkZWZhdWx0LWVudmlyb25tZW50LXZhcmlhYmxlc1xuICAgIGdpdGh1YkFjdGlvbnM6IGV4dHJhY3QoW1xuICAgICAgXCJHSVRIVUJfV09SS0ZMT1dcIixcbiAgICAgIFwiR0lUSFVCX0FDVElPTlwiLFxuICAgICAgXCJHSVRIVUJfRVZFTlRfTkFNRVwiLFxuICAgICAgXCJHSVRIVUJfUlVOX0lEXCIsXG4gICAgICBcIkdJVEhVQl9SVU5fQVRURU1QVFwiLFxuICAgICAgXCJHSVRIVUJfUkVQT1NJVE9SWVwiLFxuICAgIF0pLFxuICAgIC8vIHNlZSBodHRwczovL2RvY3MuZ2l0bGFiLmNvbS9lZS9jaS92YXJpYWJsZXMvXG4gICAgZ2l0bGFiOiBleHRyYWN0KFtcbiAgICAgIC8vIHBpcGVsaW5lIGlzIGNvbW1vbiBhbW9uZyBhbGwgam9ic1xuICAgICAgXCJDSV9QSVBFTElORV9JRFwiLFxuICAgICAgXCJDSV9QSVBFTElORV9VUkxcIixcbiAgICAgIC8vIGluZGl2aWR1YWwgam9ic1xuICAgICAgXCJDSV9CVUlMRF9JRFwiLCAvLyBidWlsZCBpZCBhbmQgam9iIGlkIGFyZSBhbGlhc2VzXG4gICAgICBcIkNJX0pPQl9JRFwiLFxuICAgICAgXCJDSV9KT0JfVVJMXCIsXG4gICAgICBcIkNJX0pPQl9OQU1FXCIsXG4gICAgICAvLyBvdGhlciBpbmZvcm1hdGlvblxuICAgICAgXCJHSVRMQUJfSE9TVFwiLFxuICAgICAgXCJDSV9QUk9KRUNUX0lEXCIsXG4gICAgICBcIkNJX1BST0pFQ1RfVVJMXCIsXG4gICAgICBcIkNJX1JFUE9TSVRPUllfVVJMXCIsXG4gICAgICBcIkNJX0VOVklST05NRU5UX1VSTFwiLFxuICAgICAgXCJDSV9ERUZBVUxUX0JSQU5DSFwiLFxuICAgICAgLy8gZm9yIFBSczogaHR0cHM6Ly9naXRsYWIuY29tL2dpdGxhYi1vcmcvZ2l0bGFiLWNlL2lzc3Vlcy8yMzkwMlxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vZG9jcy5nb2NkLm9yZy9jdXJyZW50L2ZhcS9kZXZfdXNlX2N1cnJlbnRfcmV2aXNpb25faW5fYnVpbGQuaHRtbCNzdGFuZGFyZC1nb2NkLWVudmlyb25tZW50LXZhcmlhYmxlc1xuICAgIGdvQ0Q6IGV4dHJhY3QoW1xuICAgICAgXCJHT19TRVJWRVJfVVJMXCIsXG4gICAgICBcIkdPX0VOVklST05NRU5UX05BTUVcIixcbiAgICAgIFwiR09fUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJHT19QSVBFTElORV9DT1VOVEVSXCIsXG4gICAgICBcIkdPX1BJUEVMSU5FX0xBQkVMXCIsXG4gICAgICBcIkdPX1NUQUdFX05BTUVcIixcbiAgICAgIFwiR09fU1RBR0VfQ09VTlRFUlwiLFxuICAgICAgXCJHT19KT0JfTkFNRVwiLFxuICAgICAgXCJHT19UUklHR0VSX1VTRVJcIixcbiAgICAgIFwiR09fUkVWSVNJT05cIixcbiAgICAgIFwiR09fVE9fUkVWSVNJT05cIixcbiAgICAgIFwiR09fRlJPTV9SRVZJU0lPTlwiLFxuICAgICAgXCJHT19NQVRFUklBTF9IQVNfQ0hBTkdFRFwiLFxuICAgIF0pLFxuICAgIGdvb2dsZUNsb3VkOiBleHRyYWN0KFtcbiAgICAgIC8vIGluZGl2aWR1YWwgam9ic1xuICAgICAgXCJCVUlMRF9JRFwiLFxuICAgICAgXCJQUk9KRUNUX0lEXCIsXG4gICAgICAvLyBvdGhlciBpbmZvcm1hdGlvblxuICAgICAgXCJSRVBPX05BTUVcIixcbiAgICAgIFwiQlJBTkNIX05BTUVcIixcbiAgICAgIFwiVEFHX05BTUVcIixcbiAgICAgIFwiQ09NTUlUX1NIQVwiLFxuICAgICAgXCJTSE9SVF9TSEFcIixcbiAgICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jbG91ZC1idWlsZC9kb2NzL2FwaS9yZWZlcmVuY2UvcmVzdC9TaGFyZWQuVHlwZXMvQnVpbGRcbiAgICBdKSxcbiAgICBqZW5raW5zOiBleHRyYWN0KFtcIkJVSUxEX0lEXCIsIFwiQlVJTERfVVJMXCIsIFwiQlVJTERfTlVNQkVSXCIsIFwiZ2hwcmJQdWxsSWRcIl0pLFxuICAgIC8vIGh0dHBzOi8vc2VtYXBob3JlY2kuY29tL2RvY3MvYXZhaWxhYmxlLWVudmlyb25tZW50LXZhcmlhYmxlcy5odG1sXG4gICAgLy8gc29tZSBjb21lIGZyb20gdjEsIHNvbWUgZnJvbSB2MiBvZiBzZW1hcGhvcmVcbiAgICBzZW1hcGhvcmU6IGV4dHJhY3QoW1xuICAgICAgXCJTRU1BUEhPUkVfQlJBTkNIX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX0NVUlJFTlRfSk9CXCIsXG4gICAgICBcIlNFTUFQSE9SRV9DVVJSRU5UX1RIUkVBRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfRVhFQ1VUQUJMRV9VVUlEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfQlJBTkNIXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfRElSXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVGXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVGX1RZUEVcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRVBPX1NMVUdcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9VUkxcIixcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9DT1VOVFwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX0lEXCIsIC8vIHYyXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfTkFNRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX1VVSURcIiwgLy8gdjFcbiAgICAgIFwiU0VNQVBIT1JFX1BJUEVMSU5FX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QTEFURk9STVwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9ESVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfSEFTSF9JRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9JRFwiLCAvLyB2MlxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9OQU1FXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX1VVSURcIiwgLy8gdjFcbiAgICAgIFwiU0VNQVBIT1JFX1JFUE9fU0xVR1wiLFxuICAgICAgXCJTRU1BUEhPUkVfVFJJR0dFUl9TT1VSQ0VcIixcbiAgICAgIFwiU0VNQVBIT1JFX1dPUktGTE9XX0lEXCIsXG4gICAgICBcIlBVTExfUkVRVUVTVF9OVU1CRVJcIiwgLy8gcHVsbCByZXF1ZXN0cyBmcm9tIGZvcmtzIE9OTFlcbiAgICBdKSxcbiAgICAvLyBzZWUgaHR0cDovL2RvY3Muc2hpcHBhYmxlLmNvbS9jaS9lbnYtdmFycy9cbiAgICBzaGlwcGFibGU6IGV4dHJhY3QoW1xuICAgICAgLy8gYnVpbGQgdmFyaWFibGVzXG4gICAgICBcIlNISVBQQUJMRV9CVUlMRF9JRFwiLCAvLyBcIjViOTMzNTRjYWJmYWJiMDcwMDdmMDFmZFwiXG4gICAgICBcIlNISVBQQUJMRV9CVUlMRF9OVU1CRVJcIiwgLy8gXCI0XCJcbiAgICAgIFwiU0hJUFBBQkxFX0NPTU1JVF9SQU5HRVwiLCAvLyBcInNoYTEuLi5zaGEyXCJcbiAgICAgIFwiU0hJUFBBQkxFX0NPTlRBSU5FUl9OQU1FXCIsIC8vIFwiYy5leGVjLmN5cHJlc3MtZXhhbXBsZS1raXRjaGVuc2luay40LjFcIlxuICAgICAgXCJTSElQUEFCTEVfSk9CX0lEXCIsIC8vIFwiMVwiXG4gICAgICBcIlNISVBQQUJMRV9KT0JfTlVNQkVSXCIsIC8vIFwiMVwiXG4gICAgICBcIlNISVBQQUJMRV9SRVBPX1NMVUdcIiwgLy8gXCI8dXNlcm5hbWU+LzxyZXBvPlwiXG4gICAgICAvLyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgU2hpcHBhYmxlIHByb3ZpZGVzXG4gICAgICBcIklTX0ZPUktcIiwgLy8gXCJ0cnVlXCJcbiAgICAgIFwiSVNfR0lUX1RBR1wiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiSVNfUFJFUkVMRUFTRVwiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiSVNfUkVMRUFTRVwiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiUkVQT1NJVE9SWV9VUkxcIiwgLy8gXCJodHRwczovL2dpdGh1Yi5jb20vLi4uLmdpdFwiXG4gICAgICBcIlJFUE9fRlVMTF9OQU1FXCIsIC8vIFwiPHVzZXJuYW1lPi88cmVwbz5cIlxuICAgICAgXCJSRVBPX05BTUVcIiwgLy8gXCJjeXByZXNzLWV4YW1wbGUta2l0Y2hlbnNpbmtcIlxuICAgICAgXCJCVUlMRF9VUkxcIiwgLy8gXCJodHRwczovL2FwcC5zaGlwcGFibGUuY29tL2dpdGh1Yi88dXNlcm5hbWU+LzxyZXBvPi9ydW5zLzFcIlxuICAgICAgLy8gUHVsbCByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgICBcIkJBU0VfQlJBTkNIXCIsIC8vIE5hbWUgb2YgdGhlIHRhcmdldCBicmFuY2ggaW50byB3aGljaCB0aGUgcHVsbCByZXF1ZXN0IGNoYW5nZXMgd2lsbCBiZSBtZXJnZWQuXG4gICAgICBcIkhFQURfQlJBTkNIXCIsIC8vIFRoaXMgaXMgb25seSBzZXQgZm9yIHB1bGwgcmVxdWVzdHMgYW5kIGlzIHRoZSBuYW1lIG9mIHRoZSBicmFuY2ggdGhlIHB1bGwgcmVxdWVzdCB3YXMgb3BlbmVkIGZyb20uXG4gICAgICBcIklTX1BVTExfUkVRVUVTVFwiLCAvLyBcImZhbHNlXCIgb3IgXCJ0cnVlXCJcbiAgICAgIFwiUFVMTF9SRVFVRVNUXCIsIC8vIFB1bGwgcmVxdWVzdCBudW1iZXIgaWYgdGhlIGpvYiBpcyBhIHB1bGwgcmVxdWVzdC4gSWYgbm90LCB0aGlzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuICAgICAgXCJQVUxMX1JFUVVFU1RfQkFTRV9CUkFOQ0hcIiwgLy8gTmFtZSBvZiB0aGUgYnJhbmNoIHRoYXQgdGhlIHB1bGwgcmVxdWVzdCB3aWxsIGJlIG1lcmdlZCBpbnRvLiBJdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgQkFTRV9CUkFOQ0guXG4gICAgICBcIlBVTExfUkVRVUVTVF9SRVBPX0ZVTExfTkFNRVwiLCAvLyBGdWxsIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgZnJvbSB3aGVyZSB0aGUgcHVsbCByZXF1ZXN0IG9yaWdpbmF0ZWQuXG4gICAgXSksXG4gICAgdGVhbWNpdHk6IG51bGwsXG4gICAgdGVhbWZvdW5kYXRpb246IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9CVUlMRElEXCIsXG4gICAgICBcIkJVSUxEX0JVSUxETlVNQkVSXCIsXG4gICAgICBcIkJVSUxEX0NPTlRBSU5FUklEXCIsXG4gICAgXSksXG4gICAgdHJhdmlzOiBleHRyYWN0KFtcbiAgICAgIFwiVFJBVklTX0pPQl9JRFwiLFxuICAgICAgXCJUUkFWSVNfQlVJTERfSURcIixcbiAgICAgIFwiVFJBVklTX0JVSUxEX1dFQl9VUkxcIixcbiAgICAgIFwiVFJBVklTX1JFUE9fU0xVR1wiLFxuICAgICAgXCJUUkFWSVNfSk9CX05VTUJFUlwiLFxuICAgICAgXCJUUkFWSVNfRVZFTlRfVFlQRVwiLFxuICAgICAgXCJUUkFWSVNfQ09NTUlUX1JBTkdFXCIsXG4gICAgICBcIlRSQVZJU19CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiVFJBVklTX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUX0JSQU5DSFwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUX1NIQVwiLFxuICAgIF0pLFxuICAgIHdlcmNrZXI6IG51bGwsXG4gICAgLy8gaHR0cHM6Ly9kb2NzLm5ldGxpZnkuY29tL2NvbmZpZ3VyZS1idWlsZHMvZW52aXJvbm1lbnQtdmFyaWFibGVzLyNkZXBsb3ktdXJscy1hbmQtbWV0YWRhdGFcbiAgICBuZXRsaWZ5OiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfSURcIixcbiAgICAgIFwiQ09OVEVYVFwiLFxuICAgICAgXCJVUkxcIixcbiAgICAgIFwiREVQTE9ZX1VSTFwiLFxuICAgICAgXCJERVBMT1lfUFJJTUVfVVJMXCIsXG4gICAgICBcIkRFUExPWV9JRFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vbGF5ZXJjaS5jb20vZG9jcy9sYXllcmZpbGUtcmVmZXJlbmNlL2J1aWxkLWVudlxuICAgIGxheWVyY2k6IGV4dHJhY3QoW1xuICAgICAgXCJMQVlFUkNJX0pPQl9JRFwiLFxuICAgICAgXCJMQVlFUkNJX1JVTk5FUl9JRFwiLFxuICAgICAgXCJSRVRSWV9JTkRFWFwiLFxuICAgICAgXCJMQVlFUkNJX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJMQVlFUkNJX1JFUE9fTkFNRVwiLFxuICAgICAgXCJMQVlFUkNJX1JFUE9fT1dORVJcIixcbiAgICAgIFwiTEFZRVJDSV9CUkFOQ0hcIixcbiAgICAgIFwiR0lUX1RBR1wiLCAvLyBzaG9ydCBoZXggZm9yIGNvbW1pdHNcbiAgICBdKSxcbiAgfTtcbn07XG5cbi8vIHRyaWVzIHRvIGdyYWIgY29tbWl0IGluZm9ybWF0aW9uIGZyb20gQ0kgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4vLyB2ZXJ5IHVzZWZ1bCB0byBmaWxsIG1pc3NpbmcgaW5mb3JtYXRpb24gd2hlbiBHaXQgY2Fubm90IGdyYWIgY29ycmVjdCB2YWx1ZXNcbmNvbnN0IF9wcm92aWRlckNvbW1pdFBhcmFtcyA9ICgpOiBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyA9PiB7XG4gIGNvbnN0IHsgZW52IH0gPSBwcm9jZXNzO1xuXG4gIHJldHVybiB7XG4gICAgYXBwdmV5b3I6IHtcbiAgICAgIHNoYTogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlULFxuICAgICAgLy8gc2luY2UgQVBQVkVZT1JfUkVQT19CUkFOQ0ggd2lsbCBiZSB0aGUgdGFyZ2V0IGJyYW5jaCBvbiBhIFBSXG4gICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBQVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSCBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBlLmcuIGlmIHlvdSBoYXZlIGEgUFI6IGRldmVsb3AgPC0gbXktZmVhdHVyZS1icmFuY2hcbiAgICAgIC8vIG15LWZlYXR1cmUtYnJhbmNoIGlzIEFQUFZFWU9SX1BVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIXG4gICAgICAvLyBkZXZlbG9wICAgICAgICAgICBpcyBBUFBWRVlPUl9SRVBPX0JSQU5DSFxuICAgICAgYnJhbmNoOlxuICAgICAgICBlbnYuQVBQVkVZT1JfUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0ggfHwgZW52LkFQUFZFWU9SX1JFUE9fQlJBTkNILFxuICAgICAgbWVzc2FnZTogam9pbihcbiAgICAgICAgXCJcXG5cIixcbiAgICAgICAgZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX01FU1NBR0UsXG4gICAgICAgIGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9NRVNTQUdFX0VYVEVOREVEXG4gICAgICApLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX0FVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfQVVUSE9SX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYXdzQ29kZUJ1aWxkOiB7XG4gICAgICBzaGE6IGVudi5DT0RFQlVJTERfUkVTT0xWRURfU09VUkNFX1ZFUlNJT04sXG4gICAgICAvLyBicmFuY2g6ID8/PyxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DT0RFQlVJTERfU09VUkNFX1JFUE9fVVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBhenVyZToge1xuICAgICAgc2hhOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkJVSUxEX1NPVVJDRUJSQU5DSE5BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTk1FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTkFVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQlVJTERfUkVRVUVTVEVERk9SRU1BSUwsXG4gICAgfSxcbiAgICBiYW1ib286IHtcbiAgICAgIHNoYTogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXZpc2lvbixcbiAgICAgIGJyYW5jaDogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9icmFuY2gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIGF1dGhvck5hbWU6IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfdXNlcm5hbWUsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfcmVwb3NpdG9yeVVSTCxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYml0YnVja2V0OiB7XG4gICAgICBzaGE6IGVudi5CSVRCVUNLRVRfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuQklUQlVDS0VUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBidWlsZGtpdGU6IHtcbiAgICAgIHNoYTogZW52LkJVSUxES0lURV9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CVUlMREtJVEVfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkJVSUxES0lURV9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkJVSUxES0lURV9CVUlMRF9DUkVBVE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5CVUlMREtJVEVfQlVJTERfQ1JFQVRPUl9FTUFJTCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkJVSUxES0lURV9SRVBPLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkJVSUxES0lURV9QSVBFTElORV9ERUZBVUxUX0JSQU5DSCxcbiAgICB9LFxuICAgIGNpcmNsZToge1xuICAgICAgc2hhOiBlbnYuQ0lSQ0xFX1NIQTEsXG4gICAgICBicmFuY2g6IGVudi5DSVJDTEVfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lSQ0xFX1VTRVJOQU1FLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ0lSQ0xFX1JFUE9TSVRPUllfVVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBjb2Rlc2hpcEJhc2ljOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfSUQsXG4gICAgICBicmFuY2g6IGVudi5DSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lfQ09NTUlUVEVSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkNJX0NPTU1JVFRFUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVzaGlwUHJvOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfSUQsXG4gICAgICBicmFuY2g6IGVudi5DSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lfQ09NTUlUVEVSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkNJX0NPTU1JVFRFUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVGcmVzaDoge1xuICAgICAgc2hhOiBlbnYuQ0ZfUkVWSVNJT04sXG4gICAgICBicmFuY2g6IGVudi5DRl9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0ZfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0ZfQ09NTUlUX0FVVEhPUixcbiAgICB9LFxuICAgIGRyb25lOiB7XG4gICAgICBzaGE6IGVudi5EUk9ORV9DT01NSVRfU0hBLFxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmRyb25lLmlvL3BpcGVsaW5lL2Vudmlyb25tZW50L3JlZmVyZW5jZS9kcm9uZS1zb3VyY2UtYnJhbmNoL1xuICAgICAgYnJhbmNoOiBlbnYuRFJPTkVfU09VUkNFX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5EUk9ORV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5EUk9ORV9DT01NSVRfQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5EUk9ORV9DT01NSVRfQVVUSE9SX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuRFJPTkVfR0lUX0hUVFBfVVJMLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkRST05FX1JFUE9fQlJBTkNILFxuICAgIH0sXG4gICAgZ2l0aHViQWN0aW9uczoge1xuICAgICAgc2hhOiBlbnYuR0lUSFVCX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkdIX0JSQU5DSCB8fCBlbnYuR0lUSFVCX1JFRixcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5HSVRIVUJfQkFTRV9SRUYsXG4gICAgICByZW1vdGVCcmFuY2g6IGVudi5HSVRIVUJfSEVBRF9SRUYsXG4gICAgICBydW5BdHRlbXB0OiBlbnYuR0lUSFVCX1JVTl9BVFRFTVBULFxuICAgIH0sXG4gICAgZ2l0bGFiOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuQ0lfQ09NTUlUX1JFRl9OQU1FLFxuICAgICAgbWVzc2FnZTogZW52LkNJX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkdJVExBQl9VU0VSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkdJVExBQl9VU0VSX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ0lfUkVQT1NJVE9SWV9VUkwsXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuQ0lfREVGQVVMVF9CUkFOQ0gsXG4gICAgfSxcbiAgICBnb29nbGVDbG91ZDoge1xuICAgICAgc2hhOiBlbnYuQ09NTUlUX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSF9OQU1FLFxuICAgICAgLy8gbWVzc2FnZTogPz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/P1xuICAgIH0sXG4gICAgamVua2luczoge1xuICAgICAgc2hhOiBlbnYuR0lUX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkdJVF9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgLy8gT25seSBmcm9tIGZvcmtzPyBodHRwczovL3NlbWFwaG9yZWNpLmNvbS9kb2NzL2F2YWlsYWJsZS1lbnZpcm9ubWVudC12YXJpYWJsZXMuaHRtbFxuICAgIHNlbWFwaG9yZToge1xuICAgICAgc2hhOiBlbnYuU0VNQVBIT1JFX0dJVF9TSEEsXG4gICAgICBicmFuY2g6IGVudi5TRU1BUEhPUkVfR0lUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5TRU1BUEhPUkVfR0lUX1JFUE9fU0xVRyxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgc2hpcHBhYmxlOiB7XG4gICAgICBzaGE6IGVudi5DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ09NTUlUVEVSLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgc25hcDogbnVsbCxcbiAgICB0ZWFtY2l0eTogbnVsbCxcbiAgICB0ZWFtZm91bmRhdGlvbjoge1xuICAgICAgc2hhOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkJVSUxEX1NPVVJDRUJSQU5DSE5BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTk1FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTkFVVEhPUixcbiAgICB9LFxuICAgIHRyYXZpczoge1xuICAgICAgc2hhOiBlbnYuVFJBVklTX1BVTExfUkVRVUVTVF9TSEEgfHwgZW52LlRSQVZJU19DT01NSVQsXG4gICAgICAvLyBmb3IgUFJzLCBUUkFWSVNfQlJBTkNIIGlzIHRoZSBiYXNlIGJyYW5jaCBiZWluZyBtZXJnZWQgaW50b1xuICAgICAgYnJhbmNoOiBlbnYuVFJBVklTX1BVTExfUkVRVUVTVF9CUkFOQ0ggfHwgZW52LlRSQVZJU19CUkFOQ0gsXG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIG1lc3NhZ2U6IGVudi5UUkFWSVNfQ09NTUlUX01FU1NBR0UsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICB3ZXJja2VyOiBudWxsLFxuICAgIG5ldGxpZnk6IHtcbiAgICAgIHNoYTogZW52LkNPTU1JVF9SRUYsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0gsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5SRVBPU0lUT1JZX1VSTCxcbiAgICB9LFxuICAgIGxheWVyY2k6IHtcbiAgICAgIHNoYTogZW52LkdJVF9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5MQVlFUkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5HSVRfQ09NTUlUX1RJVExFLFxuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBDaVByb3ZpZGVyRGF0YSA9IHtcbiAgc2hhPzogc3RyaW5nO1xuICBicmFuY2g/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGF1dGhvck5hbWU/OiBzdHJpbmc7XG4gIGF1dGhvckVtYWlsPzogc3RyaW5nO1xuICByZW1vdGVPcmlnaW4/OiBzdHJpbmc7XG4gIGRlZmF1bHRCcmFuY2g/OiBzdHJpbmc7XG4gIHJlbW90ZUJyYW5jaD86IHN0cmluZztcbiAgcnVuQXR0ZW1wdD86IHN0cmluZztcbiAgZ2hhRXZlbnREYXRhPzogR2hhRXZlbnREYXRhIHwgbnVsbDtcbn07XG5cbmludGVyZmFjZSBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyB7XG4gIFtrZXk6IHN0cmluZ106IENpUHJvdmlkZXJEYXRhIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFByb3ZpZGVyQ2lQYXJhbXNSZXMge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgX2dldCA9IChmbjogKCkgPT4gUHJvdmlkZXJDb21taXRQYXJhbXNSZXMgfCBQcm92aWRlckNpUGFyYW1zUmVzKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlck5hbWUpIHJldHVybiB7fTtcblxuICByZXR1cm4gXy5jaGFpbihmbigpKS5nZXQocHJvdmlkZXJOYW1lKS52YWx1ZSgpO1xufTtcblxuLyoqXG4gKiBJZiB0aGVyZSBpcyBubyBidWlsZCBJRCBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYnkgdXNlclxuICogQ2hlY2sgaWYgd2UgY2FuIGZldGNoIGl0IGF1dG9tYXRpY2FsbHkgZnJvbSBDSSB2YXJpYWJsZXMuXG4gKiBUaGUgcHJvY2VzcyB3aWxsIHN0b3AgaWYgd2UgY2Fubm90IGRvIGl0XG4gKiBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvcmVmZXJlbmNlcy9lcnJvci1tZXNzYWdlcyNXZS1jb3VsZC1ub3QtZGV0ZXJtaW5lLWEtdW5pcXVlLUNJLWJ1aWxkLUlEXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShjaVByb3ZpZGVyOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChjaVByb3ZpZGVyICYmIGRldGVjdGFibGVDaUJ1aWxkSWRQcm92aWRlcnMoKS5pbmNsdWRlcyhjaVByb3ZpZGVyKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIENJIGJ1aWxkIElEIGZyb20gdGhlIGVudmlyb25tZW50LiBQbGVhc2UgcHJvdmlkZSBhIHVuaXF1ZSBDSSBidWlsZCBJRCB1c2luZyB0aGUgLS1jaS1idWlsZC1pZCBDTEkgZmxhZyBvciAnY2lCdWlsZElkJyBwYXJhbWV0ZXIgZm9yICdydW4nIG1ldGhvZC5gXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0KCkge1xuICByZXR1cm4gXy5rZXlzKENJX1BST1ZJREVSUyk7XG59XG5cbi8vIGdyYWIgYWxsIGRldGVjdGFibGUgcHJvdmlkZXJzXG4vLyB0aGF0IHdlIGNhbiBleHRyYWN0IGNpQnVpbGRJZCBmcm9tXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0YWJsZUNpQnVpbGRJZFByb3ZpZGVycygpIHtcbiAgcmV0dXJuIF8uY2hhaW4oX3Byb3ZpZGVyQ2lQYXJhbXMoKSkub21pdEJ5KF8uaXNOdWxsKS5rZXlzKCkudmFsdWUoKTtcbn1cblxuZXhwb3J0IHR5cGUgQ2lQcm92aWRlciA9IHN0cmluZyB8IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaVByb3ZpZGVyKCk6IENpUHJvdmlkZXIge1xuICByZXR1cm4gX2RldGVjdFByb3ZpZGVyTmFtZSgpIHx8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIENpUGFyYW1zID0ge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lQYXJhbXMoKSB7XG4gIHJldHVybiBfZ2V0KF9wcm92aWRlckNpUGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdFBhcmFtcygpIHtcbiAgcmV0dXJuIF9nZXQoX3Byb3ZpZGVyQ29tbWl0UGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENJKGNpQnVpbGRJZD86IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSBnZXRDaVBhcmFtcygpIGFzIENpUGFyYW1zO1xuICBjb25zdCBwcm92aWRlciA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFjaUJ1aWxkSWQpIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShwcm92aWRlcik7XG5cbiAgZGVidWcoXCJkZXRlY3RlZCBDSSBwcm92aWRlcjogJXNcIiwgcHJvdmlkZXIpO1xuICBkZWJ1ZyhcImRldGVjdGVkIENJIHBhcmFtczogJU9cIiwgcGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcHJvdmlkZXIsXG4gIH07XG59XG4iLCAiaW1wb3J0IGRlYnVnRm4gZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5cbmltcG9ydCB7IEdoYUV2ZW50RGF0YSB9IGZyb20gXCIuLi9naXRcIjtcbmltcG9ydCB7IENpUHJvdmlkZXIsIENpUHJvdmlkZXJEYXRhLCBnZXRDb21taXRQYXJhbXMgfSBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGbihcImN1cnJlbnRzOmNpXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbWl0RGVmYXVsdHMoZXhpc3RpbmdJbmZvOiBDaVByb3ZpZGVyRGF0YSkge1xuICBkZWJ1ZyhcImdpdCBjb21taXQgZXhpc3RpbmcgaW5mb1wiKTtcbiAgZGVidWcoZXhpc3RpbmdJbmZvKTtcblxuICBjb25zdCBjb21taXRQYXJhbXNPYmogPSBnZXRDb21taXRQYXJhbXMoKTtcblxuICBkZWJ1ZyhcImNvbW1pdCBpbmZvIGZyb20gcHJvdmlkZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzOiAlT1wiLCBjb21taXRQYXJhbXNPYmopO1xuXG4gIC8vIGJhc2VkIG9uIHRoZSBleGlzdGluZ0luZm8gcHJvcGVydGllc1xuICAvLyBtZXJnZSBpbiB0aGUgY29tbWl0UGFyYW1zIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gIC8vIGRlZmF1bHRpbmcgYmFjayB0byBudWxsIGlmIGFsbCBmYWlsc1xuICAvLyBOT1RFOiBvbmx5IHByb3BlcnRpZXMgZGVmaW5lZCBpbiBcImV4aXN0aW5nSW5mb1wiIHdpbGwgYmUgcmV0dXJuZWRcbiAgY29uc3QgY29tYmluZWQgPSBfLnRyYW5zZm9ybShcbiAgICBleGlzdGluZ0luZm8sXG4gICAgKFxuICAgICAgbWVtbzogeyBbbWVtb0tleTogc3RyaW5nXTogc3RyaW5nIHwgR2hhRXZlbnREYXRhIHwgbnVsbCB9LFxuICAgICAgdmFsdWU6IHN0cmluZyB8IEdoYUV2ZW50RGF0YSB8IG51bGwsXG4gICAgICBrZXk6IHN0cmluZ1xuICAgICkgPT4ge1xuICAgICAgcmV0dXJuIChtZW1vW2tleV0gPSBfLmRlZmF1bHRUbyhcbiAgICAgICAgdmFsdWUgfHxcbiAgICAgICAgICAoY29tbWl0UGFyYW1zT2JqID8gY29tbWl0UGFyYW1zT2JqW2tleSBhcyBrZXlvZiBDaVByb3ZpZGVyXSA6IG51bGwpLFxuICAgICAgICBudWxsXG4gICAgICApKTtcbiAgICB9XG4gICk7XG5cbiAgZGVidWcoXCJjb21iaW5lZCBnaXQgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHByb3ZpZGVyXCIpO1xuICBkZWJ1Zyhjb21iaW5lZCk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkO1xufVxuIiwgImltcG9ydCBmcyBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY29uc3QgZ2V0Q292ZXJhZ2VGaWxlUGF0aCA9IGFzeW5jIChcbiAgY292ZXJhZ2VGaWxlID0gXCIuLy5ueWNfb3V0cHV0L291dC5qc29uXCJcbikgPT4ge1xuICBjb25zdCBwYXRoID0gam9pbihwcm9jZXNzLmN3ZCgpLCBjb3ZlcmFnZUZpbGUpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMuYWNjZXNzKHBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGZhbHNlLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcixcbiAgICB9O1xuICB9XG59O1xuIiwgImltcG9ydCBjeXByZXNzIGZyb20gXCJjeXByZXNzXCI7XG5pbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIEN5cHJlc3NSZXN1bHQsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IGdldEN5cHJlc3NSdW5BUElQYXJhbXMgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBzYWZlIH0gZnJvbSBcIi4uL2xhbmdcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRXU1NQb3J0IH0gZnJvbSBcIi4uL3dzXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjeXByZXNzXCIpO1xuaW50ZXJmYWNlIFJ1bkN5cHJlc3NTcGVjRmlsZSB7XG4gIHNwZWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkJhcmVDeXByZXNzKHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzID0ge30pIHtcbiAgLy8gcmV2ZXJ0IGN1cnJlbnRzIHBhcmFtcyB0byBjeXByZXNzIHBhcmFtc1xuICAvLyBleGNsdWRlIHJlY29yZCBtb2RlIHBhcmFtc1xuICBjb25zdCBwID0ge1xuICAgIC4uLnBhcmFtcyxcbiAgICBjaUJ1aWxkSWQ6IHVuZGVmaW5lZCxcbiAgICB0YWc6IHVuZGVmaW5lZCxcbiAgICBwYXJhbGxlbDogdW5kZWZpbmVkLFxuICAgIHJlY29yZDogZmFsc2UsXG4gICAgZ3JvdXA6IHVuZGVmaW5lZCxcbiAgICBzcGVjOiBfLmZsYXR0ZW4ocGFyYW1zLnNwZWMpLmpvaW4oXCIsXCIpLFxuICB9O1xuICBkZWJ1ZyhcIlJ1bm5pbmcgYmFyZSBDeXByZXNzIHdpdGggcGFyYW1zICVvXCIsIHApO1xuICByZXR1cm4gY3lwcmVzcy5ydW4ocCk7XG59XG5cbi8qKlxuICogUnVuIEN5cHJlc3MgdGVzdHMsIHdlIG5lZWQgdG8gcGFzcyBkb3duIHRoZSBzdHJpcHBlZCBvcHRpb25zIGFzIGlmIHdlJ3ZlIHJlY2VpdmVkIHRoZW0gZnJvbSB0aGUgQ0xJXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5TcGVjRmlsZShcbiAgeyBzcGVjIH06IFJ1bkN5cHJlc3NTcGVjRmlsZSxcbiAgY3lwcmVzc1J1bk9wdGlvbnM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKSB7XG4gIGNvbnN0IHJ1bkFQSU9wdGlvbnMgPSBnZXRDeXByZXNzUnVuQVBJUGFyYW1zKGN5cHJlc3NSdW5PcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLnJ1bkFQSU9wdGlvbnMsXG4gICAgY29uZmlnOiB7XG4gICAgICAuLi5ydW5BUElPcHRpb25zLmNvbmZpZyxcbiAgICAgIHRyYXNoQXNzZXRzQmVmb3JlUnVuczogZmFsc2UsXG4gICAgfSxcbiAgICBlbnY6IHtcbiAgICAgIC4uLnJ1bkFQSU9wdGlvbnMuZW52LFxuICAgICAgY3VycmVudHNfd3M6IGdldFdTU1BvcnQoKSxcbiAgICB9LFxuICAgIHNwZWMsXG4gIH07XG4gIGRlYnVnKFwicnVubmluZyBjeXByZXNzIHdpdGggb3B0aW9ucyAlb1wiLCBvcHRpb25zKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3lwcmVzcy5ydW4ob3B0aW9ucyk7XG5cbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICB3YXJuKCdDeXByZXNzIHJ1bm5lciBmYWlsZWQgd2l0aCBtZXNzYWdlOiBcIiVzXCInLCByZXN1bHQubWVzc2FnZSk7XG4gICAgd2FybihcbiAgICAgIFwiVGhlIGZvbGxvd2luZyBzcGVjIGZpbGVzIHdpbGwgYmUgbWFya2VkIGFzIGZhaWxlZDogJXNcIixcbiAgICAgIHNwZWNcbiAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAubWFwKChpKSA9PiBgXFxuIC0gJHtpfWApXG4gICAgICAgIC5qb2luKFwiXCIpXG4gICAgKTtcbiAgfVxuICBkZWJ1ZyhcImN5cHJlc3MgcnVuIHJlc3VsdCAlb1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3QgcnVuU3BlY0ZpbGVTYWZlID0gKFxuICBzcGVjOiBSdW5DeXByZXNzU3BlY0ZpbGUsXG4gIGN5cHJlc3NSdW5PcHRpb25zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnNcbik6IFByb21pc2U8Q3lwcmVzc1Jlc3VsdD4gPT5cbiAgc2FmZShcbiAgICBydW5TcGVjRmlsZSxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ3lwcmVzcyBydW5ubmVyIGNyYXNoZWQgd2l0aCBhbiBlcnJvcjpcXG4ke1xuICAgICAgICAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2VcbiAgICAgIH1cXG4keyhlcnJvciBhcyBFcnJvcikuc3RhY2t9fWA7XG4gICAgICBkZWJ1ZyhcImN5cHJlc3MgcnVuIGV4Y2VwdGlvbiAlb1wiLCBlcnJvcik7XG4gICAgICB3YXJuKCdDeXByZXNzIHJ1bm5lciBjcmFzaGVkOiBcIiVzXCInLCBtZXNzYWdlKTtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVGhlIGZvbGxvd2luZyBzcGVjIGZpbGVzIHdpbGwgYmUgbWFya2VkIGFzIGZhaWxlZDogJXNcIixcbiAgICAgICAgc3BlYy5zcGVjXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5tYXAoKGkpID0+IGBcXG4gLSAke2l9YClcbiAgICAgICAgICAuam9pbihcIlwiKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJmYWlsZWRcIiBhcyBjb25zdCxcbiAgICAgICAgZmFpbHVyZXM6IDEsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgKCkgPT4ge31cbiAgKShzcGVjLCBjeXByZXNzUnVuT3B0aW9ucyk7XG4iLCAiaW1wb3J0IGJsdWViaXJkIGZyb20gXCJibHVlYmlyZFwiO1xuXG5ibHVlYmlyZC5Qcm9taXNlLmNvbmZpZyh7XG4gIGNhbmNlbGxhdGlvbjogdHJ1ZSxcbn0pO1xuZXhwb3J0IGNvbnN0IEJQcm9taXNlID0gYmx1ZWJpcmQuUHJvbWlzZTtcblxuZXhwb3J0IGNvbnN0IHNhZmUgPVxuICA8VCBleHRlbmRzIGFueVtdLCBSIGV4dGVuZHMgYW55LCBGIGV4dGVuZHMgYW55PihcbiAgICBmbjogKC4uLmFyZ3M6IFQpID0+IFByb21pc2U8Uj4sXG4gICAgaWZGYWxlZDogKGU6IHVua25vd24pID0+IEYsXG4gICAgaWZTdWNjZWVkOiAoKSA9PiBhbnlcbiAgKSA9PlxuICBhc3luYyAoLi4uYXJnczogVCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gYXdhaXQgZm4oLi4uYXJncyk7XG4gICAgICBpZlN1Y2NlZWQoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBpZkZhbGVkKGUpO1xuICAgIH1cbiAgfTtcbiIsICJpbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBtYXRjaCwgUCB9IGZyb20gXCJ0cy1wYXR0ZXJuXCI7XG5pbXBvcnQgeyBDdXJyZW50c1J1blBhcmFtZXRlcnMsIERlYnVnTW9kZSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5lbnVtIERlYnVnVG9rZW5zIHtcbiAgQ3VycmVudHMgPSBcImN1cnJlbnRzOipcIixcbiAgQ3lwcmVzcyA9IFwiY3lwcmVzczoqXCIsXG4gIENvbW1pdEluZm8gPSBcImNvbW1pdC1pbmZvXCIsXG59XG5leHBvcnQgZnVuY3Rpb24gYWN0aXZhdGVEZWJ1Zyhtb2RlOiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJjbG91ZERlYnVnXCJdKSB7XG4gIG1hdGNoKG1vZGUpXG4gICAgLndpdGgoUC5pbnN0YW5jZU9mKEFycmF5KSwgKGkpID0+IGkuZm9yRWFjaChzZXREZWJ1Z01vZGUpKVxuICAgIC53aXRoKHRydWUsICgpID0+IHNldERlYnVnTW9kZShEZWJ1Z01vZGUuQWxsKSlcbiAgICAud2l0aChcbiAgICAgIFAudW5pb24oXG4gICAgICAgIERlYnVnTW9kZS5BbGwsXG4gICAgICAgIERlYnVnTW9kZS5DdXJyZW50cyxcbiAgICAgICAgRGVidWdNb2RlLkN5cHJlc3MsXG4gICAgICAgIERlYnVnTW9kZS5Db21taXRJbmZvXG4gICAgICApLFxuICAgICAgKGkpID0+IHNldERlYnVnTW9kZShpKVxuICAgIClcbiAgICAub3RoZXJ3aXNlKCgpID0+IHNldERlYnVnTW9kZShEZWJ1Z01vZGUuTm9uZSkpO1xufVxuXG5mdW5jdGlvbiBzZXREZWJ1Z01vZGUobW9kZTogc3RyaW5nKSB7XG4gIGlmIChtb2RlID09PSBEZWJ1Z01vZGUuTm9uZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHRva2VucyA9IG5ldyBTZXQocHJvY2Vzcy5lbnYuREVCVUcgPyBwcm9jZXNzLmVudi5ERUJVRy5zcGxpdChcIixcIikgOiBbXSk7XG4gIG1hdGNoKG1vZGUpXG4gICAgLndpdGgoRGVidWdNb2RlLkFsbCwgKCkgPT4ge1xuICAgICAgdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5Db21taXRJbmZvKTtcbiAgICAgIHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ3VycmVudHMpO1xuICAgICAgdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DeXByZXNzKTtcbiAgICB9KVxuICAgIC53aXRoKERlYnVnTW9kZS5DdXJyZW50cywgKCkgPT4gdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DdXJyZW50cykpXG4gICAgLndpdGgoRGVidWdNb2RlLkN5cHJlc3MsICgpID0+IHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ3lwcmVzcykpXG4gICAgLndpdGgoRGVidWdNb2RlLkNvbW1pdEluZm8sICgpID0+IHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ29tbWl0SW5mbykpXG4gICAgLm90aGVyd2lzZSgoKSA9PiB7fSk7XG5cbiAgZGVidWcuZW5hYmxlKEFycmF5LmZyb20odG9rZW5zKS5qb2luKFwiLFwiKSk7XG59XG4iLCAiaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCB9IGZyb20gXCIuL2h0dHBDbGllbnQvY29uZmlnXCI7XG5cbmV4cG9ydCBjb25zdCBpc0N1cnJlbnRzID0gKCkgPT5cbiAgISFwcm9jZXNzLmVudi5DVVJSRU5UU19FTkZPUkNFX0lTX0NVUlJFTlRTIHx8XG4gIGdldEFQSUJhc2VVcmwoKSA9PT0gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiO1xuIiwgIi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IGNvbW1pdEluZm8gfSBmcm9tIFwiQGN1cnJlbnRzL2NvbW1pdC1pbmZvXCI7XG5pbXBvcnQgeyBnZXRDb21taXREZWZhdWx0cyB9IGZyb20gXCIuL2NpUHJvdmlkZXJcIjtcblxuZXhwb3J0IHR5cGUgR2hhRXZlbnREYXRhID0ge1xuICBoZWFkUmVmOiBzdHJpbmc7XG4gIGhlYWRTaGE6IHN0cmluZztcbiAgYmFzZVJlZjogc3RyaW5nO1xuICBiYXNlU2hhOiBzdHJpbmc7XG4gIGlzc3VlVXJsOiBzdHJpbmc7XG4gIGh0bWxVcmw6IHN0cmluZztcbiAgcHJUaXRsZTogc3RyaW5nO1xuICBzZW5kZXJBdmF0YXJVcmw6IHN0cmluZztcbiAgc2VuZGVySHRtbFVybDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEdpdEluZm8gPSBhc3luYyAocHJvamVjdFJvb3Q6IHN0cmluZykgPT4ge1xuICBjb25zdCBjb21taXQgPSBhd2FpdCBjb21taXRJbmZvKHByb2plY3RSb290KTtcbiAgcmV0dXJuIGdldENvbW1pdERlZmF1bHRzKHtcbiAgICBicmFuY2g6IGNvbW1pdC5icmFuY2gsXG4gICAgcmVtb3RlT3JpZ2luOiBjb21taXQucmVtb3RlLFxuICAgIGF1dGhvckVtYWlsOiBjb21taXQuZW1haWwsXG4gICAgYXV0aG9yTmFtZTogY29tbWl0LmF1dGhvcixcbiAgICBtZXNzYWdlOiBjb21taXQubWVzc2FnZSxcbiAgICBzaGE6IGNvbW1pdC5zaGEsXG4gICAgZ2hhRXZlbnREYXRhOiBjb21taXQuZ2hhRXZlbnREYXRhLFxuICB9KTtcbn07XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRGV0ZWN0ZWRCcm93c2VyLCBQbGF0Zm9ybSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmJyb3dzZXJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBndWVzc0Jyb3dzZXIoXG4gIGJyb3dzZXI6IHN0cmluZyxcbiAgYXZhaWxhYmxlQnJvd3NlcnM6IERldGVjdGVkQnJvd3NlcltdID0gW11cbik6IFBpY2s8UGxhdGZvcm0sIFwiYnJvd3Nlck5hbWVcIiB8IFwiYnJvd3NlclZlcnNpb25cIj4ge1xuICBkZWJ1ZyhcbiAgICBcImd1ZXNzaW5nIGJyb3dzZXIgZnJvbSAnJXMnLCBhdmFpbGFibGUgYnJvd3NlcnM6ICVvXCIsXG4gICAgYnJvd3NlcixcbiAgICBhdmFpbGFibGVCcm93c2Vyc1xuICApO1xuICAvLyB0cnkgaWRlbnRpZnlpbmcgdGhlIGJyb3dzZXIgYnkgbmFtZSBmaXJzdFxuICBsZXQgcmVzdWx0ID0gYXZhaWxhYmxlQnJvd3NlcnMuZmluZCgoYikgPT4gYi5uYW1lID09PSBicm93c2VyKTtcblxuICBpZiAocmVzdWx0KSB7XG4gICAgZGVidWcoXCJpZGVudGlmaWVkIGJyb3dzZXIgYnkgbmFtZTogJW9cIiwgcmVzdWx0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3Nlck5hbWU6IHJlc3VsdC5kaXNwbGF5TmFtZSxcbiAgICAgIGJyb3dzZXJWZXJzaW9uOiByZXN1bHQudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCB0cnkgaWRlbnRpZnlpbmcgYnkgdGhlIHBhdGhcbiAgcmVzdWx0ID0gYXZhaWxhYmxlQnJvd3NlcnMuZmluZCgoYikgPT4gYi5wYXRoID09PSBicm93c2VyKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGRlYnVnKFwiaWRlbnRpZmllZCBicm93c2VyIGJ5IHBhdGg6ICVvXCIsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJOYW1lOiByZXN1bHQuZGlzcGxheU5hbWUgPz8gcmVzdWx0Lm5hbWUsXG4gICAgICBicm93c2VyVmVyc2lvbjogcmVzdWx0LnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIHdhcm4oXCJVbmFibGUgdG8gaWRlbnRpZnkgYnJvd3NlciBuYW1lIGFuZCB2ZXJzaW9uXCIpO1xuXG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIGR1bW15IGJyb3dzZXJcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyTmFtZTogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclZlcnNpb246IFwidW5rbm93blwiLFxuICB9O1xufVxuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBnZXRvcyBmcm9tIFwiZ2V0b3NcIjtcbmltcG9ydCB7IGNwdXMsIGZyZWVtZW0sIHBsYXRmb3JtLCByZWxlYXNlLCB0b3RhbG1lbSB9IGZyb20gXCJvc1wiO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSBcInV0aWxcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnBsYXRmb3JtXCIpO1xuXG5jb25zdCBnZXRPc1ZlcnNpb24gPSBhc3luYyAoKSA9PiB7XG4gIGlmIChwbGF0Zm9ybSgpID09PSBcImxpbnV4XCIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbGludXhPcyA9IGF3YWl0IHByb21pc2lmeShnZXRvcykoKTtcbiAgICAgIGlmIChcImRpc3RcIiBpbiBsaW51eE9zICYmIFwicmVsZWFzZVwiIGluIGxpbnV4T3MpIHtcbiAgICAgICAgcmV0dXJuIFtsaW51eE9zLmRpc3QsIGxpbnV4T3MucmVsZWFzZV0uam9pbihcIiAtIFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gcmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVsZWFzZSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFBsYXRmb3JtSW5mbyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3Qgb3NWZXJzaW9uID0gYXdhaXQgZ2V0T3NWZXJzaW9uKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBvc05hbWU6IHBsYXRmb3JtKCksXG4gICAgb3NWZXJzaW9uLFxuICAgIG9zQ3B1czogY3B1cygpLFxuICAgIG9zTWVtb3J5OiB7XG4gICAgICBmcmVlOiBmcmVlbWVtKCksXG4gICAgICB0b3RhbDogdG90YWxtZW0oKSxcbiAgICB9LFxuICB9O1xuICBkZWJ1ZyhcInBsYXRmb3JtIGluZm86ICVvXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwgImltcG9ydCB7IE1lcmdlZENvbmZpZyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IGd1ZXNzQnJvd3NlciB9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCB7IGdldFBsYXRmb3JtSW5mbyB9IGZyb20gXCIuL3BsYXRmb3JtXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQbGF0Zm9ybSh7XG4gIGJyb3dzZXIsXG4gIGNvbmZpZyxcbn06IHtcbiAgYnJvd3Nlcj86IHN0cmluZztcbiAgY29uZmlnOiBNZXJnZWRDb25maWc7XG59KSB7XG4gIHJldHVybiB7XG4gICAgLi4uKGF3YWl0IGdldFBsYXRmb3JtSW5mbygpKSxcbiAgICAuLi5ndWVzc0Jyb3dzZXIoYnJvd3NlciA/PyBcImVsZWN0cm9uXCIsIGNvbmZpZy5yZXNvbHZlZD8uYnJvd3NlcnMpLFxuICB9O1xufVxuIiwgImltcG9ydCB7IEN5cHJlc3NSZXN1bHQsIFNjcmVlbnNob3RBcnRpZmFjdCB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tIFwibmFub2lkXCI7XG5pbXBvcnQge1xuICBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgVGVzdFN0YXRlLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBNZXJnZWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cmVzdWx0c1wiKTtcblxuZXhwb3J0IGNvbnN0IGlzU3VjY2Vzc1Jlc3VsdCA9IChcbiAgcmVzdWx0OiBDeXByZXNzUmVzdWx0XG4pOiByZXN1bHQgaXMgQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgPT4ge1xuICByZXR1cm4gcmVzdWx0LnN0YXR1cyA9PT0gXCJmaW5pc2hlZFwiO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNjcmVlbnNob3RzU3VtbWFyeSA9IChcbiAgdGVzdHM6IEN5cHJlc3NDb21tYW5kTGluZS5UZXN0UmVzdWx0W10gPSBbXVxuKTogU2NyZWVuc2hvdEFydGlmYWN0W10gPT4ge1xuICByZXR1cm4gdGVzdHMuZmxhdE1hcCgodGVzdCwgaSkgPT5cbiAgICB0ZXN0LmF0dGVtcHRzLmZsYXRNYXAoKGEsIGFpKSA9PlxuICAgICAgYS5zY3JlZW5zaG90cy5mbGF0TWFwKChzKSA9PiAoe1xuICAgICAgICAuLi5zLFxuICAgICAgICB0ZXN0SWQ6IGByJHtpfWAsXG4gICAgICAgIHRlc3RBdHRlbXB0SW5kZXg6IGFpLFxuICAgICAgICBzY3JlZW5zaG90SWQ6IG5hbm9pZCgpLFxuICAgICAgfSkpXG4gICAgKVxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFN0YXRzID0gKHN0YXRzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wic3RhdHNcIl0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0cyxcbiAgICB3YWxsQ2xvY2tEdXJhdGlvbjogc3RhdHMuZHVyYXRpb24sXG4gICAgd2FsbENsb2NrU3RhcnRlZEF0OiBzdGF0cy5zdGFydGVkQXQsXG4gICAgd2FsbENsb2NrRW5kZWRBdDogc3RhdHMuZW5kZWRBdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUZXN0QXR0ZW1wdCA9IChhdHRlbXB0OiBDeXByZXNzQ29tbWFuZExpbmUuQXR0ZW1wdFJlc3VsdCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGVtcHQsXG4gICAgc3RhdGU6IGF0dGVtcHQuc3RhdGUgYXMgVGVzdFN0YXRlLFxuICAgIHdhbGxDbG9ja0R1cmF0aW9uOiBhdHRlbXB0LmR1cmF0aW9uLFxuICAgIHdhbGxDbG9ja1N0YXJ0ZWRBdDogYXR0ZW1wdC5zdGFydGVkQXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2VSZXN1bHRQYXlsb2FkID0gKFxuICBydW5SZXN1bHQ6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHQsXG4gIGNvdmVyYWdlRmlsZVBhdGg/OiBzdHJpbmdcbik6IFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQgPT4ge1xuICByZXR1cm4ge1xuICAgIHN0YXRzOiBnZXRTdGF0cyhydW5SZXN1bHQuc3RhdHMpLFxuICAgIHJlcG9ydGVyU3RhdHM6IHJ1blJlc3VsdC5yZXBvcnRlclN0YXRzLFxuICAgIGV4Y2VwdGlvbjogcnVuUmVzdWx0LmVycm9yID8/IG51bGwsXG4gICAgdmlkZW86ICEhcnVuUmVzdWx0LnZpZGVvLCAvLyBEaWQgdGhlIGluc3RhbmNlIGdlbmVyYXRlIGEgdmlkZW8/XG4gICAgc2NyZWVuc2hvdHM6IGdldFNjcmVlbnNob3RzU3VtbWFyeShydW5SZXN1bHQudGVzdHMgPz8gW10pLFxuICAgIGhhc0NvdmVyYWdlOiAhIWNvdmVyYWdlRmlsZVBhdGgsXG4gICAgdGVzdHM6XG4gICAgICBydW5SZXN1bHQudGVzdHM/Lm1hcCgodGVzdCwgaSkgPT4gKHtcbiAgICAgICAgZGlzcGxheUVycm9yOiB0ZXN0LmRpc3BsYXlFcnJvcixcbiAgICAgICAgc3RhdGU6IHRlc3Quc3RhdGUgYXMgVGVzdFN0YXRlLFxuICAgICAgICBob29rczogcnVuUmVzdWx0Lmhvb2tzLFxuICAgICAgICBhdHRlbXB0czogdGVzdC5hdHRlbXB0cz8ubWFwKGdldFRlc3RBdHRlbXB0KSA/PyBbXSxcbiAgICAgICAgY2xpZW50SWQ6IGByJHtpfWAsXG4gICAgICB9KSkgPz8gW10sXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFrZVRlc3RGcm9tRXhjZXB0aW9uKFxuICBlcnJvcjogc3RyaW5nLFxuICBzdGF0czogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdFtcInN0YXRzXCJdXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogW1wiVW5rbm93blwiXSxcbiAgICBib2R5OiBcIlwiLFxuICAgIGRpc3BsYXlFcnJvcjogZXJyb3Iuc3BsaXQoXCJcXG5cIilbMF0sXG4gICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgaG9va3M6IFtdLFxuICAgIGF0dGVtcHRzOiBbXG4gICAgICBnZXRUZXN0QXR0ZW1wdCh7XG4gICAgICAgIHN0YXRlOiBcImZhaWxlZFwiLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3Iuc3BsaXQoXCJcXG5cIilbMF0sXG4gICAgICAgICAgc3RhY2s6IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzY3JlZW5zaG90czogW10sXG4gICAgICAgIHN0YXJ0ZWRBdDogc3RhdHMuc3RhcnRlZEF0LFxuICAgICAgICB2aWRlb1RpbWVzdGFtcDogMCxcbiAgICAgIH0pLFxuICAgIF0sXG4gICAgY2xpZW50SWQ6IFwicjBcIixcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlVGVzdHNQYXlsb2FkID0gKFxuICBydW5SZXN1bHQ6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHQsXG4gIGNvbmZpZzogQ3lwcmVzcy5SZXNvbHZlZENvbmZpZ09wdGlvbnNcbik6IFNldEluc3RhbmNlVGVzdHNQYXlsb2FkID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgdGVzdHM6XG4gICAgICBydW5SZXN1bHQudGVzdHM/Lm1hcCgodGVzdCwgaSkgPT4gKHtcbiAgICAgICAgdGl0bGU6IHRlc3QudGl0bGUsXG4gICAgICAgIGNvbmZpZzogbnVsbCxcbiAgICAgICAgYm9keTogdGVzdC5ib2R5LFxuICAgICAgICBjbGllbnRJZDogYHIke2l9YCxcbiAgICAgICAgaG9va0lkczogW10sXG4gICAgICB9KSkgPz8gW10sXG4gICAgaG9va3M6IHJ1blJlc3VsdC5ob29rcyxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdW1tYXJpemVUZXN0UmVzdWx0cyA9IChcbiAgaW5wdXQ6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0W10sXG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnXG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCA9PiB7XG4gIGlmICghaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdldEVtcHR5Q3lwcmVzc1Jlc3VsdHMoY29uZmlnKTtcbiAgfVxuXG4gIGNvbnN0IG92ZXJhbGwgPSBpbnB1dC5yZWR1Y2UoXG4gICAgKFxuICAgICAgYWNjLFxuICAgICAge1xuICAgICAgICB0b3RhbER1cmF0aW9uLFxuICAgICAgICB0b3RhbEZhaWxlZCxcbiAgICAgICAgdG90YWxQYXNzZWQsXG4gICAgICAgIHRvdGFsUGVuZGluZyxcbiAgICAgICAgdG90YWxTa2lwcGVkLFxuICAgICAgICB0b3RhbFRlc3RzLFxuICAgICAgICB0b3RhbFN1aXRlcyxcbiAgICAgIH1cbiAgICApID0+ICh7XG4gICAgICB0b3RhbER1cmF0aW9uOiBhY2MudG90YWxEdXJhdGlvbiArIHRvdGFsRHVyYXRpb24sXG4gICAgICB0b3RhbFN1aXRlczogYWNjLnRvdGFsU3VpdGVzICsgdG90YWxTdWl0ZXMsXG4gICAgICB0b3RhbFBlbmRpbmc6IGFjYy50b3RhbFBlbmRpbmcgKyB0b3RhbFBlbmRpbmcsXG4gICAgICB0b3RhbEZhaWxlZDogYWNjLnRvdGFsRmFpbGVkICsgdG90YWxGYWlsZWQsXG4gICAgICB0b3RhbFNraXBwZWQ6IGFjYy50b3RhbFNraXBwZWQgKyB0b3RhbFNraXBwZWQsXG4gICAgICB0b3RhbFBhc3NlZDogYWNjLnRvdGFsUGFzc2VkICsgdG90YWxQYXNzZWQsXG4gICAgICB0b3RhbFRlc3RzOiBhY2MudG90YWxUZXN0cyArIHRvdGFsVGVzdHMsXG4gICAgfSksXG4gICAgZW1wdHlTdGF0c1xuICApO1xuICBjb25zdCBmaXJzdFJlc3VsdCA9IGlucHV0WzBdO1xuICBjb25zdCBzdGFydEl0ZW1zID0gaW5wdXQubWFwKChpKSA9PiBpLnN0YXJ0ZWRUZXN0c0F0KS5zb3J0KCk7XG4gIGNvbnN0IGVuZEl0ZW1zID0gaW5wdXQubWFwKChpKSA9PiBpLmVuZGVkVGVzdHNBdCkuc29ydCgpO1xuICBjb25zdCBydW5zID0gaW5wdXQubWFwKChpKSA9PiBpLnJ1bnMpLmZsYXQoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5vdmVyYWxsLFxuICAgIHJ1bnMsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IF8uZmlyc3Qoc3RhcnRJdGVtcykgYXMgc3RyaW5nLFxuICAgIGVuZGVkVGVzdHNBdDogXy5sYXN0KGVuZEl0ZW1zKSBhcyBzdHJpbmcsXG4gICAgLi4uXy5waWNrKFxuICAgICAgZmlyc3RSZXN1bHQsXG4gICAgICBcImJyb3dzZXJOYW1lXCIsXG4gICAgICBcImJyb3dzZXJWZXJzaW9uXCIsXG4gICAgICBcImJyb3dzZXJQYXRoXCIsXG4gICAgICBcIm9zTmFtZVwiLFxuICAgICAgXCJvc1ZlcnNpb25cIixcbiAgICAgIFwiY3lwcmVzc1ZlcnNpb25cIixcbiAgICAgIFwiY29uZmlnXCJcbiAgICApLFxuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVtcHR5Q3lwcmVzc1Jlc3VsdHMoXG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnXG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgLi4uZW1wdHlTdGF0cyxcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICBzdGFydGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGVuZGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHJ1bnM6IFtdLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25maWcsXG4gIH07XG59XG5jb25zdCBlbXB0eVN0YXRzID0ge1xuICB0b3RhbER1cmF0aW9uOiAwLFxuICB0b3RhbFN1aXRlczogMCxcbiAgdG90YWxQZW5kaW5nOiAwLFxuICB0b3RhbEZhaWxlZDogMCxcbiAgdG90YWxTa2lwcGVkOiAwLFxuICB0b3RhbFBhc3NlZDogMCxcbiAgdG90YWxUZXN0czogMCxcbn07XG5cbmNvbnN0IGdldER1bW15RmFpbGVkVGVzdCA9IChzdGFydDogc3RyaW5nLCBlcnJvcjogc3RyaW5nKSA9PiAoe1xuICB0aXRsZTogW1wiVW5rbm93blwiXSxcbiAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gIGJvZHk6IFwiLy8gVGhpcyB0ZXN0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGR1ZSB0byBleGVjdXRpb24gZmFpbHVyZVwiLFxuICBkaXNwbGF5RXJyb3I6IGVycm9yLFxuICBhdHRlbXB0czogW1xuICAgIHtcbiAgICAgIHN0YXRlOiBcImZhaWxlZFwiLFxuICAgICAgc3RhcnRlZEF0OiBzdGFydCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgdmlkZW9UaW1lc3RhbXA6IDAsXG4gICAgICBzY3JlZW5zaG90czogW10sXG4gICAgICBlcnJvcjoge1xuICAgICAgICBuYW1lOiBcIkN5cHJlc3NFeGVjdXRpb25FcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBlcnJvcixcbiAgICAgICAgc3RhY2s6IFwiXCIsXG4gICAgICB9LFxuICAgIH0sXG4gIF0sXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZhaWxlZER1bW15UmVzdWx0KFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIHtcbiAgICBzcGVjcyxcbiAgICBlcnJvcixcbiAgfToge1xuICAgIHNwZWNzOiBzdHJpbmdbXTtcbiAgICBlcnJvcjogc3RyaW5nO1xuICB9XG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBlbmQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIHJldHVybiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbmZpZzogY29uZmlnU3RhdGUuZ2V0Q29uZmlnKCkgPz8ge30sXG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBlbmRlZFRlc3RzQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB0b3RhbER1cmF0aW9uOiAwLFxuICAgIHRvdGFsU3VpdGVzOiAxLFxuICAgIHRvdGFsRmFpbGVkOiAxLFxuICAgIHRvdGFsUGFzc2VkOiAwLFxuICAgIHRvdGFsUGVuZGluZzogMCxcbiAgICB0b3RhbFNraXBwZWQ6IDAsXG4gICAgdG90YWxUZXN0czogMSxcbiAgICBicm93c2VyTmFtZTogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclZlcnNpb246IFwidW5rbm93blwiLFxuICAgIGJyb3dzZXJQYXRoOiBcInVua25vd25cIixcbiAgICBvc05hbWU6IFwidW5rbm93blwiLFxuICAgIG9zVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgY3lwcmVzc1ZlcnNpb246IFwidW5rbm93blwiLFxuICAgIHJ1bnM6IHNwZWNzLm1hcCgocykgPT4gKHtcbiAgICAgIHN0YXRzOiB7XG4gICAgICAgIHN1aXRlczogMSxcbiAgICAgICAgdGVzdHM6IDEsXG4gICAgICAgIHBhc3NlczogMCxcbiAgICAgICAgcGVuZGluZzogMCxcbiAgICAgICAgc2tpcHBlZDogMCxcbiAgICAgICAgZmFpbHVyZXM6IDEsXG4gICAgICAgIHN0YXJ0ZWRBdDogc3RhcnQsXG4gICAgICAgIGVuZGVkQXQ6IGVuZCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICB9LFxuICAgICAgcmVwb3J0ZXI6IFwic3BlY1wiLFxuICAgICAgcmVwb3J0ZXJTdGF0czoge30sXG4gICAgICBob29rczogW10sXG4gICAgICBlcnJvcixcbiAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgc3BlYzoge1xuICAgICAgICBuYW1lOiBzLFxuICAgICAgICByZWxhdGl2ZTogcyxcbiAgICAgICAgYWJzb2x1dGU6IHMsXG4gICAgICAgIHJlbGF0aXZlVG9Db21tb25Sb290OiBzLFxuICAgICAgfSxcbiAgICAgIHRlc3RzOiBbZ2V0RHVtbXlGYWlsZWRUZXN0KHN0YXJ0LCBlcnJvcildLFxuICAgICAgc2hvdWxkVXBsb2FkVmlkZW86IGZhbHNlLFxuICAgICAgc2tpcHBlZFNwZWM6IGZhbHNlLFxuICAgIH0pKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN5cHJlc3NSdW5SZXN1bHRGb3JTcGVjKFxuICBzcGVjOiBzdHJpbmcsXG4gIGN5cHJlc3NSZXN1bHQ6IEN5cHJlc3NSZXN1bHRcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFpc1N1Y2Nlc3NSZXN1bHQoY3lwcmVzc1Jlc3VsdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBydW4gPSBjeXByZXNzUmVzdWx0LnJ1bnMuZmluZCgocikgPT4gci5zcGVjLnJlbGF0aXZlID09PSBzcGVjKTtcbiAgaWYgKCFydW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdHMgPSBnZXRTdGF0cyhydW4uc3RhdHMpO1xuICAvLyBhZGp1c3QgdGhlIHJlc3VsdCBmb3Igc2luZ2Ugc3BlY1xuICByZXR1cm4ge1xuICAgIC4uLmN5cHJlc3NSZXN1bHQsXG4gICAgcnVuczogW3J1bl0sXG4gICAgdG90YWxTdWl0ZXM6IDEsXG4gICAgdG90YWxEdXJhdGlvbjogc3RhdHMud2FsbENsb2NrRHVyYXRpb24sXG4gICAgdG90YWxUZXN0czogc3RhdHMudGVzdHMsXG4gICAgdG90YWxGYWlsZWQ6IHN0YXRzLmZhaWx1cmVzLFxuICAgIHRvdGFsUGFzc2VkOiBzdGF0cy5wYXNzZXMsXG4gICAgdG90YWxQZW5kaW5nOiBzdGF0cy5wZW5kaW5nLFxuICAgIHRvdGFsU2tpcHBlZDogc3RhdHMuc2tpcHBlZCxcbiAgICBzdGFydGVkVGVzdHNBdDogc3RhdHMud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgIGVuZGVkVGVzdHNBdDogc3RhdHMud2FsbENsb2NrRW5kZWRBdCxcbiAgfTtcbn1cbiIsICJpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgcHJldHR5TVMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IHsgdGFibGUgfSBmcm9tIFwidGFibGVcIjtcbmltcG9ydCB7IGN5YW4sIGdyYXksIGdyZWVuLCByZWQsIHdoaXRlIH0gZnJvbSBcIi4uL2xvZ1wiO1xuXG5jb25zdCBmYWlsdXJlSWNvbiA9IHJlZChcIlx1MjcxNlwiKTtcbmNvbnN0IHN1Y2Nlc3NJY29uID0gZ3JlZW4oXCJcdTI3MTRcIik7XG5cbmV4cG9ydCBjb25zdCBzdW1tYXJ5VGFibGUgPSAocjogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQpID0+IHtcbiAgY29uc3Qgb3ZlcmFsbFNwZWNDb3VudCA9IHIucnVucy5sZW5ndGg7XG4gIGNvbnN0IGZhaWxlZFNwZWNzQ291bnQgPSBfLnN1bShcbiAgICByLnJ1bnMuZmlsdGVyKCh2KSA9PiB2LnN0YXRzLmZhaWx1cmVzICsgdi5zdGF0cy5za2lwcGVkID4gMCkubWFwKCgpID0+IDEpXG4gICk7XG4gIGNvbnN0IGhhc0ZhaWxlZCA9IGZhaWxlZFNwZWNzQ291bnQgPiAwO1xuXG4gIGNvbnN0IHZlcmRpY3QgPSBoYXNGYWlsZWRcbiAgICA/IHJlZChgJHtmYWlsZWRTcGVjc0NvdW50fSBvZiAke292ZXJhbGxTcGVjQ291bnR9IGZhaWxlZGApXG4gICAgOiBvdmVyYWxsU3BlY0NvdW50ID4gMFxuICAgID8gXCJBbGwgc3BlY3MgcGFzc2VkIVwiXG4gICAgOiBcIk5vIHNwZWNzIGV4ZWN1dGVkXCI7XG5cbiAgY29uc3QgZGF0YSA9IHIucnVucy5tYXAoKHIpID0+IFtcbiAgICByLnN0YXRzLmZhaWx1cmVzICsgci5zdGF0cy5za2lwcGVkID4gMCA/IGZhaWx1cmVJY29uIDogc3VjY2Vzc0ljb24sXG4gICAgci5zcGVjLnJlbGF0aXZlVG9Db21tb25Sb290LFxuICAgIGdyYXkocHJldHR5TVMoci5zdGF0cy5kdXJhdGlvbikpLFxuICAgIHdoaXRlKHIuc3RhdHMudGVzdHMgPz8gMCksXG4gICAgci5zdGF0cy5wYXNzZXMgPyBncmVlbihyLnN0YXRzLnBhc3NlcykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLmZhaWx1cmVzID8gcmVkKHIuc3RhdHMuZmFpbHVyZXMpIDogZ3JheShcIi1cIiksXG4gICAgci5zdGF0cy5wZW5kaW5nID8gY3lhbihyLnN0YXRzLnBlbmRpbmcpIDogZ3JheShcIi1cIiksXG4gICAgci5zdGF0cy5za2lwcGVkID8gcmVkKHIuc3RhdHMuc2tpcHBlZCkgOiBncmF5KFwiLVwiKSxcbiAgXSk7XG5cbiAgcmV0dXJuIHRhYmxlKFxuICAgIFtcbiAgICAgIFtcbiAgICAgICAgXCJcIiwgLy8gbWFya2VyXG4gICAgICAgIGdyYXkoXCJTcGVjXCIpLFxuICAgICAgICBcIlwiLFxuICAgICAgICBncmF5KFwiVGVzdHNcIiksXG4gICAgICAgIGdyYXkoXCJQYXNzaW5nXCIpLFxuICAgICAgICBncmF5KFwiRmFpbGluZ1wiKSxcbiAgICAgICAgZ3JheShcIlBlbmRpbmdcIiksXG4gICAgICAgIGdyYXkoXCJTa2lwcGVkXCIpLFxuICAgICAgXSxcbiAgICAgIC4uLmRhdGEsXG4gICAgICBbXG4gICAgICAgIGhhc0ZhaWxlZCA/IGZhaWx1cmVJY29uIDogc3VjY2Vzc0ljb24sIC8vIG1hcmtlclxuICAgICAgICB2ZXJkaWN0LFxuICAgICAgICBncmF5KHByZXR0eU1TKHIudG90YWxEdXJhdGlvbiA/PyAwKSksXG4gICAgICAgIG92ZXJhbGxTcGVjQ291bnQgPiAwID8gd2hpdGUoci50b3RhbFRlc3RzID8/IDApIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxQYXNzZWQgPyBncmVlbihyLnRvdGFsUGFzc2VkKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsRmFpbGVkID8gcmVkKHIudG90YWxGYWlsZWQpIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxQZW5kaW5nID8gY3lhbihyLnRvdGFsUGVuZGluZykgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFNraXBwZWQgPyByZWQoci50b3RhbFNraXBwZWQpIDogZ3JheShcIi1cIiksXG4gICAgICBdLFxuICAgIF0sXG4gICAge1xuICAgICAgYm9yZGVyLFxuICAgICAgY29sdW1uRGVmYXVsdDoge1xuICAgICAgICB3aWR0aDogOCxcbiAgICAgIH0sXG4gICAgICBjb2x1bW5zOiBbXG4gICAgICAgIHsgYWxpZ25tZW50OiBcImxlZnRcIiwgd2lkdGg6IDIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwibGVmdFwiLCB3aWR0aDogMzAgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgIF0sXG4gICAgICAvLyBzaW5nbGVMaW5lOiB0cnVlLFxuICAgICAgZHJhd0hvcml6b250YWxMaW5lOiAobGluZUluZGV4LCByb3dDb3VudCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gMSB8fFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gMCB8fFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gcm93Q291bnQgLSAxIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSByb3dDb3VudFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGRyYXdWZXJ0aWNhbExpbmU6IChsaW5lSW5kZXgsIHJvd0NvdW50KSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IDAgfHwgcm93Q291bnQgPT09IGxpbmVJbmRleDtcbiAgICAgIH0sXG4gICAgfVxuICApO1xufTtcblxuY29uc3QgYm9yZGVyID0gXy5tYXBWYWx1ZXMoXG4gIHtcbiAgICB0b3BCb2R5OiBgXHUyNTAwYCxcbiAgICB0b3BKb2luOiBgXHUyNTJDYCxcbiAgICB0b3BMZWZ0OiBgICBcdTI1MENgLFxuICAgIHRvcFJpZ2h0OiBgXHUyNTEwYCxcblxuICAgIGJvdHRvbUJvZHk6IGBcdTI1MDBgLFxuICAgIGJvdHRvbUpvaW46IGBcdTI1MzRgLFxuICAgIGJvdHRvbUxlZnQ6IGAgIFx1MjUxNGAsXG4gICAgYm90dG9tUmlnaHQ6IGBcdTI1MThgLFxuXG4gICAgYm9keUxlZnQ6IGAgIFx1MjUwMmAsXG4gICAgYm9keVJpZ2h0OiBgXHUyNTAyYCxcbiAgICBib2R5Sm9pbjogYFx1MjUwMmAsXG5cbiAgICBqb2luQm9keTogYFx1MjUwMGAsXG4gICAgam9pbkxlZnQ6IGAgIFx1MjUxQ2AsXG4gICAgam9pblJpZ2h0OiBgXHUyNTI0YCxcbiAgICBqb2luSm9pbjogYFx1MjUzQ2AsXG4gIH0sXG4gICh2KSA9PiBncmF5KHYpXG4pO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7XG4gIHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZCxcbiAgc2V0SW5zdGFuY2VUZXN0cyxcbiAgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIHVwZGF0ZUluc3RhbmNlUmVzdWx0cyxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgdXBsb2FkQXJ0aWZhY3RzLCB1cGxvYWRTdGRvdXRTYWZlIH0gZnJvbSBcIi4uL2FydGlmYWN0c1wiO1xuaW1wb3J0IHsgc2V0Q2FuY2VsbGF0aW9uUmVhc29uIH0gZnJvbSBcIi4uL2NhbmNlbGxhdGlvblwiO1xuaW1wb3J0IHsgZ2V0SW5pdGlhbE91dHB1dCB9IGZyb20gXCIuLi9jYXB0dXJlXCI7XG5pbXBvcnQgeyBpc0N1cnJlbnRzIH0gZnJvbSBcIi4uL2VudlwiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5pbXBvcnQgeyBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQsIGdldEluc3RhbmNlVGVzdHNQYXlsb2FkIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJlc3VsdHNcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZXBvcnRSZXN1bHRzVGFzayhcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgc3Rkb3V0OiBzdHJpbmcsXG4gIGNvdmVyYWdlRmlsZVBhdGg/OiBzdHJpbmdcbikge1xuICBjb25zdCByZXN1bHRzID0gZXhlY3V0aW9uU3RhdGUuZ2V0SW5zdGFuY2VSZXN1bHRzKGNvbmZpZ1N0YXRlLCBpbnN0YW5jZUlkKTtcbiAgY29uc3QgcnVuID0gcmVzdWx0cy5ydW5zWzBdO1xuICBpZiAoIXJ1bikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJ1biBmb3VuZCBpbiBDeXByZXNzIHJlc3VsdHNcIik7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2VSZXN1bHRzID0gZ2V0SW5zdGFuY2VSZXN1bHRQYXlsb2FkKHJ1biwgY292ZXJhZ2VGaWxlUGF0aCk7XG4gIGNvbnN0IGluc3RhbmNlVGVzdHMgPSBnZXRJbnN0YW5jZVRlc3RzUGF5bG9hZChydW4sIHJlc3VsdHMuY29uZmlnKTtcbiAgY29uc3QgeyB2aWRlb1VwbG9hZFVybCwgc2NyZWVuc2hvdFVwbG9hZFVybHMsIGNvdmVyYWdlVXBsb2FkVXJsLCBjbG91ZCB9ID1cbiAgICBhd2FpdCByZXBvcnRSZXN1bHRzKGluc3RhbmNlSWQsIGluc3RhbmNlVGVzdHMsIGluc3RhbmNlUmVzdWx0cyk7XG5cbiAgaWYgKGNsb3VkPy5zaG91bGRDYW5jZWwpIHtcbiAgICBkZWJ1ZyhcImluc3RhbmNlICVzIHNob3VsZCBjYW5jZWxcIiwgaW5zdGFuY2VJZCk7XG4gICAgc2V0Q2FuY2VsbGF0aW9uUmVhc29uKGNsb3VkLnNob3VsZENhbmNlbCk7XG4gIH1cblxuICBkZWJ1ZyhcImluc3RhbmNlICVzIGFydGlmYWN0IHVwbG9hZCBpbnN0cnVjdGlvbnMgJW9cIiwgaW5zdGFuY2VJZCwge1xuICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICAgIGNvdmVyYWdlVXBsb2FkVXJsLFxuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHVwbG9hZEFydGlmYWN0cyh7XG4gICAgICBleGVjdXRpb25TdGF0ZSxcbiAgICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgICAgdmlkZW9QYXRoOiBydW4udmlkZW8sXG4gICAgICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbiAgICAgIHNjcmVlbnNob3RzOiBpbnN0YW5jZVJlc3VsdHMuc2NyZWVuc2hvdHMsXG4gICAgICBjb3ZlcmFnZVVwbG9hZFVybCxcbiAgICAgIGNvdmVyYWdlRmlsZVBhdGgsXG4gICAgfSksXG4gICAgdXBsb2FkU3Rkb3V0U2FmZShpbnN0YW5jZUlkLCBnZXRJbml0aWFsT3V0cHV0KCkgKyBzdGRvdXQpLFxuICBdKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVwb3J0UmVzdWx0cyhcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBpbnN0YW5jZVRlc3RzOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgaW5zdGFuY2VSZXN1bHRzOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkXG4pIHtcbiAgZGVidWcoXCJyZXBvcnRpbmcgaW5zdGFuY2UgJXMgcmVzdWx0cy4uLlwiLCBpbnN0YW5jZUlkKTtcbiAgaWYgKGlzQ3VycmVudHMoKSkge1xuICAgIHJldHVybiByZXBvcnRJbnN0YW5jZVJlc3VsdHNNZXJnZWQoaW5zdGFuY2VJZCwge1xuICAgICAgdGVzdHM6IGluc3RhbmNlVGVzdHMsXG4gICAgICByZXN1bHRzOiBpbnN0YW5jZVJlc3VsdHMsXG4gICAgfSk7XG4gIH1cblxuICAvLyBydW4gb25lIGFmdGVyIGFub3RoZXJcbiAgYXdhaXQgc2V0SW5zdGFuY2VUZXN0cyhpbnN0YW5jZUlkLCBpbnN0YW5jZVRlc3RzKTtcbiAgcmV0dXJuIHVwZGF0ZUluc3RhbmNlUmVzdWx0cyhpbnN0YW5jZUlkLCBpbnN0YW5jZVJlc3VsdHMpO1xufVxuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IFNjcmVlbnNob3RBcnRpZmFjdCwgU2NyZWVuc2hvdFVwbG9hZEluc3RydWN0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyB1cGRhdGVJbnN0YW5jZVN0ZG91dCB9IGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0IHsgc2FmZSB9IGZyb20gXCIuL2xhbmdcIjtcbmltcG9ydCB7IGRpbSB9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHsgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi9zdGF0ZVwiO1xuaW1wb3J0IHsgdXBsb2FkSW1hZ2UsIHVwbG9hZEpzb24sIHVwbG9hZFZpZGVvIH0gZnJvbSBcIi4vdXBsb2FkXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6YXJ0aWZhY3RzXCIpO1xuaW50ZXJmYWNlIFVwbG9hZEFydGlmYWN0cyB7XG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZTtcbiAgdmlkZW9QYXRoOiBzdHJpbmcgfCBudWxsO1xuICB2aWRlb1VwbG9hZFVybD86IHN0cmluZyB8IG51bGw7XG4gIHNjcmVlbnNob3RzOiBTY3JlZW5zaG90QXJ0aWZhY3RbXTtcbiAgc2NyZWVuc2hvdFVwbG9hZFVybHM6IFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbltdO1xuICBjb3ZlcmFnZVVwbG9hZFVybD86IHN0cmluZyB8IG51bGw7XG4gIGNvdmVyYWdlRmlsZVBhdGg/OiBzdHJpbmcgfCBudWxsO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEFydGlmYWN0cyh7XG4gIGV4ZWN1dGlvblN0YXRlLFxuICB2aWRlb1BhdGgsXG4gIHZpZGVvVXBsb2FkVXJsLFxuICBzY3JlZW5zaG90cyxcbiAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gIGNvdmVyYWdlRmlsZVBhdGgsXG4gIGNvdmVyYWdlVXBsb2FkVXJsLFxufTogVXBsb2FkQXJ0aWZhY3RzKSB7XG4gIGRlYnVnKFwidXBsb2FkaW5nIGFydGlmYWN0czogJW9cIiwge1xuICAgIHZpZGVvUGF0aCxcbiAgICB2aWRlb1VwbG9hZFVybCxcbiAgICBzY3JlZW5zaG90cyxcbiAgICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbiAgICBjb3ZlcmFnZUZpbGVQYXRoLFxuICAgIGNvdmVyYWdlVXBsb2FkVXJsLFxuICB9KTtcblxuICBjb25zdCB0b3RhbFVwbG9hZHMgPVxuICAgICh2aWRlb1BhdGggPyAxIDogMCkgKyBzY3JlZW5zaG90cy5sZW5ndGggKyAoY292ZXJhZ2VVcGxvYWRVcmwgPyAxIDogMCk7XG4gIGlmICh0b3RhbFVwbG9hZHMgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1cGxvYWQgdmlkZW9cbiAgaWYgKHZpZGVvVXBsb2FkVXJsICYmIHZpZGVvUGF0aCkge1xuICAgIGF3YWl0IHNhZmUoXG4gICAgICB1cGxvYWRWaWRlbyxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGRlYnVnKFwiZmFpbGVkIHVwbG9hZGluZyB2aWRlbyAlcy4gRXJyb3I6ICVvXCIsIHZpZGVvUGF0aCwgZSk7XG4gICAgICAgIGV4ZWN1dGlvblN0YXRlLmFkZFdhcm5pbmcoXG4gICAgICAgICAgYEZhaWxlZCB1cGxvYWRpbmcgdmlkZW8gJHt2aWRlb1BhdGh9LlxcbiR7ZGltKGUpfWBcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBkZWJ1ZyhcInN1Y2Nlc3MgdXBsb2FkaW5nXCIsIHZpZGVvUGF0aClcbiAgICApKHZpZGVvUGF0aCwgdmlkZW9VcGxvYWRVcmwpO1xuICB9XG4gIC8vIHVwbG9hZCBzY3JlZW5zaG90c1xuICBpZiAoc2NyZWVuc2hvdFVwbG9hZFVybHMgJiYgc2NyZWVuc2hvdFVwbG9hZFVybHMubGVuZ3RoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzY3JlZW5zaG90cy5tYXAoKHNjcmVlbnNob3QpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gc2NyZWVuc2hvdFVwbG9hZFVybHMuZmluZChcbiAgICAgICAgICAodXJscykgPT4gdXJscy5zY3JlZW5zaG90SWQgPT09IHNjcmVlbnNob3Quc2NyZWVuc2hvdElkXG4gICAgICAgICk/LnVwbG9hZFVybDtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgIFwiTm8gdXBsb2FkIHVybCBmb3Igc2NyZWVuc2hvdCAlbywgc2NyZWVuc2hvdFVwbG9hZFVybHM6ICVvXCIsXG4gICAgICAgICAgICBzY3JlZW5zaG90LFxuICAgICAgICAgICAgc2NyZWVuc2hvdFVwbG9hZFVybHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGV4ZWN1dGlvblN0YXRlLmFkZFdhcm5pbmcoXG4gICAgICAgICAgICBgTm8gdXBsb2FkIFVSTCBmb3Igc2NyZWVuc2hvdCAke3NjcmVlbnNob3QucGF0aH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhZmUoXG4gICAgICAgICAgdXBsb2FkSW1hZ2UsXG4gICAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgICBcImZhaWxlZCB1cGxvYWRpbmcgc2NyZWVuc2hvdCAlcy4gRXJyb3I6ICVvXCIsXG4gICAgICAgICAgICAgIHNjcmVlbnNob3QucGF0aCxcbiAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4ZWN1dGlvblN0YXRlLmFkZFdhcm5pbmcoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdXBsb2FkaW5nIHNjcmVlbnNob3QgJHtzY3JlZW5zaG90LnBhdGh9LlxcbiR7ZGltKGUpfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiBkZWJ1ZyhcInN1Y2Nlc3MgdXBsb2FkaW5nXCIsIHNjcmVlbnNob3QucGF0aClcbiAgICAgICAgKShzY3JlZW5zaG90LnBhdGgsIHVybCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgLy8gdXBsb2FkIGNvdmVyYWdlXG4gIGlmIChjb3ZlcmFnZVVwbG9hZFVybCAmJiBjb3ZlcmFnZUZpbGVQYXRoKSB7XG4gICAgYXdhaXQgc2FmZShcbiAgICAgIHVwbG9hZEpzb24sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcImZhaWxlZCB1cGxvYWRpbmcgY292ZXJhZ2UgZmlsZSAlcy4gRXJyb3I6ICVvXCIsXG4gICAgICAgICAgY292ZXJhZ2VGaWxlUGF0aCxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG5cbiAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICBgRmFpbGVkIHVwbG9hZGluZyBjb3ZlcmFnZSBmaWxlICR7Y292ZXJhZ2VGaWxlUGF0aH0uXFxuJHtkaW0oZSl9YFxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgKCkgPT4gZGVidWcoXCJzdWNjZXNzIHVwbG9hZGluZ1wiLCBjb3ZlcmFnZUZpbGVQYXRoKVxuICAgICkoY292ZXJhZ2VGaWxlUGF0aCwgY292ZXJhZ2VVcGxvYWRVcmwpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1cGxvYWRTdGRvdXRTYWZlID0gc2FmZShcbiAgdXBkYXRlSW5zdGFuY2VTdGRvdXQsXG4gICgpID0+IHt9LFxuICAoKSA9PiB7fVxuKTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBtYWtlUmVxdWVzdCB9IGZyb20gXCIuL2h0dHBDbGllbnRcIjtcbmNvbnN0IHJlYWRGaWxlID0gZnMucHJvbWlzZXMucmVhZEZpbGU7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6dXBsb2FkXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkVmlkZW8oZmlsZTogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICByZXR1cm4gdXBsb2FkRmlsZShmaWxlLCB1cmwsIFwidmlkZW8vbXA0XCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkSW1hZ2UoZmlsZTogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICByZXR1cm4gdXBsb2FkRmlsZShmaWxlLCB1cmwsIFwiaW1hZ2UvcG5nXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkSnNvbihmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xufVxuXG50eXBlIFVwbG9hZFR5cGVzID1cbiAgfCBcInZpZGVvL21wNFwiXG4gIHwgXCJpbWFnZS9wbmdcIlxuICB8IFwicGxhaW4vdGV4dFwiXG4gIHwgXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcsIHR5cGU6IFVwbG9hZFR5cGVzKSB7XG4gIGRlYnVnKCd1cGxvYWRpbmcgZmlsZSBcIiVzXCIgdG8gXCIlc1wiJywgZmlsZSwgdXJsKTtcbiAgY29uc3QgZiA9IGF3YWl0IHJlYWRGaWxlKGZpbGUpO1xuICBhd2FpdCBtYWtlUmVxdWVzdCh7XG4gICAgdXJsLFxuICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICBkYXRhOiBmLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IHR5cGUsXG4gICAgICBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIjogYGlubGluZWAsXG4gICAgfSxcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgRXZlbnQsIHB1YnN1YiB9IGZyb20gXCIuLi9wdWJzdWJcIjtcblxuaW50ZXJmYWNlIEV4ZWN1dGlvblN0YXRlIHtcbiAgY2FuY2VsbGF0aW9uUmVhc29uOiBzdHJpbmcgfCBudWxsO1xufVxuY29uc3Qgc3RhdGU6IEV4ZWN1dGlvblN0YXRlID0ge1xuICBjYW5jZWxsYXRpb25SZWFzb246IG51bGwsXG59O1xuXG5leHBvcnQgY29uc3Qgc2V0Q2FuY2VsbGF0aW9uUmVhc29uID0gKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gIGlmIChzdGF0ZS5jYW5jZWxsYXRpb25SZWFzb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RhdGUuY2FuY2VsbGF0aW9uUmVhc29uID0gcmVhc29uO1xuICBwdWJzdWIuZW1pdChFdmVudC5SVU5fQ0FOQ0VMTEVELCByZWFzb24pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENhbmNlbGxhdGlvblJlYXNvbiA9ICgpID0+IHN0YXRlLmNhbmNlbGxhdGlvblJlYXNvbjtcbiIsICJpbXBvcnQge1xuICBTcGVjV2l0aFJlbGF0aXZlUm9vdCxcbiAgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IHsgZ2V0Q2FwdHVyZWRPdXRwdXQsIHJlc2V0Q2FwdHVyZSB9IGZyb20gXCIuLi9jYXB0dXJlXCI7XG5cbmltcG9ydCB7IGdldEN5cHJlc3NSdW5SZXN1bHRGb3JTcGVjIH0gZnJvbSBcIi4uL3Jlc3VsdHNcIjtcblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlQmF0Y2hlZEluc3RhbmNlcyxcbiAgY3JlYXRlSW5zdGFuY2UsXG4gIENyZWF0ZUluc3RhbmNlUGF5bG9hZCxcbiAgSW5zdGFuY2VSZXNwb25zZVNwZWNEZXRhaWxzLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5cbmltcG9ydCB7IHJ1blNwZWNGaWxlU2FmZSB9IGZyb20gXCIuLi9jeXByZXNzXCI7XG5pbXBvcnQgeyBpc0N1cnJlbnRzIH0gZnJvbSBcIi4uL2VudlwiO1xuaW1wb3J0IHsgZGl2aWRlciwgaW5mbywgdGl0bGUsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSwgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcbmltcG9ydCB7IGNyZWF0ZVJlcG9ydFRhc2ssIHJlcG9ydFRhc2tzIH0gZnJvbSBcIi4vcmVwb3J0VGFza1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cnVubmVyXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVGlsbERvbmUoXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICB7XG4gICAgcnVuSWQsXG4gICAgZ3JvdXBJZCxcbiAgICBtYWNoaW5lSWQsXG4gICAgcGxhdGZvcm0sXG4gICAgc3BlY3M6IGFsbFNwZWNzLFxuICB9OiBDcmVhdGVJbnN0YW5jZVBheWxvYWQgJiB7XG4gICAgc3BlY3M6IFNwZWNXaXRoUmVsYXRpdmVSb290W107XG4gIH0sXG4gIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzXG4pIHtcbiAgbGV0IGhhc01vcmUgPSB0cnVlO1xuXG4gIHdoaWxlIChoYXNNb3JlKSB7XG4gICAgY29uc3QgbmV3VGFza3MgPSBhd2FpdCBydW5CYXRjaChleGVjdXRpb25TdGF0ZSwgY29uZmlnU3RhdGUsIHtcbiAgICAgIHJ1bk1ldGE6IHtcbiAgICAgICAgcnVuSWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIG1hY2hpbmVJZCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICB9LFxuICAgICAgYWxsU3BlY3MsXG4gICAgICBwYXJhbXMsXG4gICAgfSk7XG4gICAgaWYgKCFuZXdUYXNrcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKFwiTm8gbW9yZSB0YXNrcyB0byBydW4uIFVwbG9hZHMgcXVldWU6ICVkXCIsIHJlcG9ydFRhc2tzLmxlbmd0aCk7XG4gICAgICBoYXNNb3JlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbmV3VGFza3MuZm9yRWFjaCgodCkgPT5cbiAgICAgIGNyZWF0ZVJlcG9ydFRhc2soY29uZmlnU3RhdGUsIGV4ZWN1dGlvblN0YXRlLCB0Lmluc3RhbmNlSWQpXG4gICAgKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBydW5CYXRjaChcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIHtcbiAgICBydW5NZXRhLFxuICAgIHBhcmFtcyxcbiAgICBhbGxTcGVjcyxcbiAgfToge1xuICAgIHJ1bk1ldGE6IHtcbiAgICAgIHJ1bklkOiBzdHJpbmc7XG4gICAgICBncm91cElkOiBzdHJpbmc7XG4gICAgICBtYWNoaW5lSWQ6IHN0cmluZztcbiAgICAgIHBsYXRmb3JtOiBDcmVhdGVJbnN0YW5jZVBheWxvYWRbXCJwbGF0Zm9ybVwiXTtcbiAgICB9O1xuICAgIGFsbFNwZWNzOiBTcGVjV2l0aFJlbGF0aXZlUm9vdFtdO1xuICAgIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzO1xuICB9XG4pIHtcbiAgbGV0IGJhdGNoID0ge1xuICAgIHNwZWNzOiBbXSBhcyBJbnN0YW5jZVJlc3BvbnNlU3BlY0RldGFpbHNbXSxcbiAgICBjbGFpbWVkSW5zdGFuY2VzOiAwLFxuICAgIHRvdGFsSW5zdGFuY2VzOiAwLFxuICB9O1xuXG4gIGlmIChpc0N1cnJlbnRzKCkpIHtcbiAgICBkZWJ1ZyhcIkdldHRpbmcgYmF0Y2hlZCB0YXNrczogJWRcIiwgcGFyYW1zLmJhdGNoU2l6ZSk7XG4gICAgYmF0Y2ggPSBhd2FpdCBjcmVhdGVCYXRjaGVkSW5zdGFuY2VzKHtcbiAgICAgIC4uLnJ1bk1ldGEsXG4gICAgICBiYXRjaFNpemU6IHBhcmFtcy5iYXRjaFNpemUsXG4gICAgfSk7XG4gICAgZGVidWcoXCJHb3QgYmF0Y2hlZCB0YXNrczogJW9cIiwgYmF0Y2gpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlSW5zdGFuY2UocnVuTWV0YSk7XG5cbiAgICBpZiAocmVzcG9uc2Uuc3BlYyAhPT0gbnVsbCAmJiByZXNwb25zZS5pbnN0YW5jZUlkICE9PSBudWxsKSB7XG4gICAgICBiYXRjaC5zcGVjcy5wdXNoKHtcbiAgICAgICAgc3BlYzogcmVzcG9uc2Uuc3BlYyxcbiAgICAgICAgaW5zdGFuY2VJZDogcmVzcG9uc2UuaW5zdGFuY2VJZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBiYXRjaC5jbGFpbWVkSW5zdGFuY2VzID0gcmVzcG9uc2UuY2xhaW1lZEluc3RhbmNlcztcbiAgICBiYXRjaC50b3RhbEluc3RhbmNlcyA9IHJlc3BvbnNlLnRvdGFsSW5zdGFuY2VzO1xuICB9XG5cbiAgaWYgKGJhdGNoLnNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXRjaCBjYW4gaGF2ZSBtdWx0aXBsZSBzcGVjcy4gV2hpbGUgcnVubmluZyB0aGUgc3BlY3MsXG4gICAqIGN5cHJlc3MgY2FuIGhhcmQtY3Jhc2ggd2l0aG91dCByZXBvcnRpbmcgYW55IHJlc3VsdC5cbiAgICpcbiAgICogV2hlbiBjcmFzaGVkLCBpZGVhbGx5LCB3ZSBuZWVkIHRvOlxuICAgKiAtIGRldGVybWluZSB3aGljaCBzcGVjIGNyYXNoZWRcbiAgICogLSBhc3NvY2lhdGUgdGhlIGNyYXNoIHdpdGggdGhlIHNwZWNcbiAgICogLSBydW4gdGhlIHJlc3Qgb2YgdW5yZXBvcnRlZCBzcGVjcyBpbiB0aGUgYmF0Y2hcbiAgICpcbiAgICogQnV0IGRldGVjdGluZyB0aGUgY3Jhc2hlZCBzcGVjIGlzIGVycm9yLXByb25lIGFuZCBpbmFjY3VyYXRlLFxuICAgKiBzbyB3ZSBmYWxsIGJhY2sgdG8gcmVwb3J0aW5nIGhhcmQgY3Jhc2ggdG8gYWxsIHN1YnNlcXVlbnRcbiAgICogc3BlY3MgaW4gdGhlIGJhdGNoLlxuICAgKlxuICAgKiBXb3JzdC1jYXNlIHNjZW5hcmlvOiB3ZSByZXBvcnQgaGFyZCBjcmFzaCB0byBhbGwgc3BlY3MgaW4gdGhlIGJhdGNoLlxuICAgKi9cblxuICAvLyAlc3RhdGVcbiAgYmF0Y2guc3BlY3MuZm9yRWFjaCgoaSkgPT4gZXhlY3V0aW9uU3RhdGUuaW5pdEluc3RhbmNlKGkpKTtcblxuICBkaXZpZGVyKCk7XG4gIGluZm8oXG4gICAgXCJSdW5uaW5nOiAlcyAoJWQvJWQpXCIsXG4gICAgYmF0Y2guc3BlY3MubWFwKChzKSA9PiBzLnNwZWMpLmpvaW4oXCIsIFwiKSxcbiAgICBiYXRjaC5jbGFpbWVkSW5zdGFuY2VzLFxuICAgIGJhdGNoLnRvdGFsSW5zdGFuY2VzXG4gICk7XG5cbiAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgcnVuU3BlY0ZpbGVTYWZlKFxuICAgIHtcbiAgICAgIC8vIHVzZSBhYnNvbHV0ZSBwYXRocyAtIHVzZXIgY2FuIHJ1biB0aGUgcHJvZ3JhbSBmcm9tIGEgZGlmZmVyZW50IGRpcmVjdG9yeSwgZS5nLiBueCBvciBhIG1vbm9yZXBvIHdvcmtzcGFjZVxuICAgICAgLy8gY3lwcmVzcyBzdGlsbCByZXBvcnQgdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIHByb2plY3Qgcm9vdFxuICAgICAgc3BlYzogYmF0Y2guc3BlY3NcbiAgICAgICAgLm1hcCgoYnMpID0+IGdldFNwZWNBYnNvbHV0ZVBhdGgoYWxsU3BlY3MsIGJzLnNwZWMpKVxuICAgICAgICAuam9pbihcIixcIiksXG4gICAgfSxcbiAgICBwYXJhbXNcbiAgKTtcblxuICB0aXRsZShcImJsdWVcIiwgXCJSZXBvcnRpbmcgcmVzdWx0cyBhbmQgYXJ0aWZhY3RzIGluIGJhY2tncm91bmQuLi5cIik7XG5cbiAgY29uc3Qgb3V0cHV0ID0gZ2V0Q2FwdHVyZWRPdXRwdXQoKTtcblxuICAvLyAlc3RhdGVcbiAgYmF0Y2guc3BlY3MuZm9yRWFjaCgoc3BlYykgPT4ge1xuICAgIGV4ZWN1dGlvblN0YXRlLnNldEluc3RhbmNlT3V0cHV0KHNwZWMuaW5zdGFuY2VJZCwgb3V0cHV0KTtcbiAgICBjb25zdCBzcGVjUnVuUmVzdWx0ID0gZ2V0Q3lwcmVzc1J1blJlc3VsdEZvclNwZWMoc3BlYy5zcGVjLCByYXdSZXN1bHQpO1xuICAgIGlmICghc3BlY1J1blJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBleGVjdXRpb25TdGF0ZS5zZXRJbnN0YW5jZVJlc3VsdChcbiAgICAgIGNvbmZpZ1N0YXRlLFxuICAgICAgc3BlYy5pbnN0YW5jZUlkLFxuICAgICAgc3BlY1J1blJlc3VsdFxuICAgICk7XG4gIH0pO1xuXG4gIHJlc2V0Q2FwdHVyZSgpO1xuXG4gIHJldHVybiBiYXRjaC5zcGVjcztcbn1cblxuZnVuY3Rpb24gZ2V0U3BlY0Fic29sdXRlUGF0aChcbiAgYWxsU3BlY3M6IFNwZWNXaXRoUmVsYXRpdmVSb290W10sXG4gIHJlbGF0aXZlOiBzdHJpbmdcbikge1xuICBjb25zdCBhYnNvbHV0ZVBhdGggPSBhbGxTcGVjcy5maW5kKChpKSA9PiBpLnJlbGF0aXZlID09PSByZWxhdGl2ZSk/LmFic29sdXRlO1xuICBpZiAoIWFic29sdXRlUGF0aCkge1xuICAgIHdhcm4oXG4gICAgICAnQ2Fubm90IGZpbmQgYWJzb2x1dGUgcGF0aCBmb3Igc3BlYy4gU3BlYzogXCIlc1wiLCBjYW5kaWRhdGVzOiAlbycsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIGFsbFNwZWNzXG4gICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGFic29sdXRlIHBhdGggZm9yIHNwZWNgKTtcbiAgfVxuICByZXR1cm4gYWJzb2x1dGVQYXRoO1xufVxuIiwgImltcG9ydCB7IEluc3RhbmNlSWQgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgZXJyb3IgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRSZXBvcnRSZXN1bHRzVGFzayB9IGZyb20gXCIuLi9yZXN1bHRzXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSwgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJlcG9ydFRhc2tcIik7XG5cbmV4cG9ydCBjb25zdCByZXBvcnRUYXNrczogUHJvbWlzZTxhbnk+W10gPSBbXTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlcG9ydFRhc2sgPSAoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBpbnN0YW5jZUlkOiBJbnN0YW5jZUlkXG4pID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBleGVjdXRpb25TdGF0ZS5nZXRJbnN0YW5jZShpbnN0YW5jZUlkKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIGVycm9yKFwiQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZSAlc1wiLCBpbnN0YW5jZUlkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluc3RhbmNlLnJlcG9ydFN0YXJ0ZWRBdCkge1xuICAgIGRlYnVnKFwiUmVwb3J0IHRhc2sgYWxyZWFkeSBjcmVhdGVkIGZvciBpbnN0YW5jZSAlc1wiLCBpbnN0YW5jZUlkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbnN0YW5jZS5yZXBvcnRTdGFydGVkQXQgPSBuZXcgRGF0ZSgpO1xuXG4gIGRlYnVnKFwiQ3JlYXRpbmcgcmVwb3J0IHRhc2sgZm9yIGluc3RhbmNlSWQgJXNcIiwgaW5zdGFuY2VJZCk7XG4gIHJlcG9ydFRhc2tzLnB1c2goXG4gICAgZ2V0UmVwb3J0UmVzdWx0c1Rhc2soXG4gICAgICBpbnN0YW5jZUlkLFxuICAgICAgY29uZmlnU3RhdGUsXG4gICAgICBleGVjdXRpb25TdGF0ZSxcbiAgICAgIGluc3RhbmNlLm91dHB1dCA/PyBcIm5vIG91dHB1dCBjYXB0dXJlZFwiLFxuICAgICAgaW5zdGFuY2UuY292ZXJhZ2VGaWxlUGF0aFxuICAgICkuY2F0Y2goZXJyb3IpXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVwb3J0VGFza1NwZWMgPSAoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBzcGVjOiBzdHJpbmdcbikgPT4ge1xuICBjb25zdCBpID0gZXhlY3V0aW9uU3RhdGUuZ2V0U3BlYyhzcGVjKTtcbiAgaWYgKCFpKSB7XG4gICAgZXJyb3IoXCJDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgJXNcIiwgc3BlYyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlYnVnKFwiQ3JlYXRpbmcgcmVwb3J0IHRhc2sgZm9yIHNwZWMgJXNcIiwgc3BlYyk7XG4gIHJldHVybiBjcmVhdGVSZXBvcnRUYXNrKGNvbmZpZ1N0YXRlLCBleGVjdXRpb25TdGF0ZSwgaS5pbnN0YW5jZUlkKTtcbn07XG4iLCAiaW1wb3J0IHsgQlByb21pc2UgfSBmcm9tIFwiLi4vbGFuZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IEV2ZW50LCBwdWJzdWIgfSBmcm9tIFwiLi4vcHVic3ViXCI7XG5pbXBvcnQgeyBydW5UaWxsRG9uZSB9IGZyb20gXCIuL3J1bm5lclwiO1xuXG5sZXQgY2FuY2VsbGFibGU6IHtcbiAgY2FuY2VsOiAoKSA9PiB2b2lkO1xufSB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBvblJ1bkNhbmNlbGxlZChyZWFzb246IHN0cmluZykge1xuICB3YXJuKFxuICAgIGBSdW4gY2FuY2VsbGVkOiAlcy4gV2FpdGluZyBmb3IgdXBsb2FkcyB0byBjb21wbGV0ZSBhbmQgc3RvcHBpbmcgZXhlY3V0aW9uLi4uYCxcbiAgICByZWFzb25cbiAgKTtcbiAgY2FuY2VsbGFibGU/LmNhbmNlbCgpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHJ1blRpbGxEb25lPlxuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICBjYW5jZWxsYWJsZSA9IG5ldyBCUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgaWYgKCFvbkNhbmNlbCkge1xuICAgICAgICBfcmVqZWN0KG5ldyBFcnJvcihcIkJsdWVCaXJkIGlzIG1pc2NvbmZpZ3VyZWQ6IG9uQ2FuY2VsIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uQ2FuY2VsKCgpID0+IF9yZXNvbHZlKHZvaWQgMCkpO1xuICAgICAgcnVuVGlsbERvbmUoLi4uYXJncykudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICBfcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICBfcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHB1YnN1Yi5hZGRMaXN0ZW5lcihFdmVudC5SVU5fQ0FOQ0VMTEVELCBvblJ1bkNhbmNlbGxlZCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIHB1YnN1Yi5yZW1vdmVMaXN0ZW5lcihFdmVudC5SVU5fQ0FOQ0VMTEVELCBvblJ1bkNhbmNlbGxlZCk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IHN0b3BXU1MgfSBmcm9tIFwiLi93c1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2h1dGRvd24oKSB7XG4gIGF3YWl0IHN0b3BXU1MoKTtcbn1cbiIsICIvKiEgQHByZXNlcnZlXG5cbiMjIyBNSVRcblxuUGFydHMgb2YgdGhpcyBjb2RlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzIGFuZCBpcyBzdWJqZWN0IHRvIE1JVCBsaWNlbnNlLlxuXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMjIgQ3lwcmVzcy5pb1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5pbXBvcnQgY29tbW9uUGF0aFByZWZpeCBmcm9tIFwiY29tbW9uLXBhdGgtcHJlZml4XCI7XG5pbXBvcnQgZ2xvYmJ5LCB7IEdsb2JieU9wdGlvbnMgfSBmcm9tIFwiZ2xvYmJ5XCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQge1xuICBGaW5kU3BlY3MsXG4gIFNwZWNUeXBlLFxuICBTcGVjV2l0aFJlbGF0aXZlUm9vdCxcbiAgVGVzdGluZ1R5cGUsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgdG9BcnJheSwgdG9Qb3NpeCB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6c3BlY3NcIik7XG5cbnR5cGUgR2xvYlBhdHRlcm4gPSBzdHJpbmcgfCBzdHJpbmdbXTtcblxuLyoqXG4gKiBSZXBsaWNhdGUgaG93IGN5cHJlc3MgaXMgZGlzY292ZXJpbmcgc3BlYyBmaWxlc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2JjOWVkYjQ0NTIzZDYyY2E5MzQ4MjdiOGU4NzBmMzhmODY2MzRjYTQvcGFja2FnZXMvZGF0YS1jb250ZXh0L3NyYy9zb3VyY2VzL1Byb2plY3REYXRhU291cmNlLnRzI0wyNTBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9iYzllZGI0NDUyM2Q2MmNhOTM0ODI3YjhlODcwZjM4Zjg2NjM0Y2E0L3BhY2thZ2VzL2RhdGEtY29udGV4dC9zcmMvYWN0aW9ucy9Qcm9qZWN0QWN0aW9ucy50cyNMNDE3XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kU3BlY3Moe1xuICBwcm9qZWN0Um9vdCxcbiAgdGVzdGluZ1R5cGUsXG4gIHNwZWNQYXR0ZXJuLFxuICBjb25maWdTcGVjUGF0dGVybixcbiAgZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbn06IEZpbmRTcGVjczxzdHJpbmdbXSB8IHN0cmluZz4pOiBQcm9taXNlPFNwZWNXaXRoUmVsYXRpdmVSb290W10+IHtcbiAgY29uZmlnU3BlY1BhdHRlcm4gPSB0b0FycmF5KGNvbmZpZ1NwZWNQYXR0ZXJuKTtcbiAgc3BlY1BhdHRlcm4gPSB0b0FycmF5KHNwZWNQYXR0ZXJuKTtcbiAgZXhjbHVkZVNwZWNQYXR0ZXJuID0gdG9BcnJheShleGNsdWRlU3BlY1BhdHRlcm4pIHx8IFtdO1xuXG4gIC8vIGV4Y2x1ZGUgYWxsIHNwZWNzIG1hdGNoaW5nIGUyZSBpZiBpbiBjb21wb25lbnQgdGVzdGluZ1xuICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybiA9IHRvQXJyYXkoYWRkaXRpb25hbElnbm9yZVBhdHRlcm4pIHx8IFtdO1xuXG4gIGRlYnVnKFwiZXhwbG9yaW5nIHNwZWMgZmlsZXMgZm9yIGV4ZWN1dGlvbiAlT1wiLCB7XG4gICAgdGVzdGluZ1R5cGUsXG4gICAgcHJvamVjdFJvb3QsXG4gICAgc3BlY1BhdHRlcm4sXG4gICAgY29uZmlnU3BlY1BhdHRlcm4sXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICB9KTtcblxuICBpZiAoIXNwZWNQYXR0ZXJuIHx8ICFjb25maWdTcGVjUGF0dGVybikge1xuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGZpbmQgZ2xvYiBwYXR0ZXJucyBmb3IgZXhwbG9yaW5nIHNwZWNzXCIpO1xuICB9XG5cbiAgbGV0IHNwZWNBYnNvbHV0ZVBhdGhzID0gYXdhaXQgZ2V0RmlsZXNCeUdsb2IocHJvamVjdFJvb3QsIHNwZWNQYXR0ZXJuLCB7XG4gICAgYWJzb2x1dGU6IHRydWUsXG4gICAgaWdub3JlOiBbLi4uZXhjbHVkZVNwZWNQYXR0ZXJuLCAuLi5hZGRpdGlvbmFsSWdub3JlUGF0dGVybl0sXG4gIH0pO1xuXG4gIC8vIElmIHRoZSBzcGVjUGF0dGVybiBhbmQgY29uZmlnU3BlY1BhdHRlcm4gYXJlIGRpZmZlcmVudCxcbiAgLy8gaXQgbWVhbnMgdGhlIHVzZXIgcGFzc2VkIHNvbWV0aGluZyBub24tZGVmYXVsdCB2aWEgLS1zcGVjIChydW4gbW9kZSBvbmx5KVxuICAvLyBpbiB0aGlzIHNjZW5hcmlvLCB3ZSB3YW50IHRvIGdyYWIgZXZlcnl0aGluZyB0aGF0IG1hdGNoZXMgYC0tc3BlY2BcbiAgLy8gdGhhdCBmYWxscyB3aXRoaW4gdGhlaXIgZGVmYXVsdCBzcGVjUGF0dGVybi4gVGhlIHJlYXNvbiBpcyBzbyB3ZSBhdm9pZFxuICAvLyBhdHRlbXB0aW5nIHRvIHJ1biB0aGluZ3MgdGhhdCBhcmUgbm90IHNwZWNzLCBlZyBzb3VyY2UgY29kZSwgdmlkZW9zLCBldGMuXG4gIC8vXG4gIC8vIEV4YW1wbGU6IGRldmVsb3BlciB3YW50cyB0byBydW4gdGVzdHMgYXNzb2NpYXRlZCB3aXRoIHRpbWVycyBpbiBwYWNrYWdlcy9kcml2ZXJcbiAgLy8gU28gdGhleSBydW4geWFybiBjeXByZXNzOnJ1biAtLXNwZWMgKiovdGltZXJzKlxuICAvLyB3ZSBkbyAqKm5vdCoqIHdhbnQgdG8gY2FwdHVyZSBgdGltZXJzLnRzYCAoc291cmNlIGNvZGUpIG9yIGEgdmlkZW8gaW5cbiAgLy8gY3lwcmVzcy92aWRlb3MvdGltZXJzLmN5LnRzLm1wNCwgc28gd2UgdGFrZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gc3BlY1BhdHRlcm5cbiAgLy8gYW5kIC0tc3BlYy5cbiAgaWYgKCFfLmlzRXF1YWwoc3BlY1BhdHRlcm4sIGNvbmZpZ1NwZWNQYXR0ZXJuKSkge1xuICAgIGNvbnN0IGRlZmF1bHRTcGVjQWJzb2x1dGVQYXRocyA9IGF3YWl0IGdldEZpbGVzQnlHbG9iKFxuICAgICAgcHJvamVjdFJvb3QsXG4gICAgICBjb25maWdTcGVjUGF0dGVybixcbiAgICAgIHtcbiAgICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGlnbm9yZTogWy4uLmV4Y2x1ZGVTcGVjUGF0dGVybiwgLi4uYWRkaXRpb25hbElnbm9yZVBhdHRlcm5dLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBzcGVjQWJzb2x1dGVQYXRocyA9IF8uaW50ZXJzZWN0aW9uKFxuICAgICAgc3BlY0Fic29sdXRlUGF0aHMsXG4gICAgICBkZWZhdWx0U3BlY0Fic29sdXRlUGF0aHNcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRTcGVjcyh7XG4gICAgcHJvamVjdFJvb3QsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgc3BlY0Fic29sdXRlUGF0aHMsXG4gICAgc3BlY1BhdHRlcm4sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlc0J5R2xvYihcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbiAgZ2xvYjogR2xvYlBhdHRlcm4sXG4gIGdsb2JPcHRpb25zOiBHbG9iYnlPcHRpb25zXG4pIHtcbiAgY29uc3Qgd29ya2luZ0RpcmVjdG9yeVByZWZpeCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgcGF0aC5zZXApO1xuICBjb25zdCBnbG9icyA9IChbXSBhcyBzdHJpbmdbXSlcbiAgICAuY29uY2F0KGdsb2IpXG4gICAgLm1hcCgoZ2xvYlBhdHRlcm4pID0+XG4gICAgICBnbG9iUGF0dGVybi5zdGFydHNXaXRoKFwiLi9cIikgPyBnbG9iUGF0dGVybi5yZXBsYWNlKFwiLi9cIiwgXCJcIikgOiBnbG9iUGF0dGVyblxuICAgIClcbiAgICAubWFwKChnbG9iUGF0dGVybikgPT4ge1xuICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gaW5jbHVkZXMgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LCB3ZSBzdHJpcCBpdCBmcm9tIHRoZSBwYXR0ZXJuLlxuICAgICAgLy8gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IHBhdGggbWF5IGluY2x1ZGUgY2hhcmFjdGVycyB0aGF0IGNvbmZsaWN0IHdpdGggZ2xvYlxuICAgICAgLy8gc3ludGF4IChicmFja2V0cywgcGFyZW50aGVzZXMsIGV0Yy4pIGFuZCBjYXVzZSBvdXIgc2VhcmNoZXMgdG8gaW5hZHZlcnRlbnRseSBmYWlsLlxuICAgICAgLy8gV2Ugc2NvcGUgb3VyIHNlYXJjaCB0byB0aGUgd29ya2luZyBkaXJlY3RvcnkgdXNpbmcgdGhlIGBjd2RgIGdsb2JieSBvcHRpb24uXG4gICAgICBpZiAoZ2xvYlBhdHRlcm4uc3RhcnRzV2l0aCh3b3JraW5nRGlyZWN0b3J5UHJlZml4KSkge1xuICAgICAgICByZXR1cm4gZ2xvYlBhdHRlcm4ucmVwbGFjZSh3b3JraW5nRGlyZWN0b3J5UHJlZml4LCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdsb2JQYXR0ZXJuO1xuICAgIH0pO1xuXG4gIGlmIChvcy5wbGF0Zm9ybSgpID09PSBcIndpbjMyXCIpIHtcbiAgICAvLyBnbG9iYnkgY2FuJ3Qgd29yayB3aXRoIGJhY2t3YXJkcyBzbGFzaGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nbG9iYnkvaXNzdWVzLzE3OVxuICAgIGRlYnVnKFwidXBkYXRpbmcgZ2xvYiBwYXR0ZXJucyB0byBQT1NJWFwiKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gZ2xvYnMpIHtcbiAgICAgIGNvbnN0IGN1ciA9IGdsb2JzW2ldO1xuXG4gICAgICBpZiAoIWN1cikgdGhyb3cgbmV3IEVycm9yKFwidW5kZWZpbmVkIGdsb2IgcmVjZWl2ZWRcIik7XG5cbiAgICAgIGdsb2JzW2ldID0gdG9Qb3NpeChjdXIpO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVidWcoXCJnbG9iYmluZyBwYXR0ZXJuKHMpOiAlb1wiLCBnbG9icyk7XG4gICAgZGVidWcoXCJ3aXRoaW4gZGlyZWN0b3J5OiAlc1wiLCBwcm9qZWN0Um9vdCk7XG5cbiAgICByZXR1cm4gbWF0Y2hHbG9icyhnbG9icywge1xuICAgICAgb25seUZpbGVzOiB0cnVlLFxuICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgLi4uZ2xvYk9wdGlvbnMsXG4gICAgICBpZ25vcmU6IChnbG9iT3B0aW9ucz8uaWdub3JlID8/IFtdKS5jb25jYXQoXCIqKi9ub2RlX21vZHVsZXMvKipcIiksXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcImVycm9yIGluIGdldEZpbGVzQnlHbG9iICVvXCIsIGUpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5jb25zdCBtYXRjaEdsb2JzID0gYXN5bmMgKGdsb2JzOiBHbG9iUGF0dGVybiwgZ2xvYmJ5T3B0aW9uczogR2xvYmJ5T3B0aW9ucykgPT4ge1xuICByZXR1cm4gYXdhaXQgZ2xvYmJ5KGdsb2JzLCBnbG9iYnlPcHRpb25zKTtcbn07XG5cbmludGVyZmFjZSBNYXRjaGVkU3BlY3Mge1xuICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICB0ZXN0aW5nVHlwZTogVGVzdGluZ1R5cGU7XG4gIHNwZWNBYnNvbHV0ZVBhdGhzOiBzdHJpbmdbXTtcbiAgc3BlY1BhdHRlcm46IHN0cmluZyB8IHN0cmluZ1tdO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVkU3BlY3Moe1xuICBwcm9qZWN0Um9vdCxcbiAgdGVzdGluZ1R5cGUsXG4gIHNwZWNBYnNvbHV0ZVBhdGhzLFxufTogTWF0Y2hlZFNwZWNzKSB7XG4gIGRlYnVnKFwiZm91bmQgc3BlY3MgJW9cIiwgc3BlY0Fic29sdXRlUGF0aHMpO1xuXG4gIGxldCBjb21tb25Sb290ID0gXCJcIjtcblxuICBpZiAoc3BlY0Fic29sdXRlUGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29tbW9uUm9vdCA9IHBhdGguZGlybmFtZShzcGVjQWJzb2x1dGVQYXRoc1swXSk7XG4gIH0gZWxzZSB7XG4gICAgY29tbW9uUm9vdCA9IGNvbW1vblBhdGhQcmVmaXgoc3BlY0Fic29sdXRlUGF0aHMpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWNBYnNvbHV0ZVBhdGhzLm1hcCgoYWJzb2x1dGUpID0+XG4gICAgdHJhbnNmb3JtU3BlYyh7XG4gICAgICBwcm9qZWN0Um9vdCxcbiAgICAgIGFic29sdXRlLFxuICAgICAgdGVzdGluZ1R5cGUsXG4gICAgICBjb21tb25Sb290LFxuICAgICAgcGxhdGZvcm06IG9zLnBsYXRmb3JtKCksXG4gICAgICBzZXA6IHBhdGguc2VwLFxuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtU3BlYyB7XG4gIHByb2plY3RSb290OiBzdHJpbmc7XG4gIGFic29sdXRlOiBzdHJpbmc7XG4gIHRlc3RpbmdUeXBlOiBUZXN0aW5nVHlwZTtcbiAgY29tbW9uUm9vdDogc3RyaW5nO1xuICBwbGF0Zm9ybTogTm9kZUpTLlBsYXRmb3JtO1xuICBzZXA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlYyh7XG4gIHByb2plY3RSb290LFxuICBhYnNvbHV0ZSxcbiAgdGVzdGluZ1R5cGUsXG4gIGNvbW1vblJvb3QsXG4gIHBsYXRmb3JtLFxuICBzZXAsXG59OiBUcmFuc2Zvcm1TcGVjKSB7XG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgYWJzb2x1dGUgPSB0b1Bvc2l4KGFic29sdXRlLCBzZXApO1xuICAgIHByb2plY3RSb290ID0gdG9Qb3NpeChwcm9qZWN0Um9vdCwgc2VwKTtcbiAgfVxuXG4gIGNvbnN0IHJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZShwcm9qZWN0Um9vdCwgYWJzb2x1dGUpO1xuICBjb25zdCBwYXJzZWRGaWxlID0gcGF0aC5wYXJzZShhYnNvbHV0ZSk7XG4gIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUoYWJzb2x1dGUpO1xuXG4gIGNvbnN0IHNwZWNGaWxlRXh0ZW5zaW9uID1cbiAgICBbXCIuc3BlY1wiLCBcIi50ZXN0XCIsIFwiLXNwZWNcIiwgXCItdGVzdFwiLCBcIi5jeVwiXVxuICAgICAgLm1hcCgoZXh0KSA9PiBleHQgKyBmaWxlRXh0ZW5zaW9uKVxuICAgICAgLmZpbmQoKGV4dCkgPT4gYWJzb2x1dGUuZW5kc1dpdGgoZXh0KSkgfHwgZmlsZUV4dGVuc2lvbjtcblxuICBjb25zdCBwYXJ0cyA9IGFic29sdXRlLnNwbGl0KHByb2plY3RSb290KTtcbiAgbGV0IG5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSB8fCBcIlwiO1xuXG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoMSk7XG4gIH1cblxuICBjb25zdCBMRUFESU5HX1NMQVNIID0gL15cXC98L2c7XG4gIGNvbnN0IHJlbGF0aXZlVG9Db21tb25Sb290ID0gYWJzb2x1dGVcbiAgICAucmVwbGFjZShjb21tb25Sb290LCBcIlwiKVxuICAgIC5yZXBsYWNlKExFQURJTkdfU0xBU0gsIFwiXCIpO1xuXG4gIHJldHVybiB7XG4gICAgZmlsZUV4dGVuc2lvbixcbiAgICBiYXNlTmFtZTogcGFyc2VkRmlsZS5iYXNlLFxuICAgIGZpbGVOYW1lOiBwYXJzZWRGaWxlLmJhc2UucmVwbGFjZShzcGVjRmlsZUV4dGVuc2lvbiwgXCJcIiksXG4gICAgc3BlY0ZpbGVFeHRlbnNpb24sXG4gICAgcmVsYXRpdmVUb0NvbW1vblJvb3QsXG4gICAgc3BlY1R5cGU6ICh0ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIlxuICAgICAgPyBcImNvbXBvbmVudFwiXG4gICAgICA6IFwiaW50ZWdyYXRpb25cIikgYXMgU3BlY1R5cGUsXG4gICAgbmFtZSxcbiAgICByZWxhdGl2ZSxcbiAgICBhYnNvbHV0ZSxcbiAgfTtcbn1cbiIsICJpbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheSh2YWw/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICByZXR1cm4gdmFsID8gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBbdmFsXSA6IHZhbCkgOiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9zaXgoZmlsZTogc3RyaW5nLCBzZXA6IHN0cmluZyA9IHBhdGguc2VwKSB7XG4gIHJldHVybiBmaWxlLnNwbGl0KHNlcCkuam9pbihwYXRoLnBvc2l4LnNlcCk7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgeyBNZXJnZWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGZpbmRTcGVjcyB9IGZyb20gXCIuL3NwZWNNYXRjaGVyXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRTcGVjRmlsZXMgPSBhc3luYyAoe1xuICBjb25maWcsXG4gIHBhcmFtcyxcbn06IHtcbiAgY29uZmlnOiBNZXJnZWRDb25maWc7XG4gIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzO1xufSkgPT4ge1xuICBjb25zdCBzcGVjUGF0dGVybiA9IGdldFNwZWNQYXR0ZXJuKGNvbmZpZy5zcGVjUGF0dGVybiwgcGFyYW1zLnNwZWMpO1xuICAvLyBmaW5kIHRoZSBzcGVjIGZpbGVzIGFjY29yZGluZyB0byB0aGUgcmVzb2x2ZWQgY29uZmlndXJhdGlvblxuICBjb25zdCBzcGVjcyA9IGF3YWl0IGZpbmRTcGVjcyh7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL2d1aWRlcy9jb21tYW5kLWxpbmUjY3lwcmVzcy1ydW4tc3BlYy1sdC1zcGVjLWd0XG4gICAgcHJvamVjdFJvb3Q6IHBhcmFtcy5wcm9qZWN0ID8/IGNvbmZpZy5wcm9qZWN0Um9vdCxcbiAgICB0ZXN0aW5nVHlwZTogcGFyYW1zLnRlc3RpbmdUeXBlLFxuICAgIHNwZWNQYXR0ZXJuLFxuICAgIGNvbmZpZ1NwZWNQYXR0ZXJuOiBjb25maWcuc3BlY1BhdHRlcm4sXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuOiBjb25maWcuZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuOiBjb25maWcuYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gIH0pO1xuICBpZiAoc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgd2FybihcbiAgICAgIFwiRm91bmQgbm8gc3BlYyBmaWxlcy4gV2FzIGxvb2tpbmcgZm9yIHNwZWMgZmlsZXMgdGhhdCBtYXRjaCBib3RoIGNvbmZpZ1NwZWNQYXR0ZXJuIGFuZCBzcGVjUGF0dGVybiByZWxhdGl2ZSB0byBwcm9qZWN0Um9vdC4gQ29uZmlndXJhdGlvbjogJU9cIixcbiAgICAgIHtcbiAgICAgICAgcHJvamVjdFJvb3Q6IGNvbmZpZy5wcm9qZWN0Um9vdCxcbiAgICAgICAgc3BlY1BhdHRlcm4sXG4gICAgICAgIGNvbmZpZ1NwZWNQYXR0ZXJuOiBjb25maWcuc3BlY1BhdHRlcm4sXG4gICAgICAgIGV4Y2x1ZGVTcGVjUGF0dGVybjogW1xuICAgICAgICAgIGNvbmZpZy5leGNsdWRlU3BlY1BhdHRlcm4sXG4gICAgICAgICAgY29uZmlnLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICAgICAgICBdLmZsYXQoMiksXG4gICAgICAgIHRlc3RpbmdUeXBlOiBwYXJhbXMudGVzdGluZ1R5cGUsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4geyBzcGVjcywgc3BlY1BhdHRlcm4gfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNwZWNQYXR0ZXJuKFxuICBjb25maWdQYXR0ZXJuOiBNZXJnZWRDb25maWdbXCJzcGVjUGF0dGVyblwiXSxcbiAgZXhwbGljaXQ/OiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJzcGVjXCJdXG4pIHtcbiAgcmV0dXJuIGV4cGxpY2l0IHx8IGNvbmZpZ1BhdHRlcm47XG59XG4iLCAiZXhwb3J0IGNsYXNzIENvbmZpZ1N0YXRlIHtcbiAgcHJpdmF0ZSBfY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9ucyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgcHVibGljIHNldENvbmZpZyhjOiB0eXBlb2YgdGhpcy5fY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gYztcbiAgfVxuICBwdWJsaWMgZ2V0Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBDeXByZXNzUnVuLFxuICBDeXByZXNzU2NyZWVuc2hvdCxcbiAgQ3lwcmVzc1Rlc3QsXG4gIEN5cHJlc3NUZXN0QXR0ZW1wdCxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcblxuaW1wb3J0ICogYXMgU3BlY0FmdGVyIGZyb20gXCIuLi9ydW5uZXIvc3BlYy50eXBlXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0RmFrZVRlc3RGcm9tRXhjZXB0aW9uIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuXG5mdW5jdGlvbiBnZXRTY3JlZW5zaG90KHM6IFNwZWNBZnRlci5TY3JlZW5zaG90KTogQ3lwcmVzc1NjcmVlbnNob3Qge1xuICByZXR1cm4ge1xuICAgIC4uLnMsXG4gICAgbmFtZTogcy5uYW1lID8/IFwic2NyZWVuc2hvdFwiLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUZXN0QXR0ZW1wdChcbiAgYXR0ZW1wdDogU3BlY0FmdGVyLlRlc3RBdHRlbXB0LFxuICBzY3JlZW5zaG90czogU3BlY0FmdGVyLlNjcmVlbnNob3RbXVxuKTogQ3lwcmVzc1Rlc3RBdHRlbXB0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hdHRlbXB0LFxuICAgIHN0YXJ0ZWRBdDogYXR0ZW1wdC53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgZHVyYXRpb246IGF0dGVtcHQud2FsbENsb2NrRHVyYXRpb24sXG4gICAgc2NyZWVuc2hvdHM6IHNjcmVlbnNob3RzLm1hcChnZXRTY3JlZW5zaG90KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VGVzdChcbiAgdDogU3BlY0FmdGVyLlRlc3QsXG4gIHNjcmVlbnNob3RzOiBTcGVjQWZ0ZXIuU2NyZWVuc2hvdFtdXG4pOiBDeXByZXNzVGVzdCB7XG4gIGNvbnN0IF9zY3JlZW5zaG90cyA9IHNjcmVlbnNob3RzLmZpbHRlcigocykgPT4gcy50ZXN0SWQgPT09IHQudGVzdElkKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50LFxuICAgIGF0dGVtcHRzOiB0LmF0dGVtcHRzLm1hcCgoYSwgaSkgPT5cbiAgICAgIGdldFRlc3RBdHRlbXB0KFxuICAgICAgICBhLFxuICAgICAgICBfc2NyZWVuc2hvdHMuZmlsdGVyKChzKSA9PiBzLnRlc3RBdHRlbXB0SW5kZXggPT09IGkpXG4gICAgICApXG4gICAgKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwZWNSZXN1bHRzVG9DeXByZXNzUmVzdWx0cyhcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBzcGVjQWZ0ZXJSZXN1bHQ6IFNwZWNBZnRlci5TcGVjUmVzdWx0XG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbmZpZzogY29uZmlnU3RhdGUuZ2V0Q29uZmlnKCksXG4gICAgdG90YWxEdXJhdGlvbjogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0R1cmF0aW9uLFxuICAgIHRvdGFsU3VpdGVzOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMuc3VpdGVzLFxuICAgIHRvdGFsVGVzdHM6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy50ZXN0cyxcbiAgICB0b3RhbEZhaWxlZDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLmZhaWx1cmVzLFxuICAgIHRvdGFsUGFzc2VkOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMucGFzc2VzLFxuICAgIHRvdGFsUGVuZGluZzogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnBlbmRpbmcsXG4gICAgdG90YWxTa2lwcGVkOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMuc2tpcHBlZCxcbiAgICBzdGFydGVkVGVzdHNBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja1N0YXJ0ZWRBdCxcbiAgICBlbmRlZFRlc3RzQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICAgIHJ1bnM6IFtcbiAgICAgIHtcbiAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAuLi5zcGVjQWZ0ZXJSZXN1bHQuc3RhdHMsXG4gICAgICAgICAgc3RhcnRlZEF0OiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgICAgICAgIGVuZGVkQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICAgICAgICAgIGR1cmF0aW9uOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrRHVyYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIHJlcG9ydGVyOiBzcGVjQWZ0ZXJSZXN1bHQucmVwb3J0ZXIsXG4gICAgICAgIHJlcG9ydGVyU3RhdHM6IHNwZWNBZnRlclJlc3VsdC5yZXBvcnRlclN0YXRzID8/IHt9LFxuICAgICAgICBzcGVjOiBzcGVjQWZ0ZXJSZXN1bHQuc3BlYyxcbiAgICAgICAgZXJyb3I6IHNwZWNBZnRlclJlc3VsdC5lcnJvcixcbiAgICAgICAgdmlkZW86IHNwZWNBZnRlclJlc3VsdC52aWRlbyxcbiAgICAgICAgc2hvdWxkVXBsb2FkVmlkZW86IHRydWUsIC8vIG5vdCByZWFsbHkgdXNlZFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIHdyb25nIHR5cGVkZWYgZm9yIEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0XG4gICAgICAgIC8vIGFjdHVhbCBIb29rTmFtZSBpcyBcImJlZm9yZSBhbGxcIiB8IFwiYmVmb3JlIGVhY2hcIiB8IFwiYWZ0ZXIgYWxsXCIgfCBcImFmdGVyIGVhY2hcIlxuICAgICAgICBob29rczogc3BlY0FmdGVyUmVzdWx0Lmhvb2tzLFxuICAgICAgICB0ZXN0czogKHNwZWNBZnRlclJlc3VsdC50ZXN0cyA/PyBbXSkubWFwKCh0KSA9PlxuICAgICAgICAgIGdldFRlc3QodCwgc3BlY0FmdGVyUmVzdWx0LnNjcmVlbnNob3RzKVxuICAgICAgICApLFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgYmFja2ZpbGxFeGNlcHRpb24gPSAoXG4gIHJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbikgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBydW5zOiByZXN1bHQucnVucy5tYXAoYmFja2ZpbGxFeGNlcHRpb25SdW4pLFxuICB9O1xufTtcblxuY29uc3QgYmFja2ZpbGxFeGNlcHRpb25SdW4gPSAocnVuOiBDeXByZXNzUnVuKSA9PiB7XG4gIGlmICghcnVuLmVycm9yKSB7XG4gICAgcmV0dXJuIHJ1bjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucnVuLFxuICAgIHRlc3RzOiBbZ2V0RmFrZVRlc3RGcm9tRXhjZXB0aW9uKHJ1bi5lcnJvciwgcnVuLnN0YXRzKV0sXG4gIH07XG59O1xuIiwgImltcG9ydCB7IEluc3RhbmNlSWQgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IHsgZXJyb3IsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRGYWlsZWREdW1teVJlc3VsdCB9IGZyb20gXCIuLi9yZXN1bHRzXCI7XG5pbXBvcnQge1xuICBiYWNrZmlsbEV4Y2VwdGlvbixcbiAgc3BlY1Jlc3VsdHNUb0N5cHJlc3NSZXN1bHRzLFxufSBmcm9tIFwiLi4vcmVzdWx0cy9tYXBSZXN1bHRcIjtcbmltcG9ydCB7IFNwZWNSZXN1bHQgfSBmcm9tIFwiLi4vcnVubmVyL3NwZWMudHlwZVwiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnN0YXRlXCIpO1xuXG50eXBlIEluc3RhbmNlRXhlY3V0aW9uU3RhdGUgPSB7XG4gIGluc3RhbmNlSWQ6IEluc3RhbmNlSWQ7XG4gIHNwZWM6IHN0cmluZztcbiAgb3V0cHV0Pzogc3RyaW5nO1xuICBzcGVjQmVmb3JlPzogRGF0ZTtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICBydW5SZXN1bHRzPzogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQ7XG4gIHJ1blJlc3VsdHNSZXBvcnRlZEF0PzogRGF0ZTtcbiAgc3BlY0FmdGVyPzogRGF0ZTtcbiAgc3BlY0FmdGVyUmVzdWx0cz86IFNwZWNSZXN1bHQ7XG4gIHJlcG9ydFN0YXJ0ZWRBdD86IERhdGU7XG4gIGNvdmVyYWdlRmlsZVBhdGg/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uU3RhdGUge1xuICBwcml2YXRlIHdhcm5pbmdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHByaXZhdGUgc3RhdGU6IFJlY29yZDxJbnN0YW5jZUlkLCBJbnN0YW5jZUV4ZWN1dGlvblN0YXRlPiA9IHt9O1xuXG4gIHB1YmxpYyBnZXRXYXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy53YXJuaW5ncztcbiAgfVxuXG4gIHB1YmxpYyBhZGRXYXJuaW5nKHdhcm5pbmc6IHN0cmluZykge1xuICAgIHRoaXMud2FybmluZ3MuYWRkKHdhcm5pbmcpO1xuICB9XG5cbiAgcHVibGljIGdldFJlc3VsdHMoY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZSkubWFwKChpKSA9PlxuICAgICAgdGhpcy5nZXRJbnN0YW5jZVJlc3VsdHMoY29uZmlnU3RhdGUsIGkuaW5zdGFuY2VJZClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldEluc3RhbmNlKGluc3RhbmNlSWQ6IEluc3RhbmNlSWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtpbnN0YW5jZUlkXTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRTcGVjKHNwZWM6IHN0cmluZykge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUpLmZpbmQoKGkpID0+IGkuc3BlYyA9PT0gc3BlYyk7XG4gIH1cblxuICBwdWJsaWMgaW5pdEluc3RhbmNlKHtcbiAgICBpbnN0YW5jZUlkLFxuICAgIHNwZWMsXG4gIH06IHtcbiAgICBpbnN0YW5jZUlkOiBJbnN0YW5jZUlkO1xuICAgIHNwZWM6IHN0cmluZztcbiAgfSkge1xuICAgIGRlYnVnKCdJbml0IGV4ZWN1dGlvbiBzdGF0ZSBmb3IgXCIlc1wiJywgc3BlYyk7XG4gICAgdGhpcy5zdGF0ZVtpbnN0YW5jZUlkXSA9IHtcbiAgICAgIGluc3RhbmNlSWQsXG4gICAgICBzcGVjLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc2V0U3BlY0JlZm9yZShzcGVjOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTcGVjKHNwZWMpO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjIFwiJXNcIicsIHNwZWMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGkuc3BlY0JlZm9yZSA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0U3BlY0NvdmVyYWdlKHNwZWM6IHN0cmluZywgY292ZXJhZ2VGaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWJ1ZyhcIkV4cGVyaW1lbnRhbDogY292ZXJhZ2VGaWxlUGF0aCB3YXMgc2V0XCIpO1xuICAgIGkuY292ZXJhZ2VGaWxlUGF0aCA9IGNvdmVyYWdlRmlsZVBhdGg7XG4gIH1cblxuICBwdWJsaWMgc2V0U3BlY0FmdGVyKHNwZWM6IHN0cmluZywgcmVzdWx0czogU3BlY1Jlc3VsdCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFNwZWMoc3BlYyk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgXCIlc1wiJywgc3BlYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGkuc3BlY0FmdGVyID0gbmV3IERhdGUoKTtcbiAgICBpLnNwZWNBZnRlclJlc3VsdHMgPSByZXN1bHRzO1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNPdXRwdXQoc3BlYzogc3RyaW5nLCBvdXRwdXQ6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFNwZWMoc3BlYyk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgXCIlc1wiJywgc3BlYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0SW5zdGFuY2VPdXRwdXQoaS5pbnN0YW5jZUlkLCBvdXRwdXQpO1xuICB9XG5cbiAgcHVibGljIHNldEluc3RhbmNlT3V0cHV0KGluc3RhbmNlSWQ6IHN0cmluZywgb3V0cHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBpID0gdGhpcy5zdGF0ZVtpbnN0YW5jZUlkXTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2UgXCIlc1wiJywgaW5zdGFuY2VJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpLm91dHB1dCkge1xuICAgICAgZGVidWcoJ0luc3RhbmNlIFwiJXNcIiBhbHJlYWR5IGhhcyBvdXRwdXQnLCBpbnN0YW5jZUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaS5vdXRwdXQgPSBvdXRwdXQ7XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VSZXN1bHQoXG4gICAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICAgIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgICByZXN1bHRzOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdFxuICApIHtcbiAgICBjb25zdCBpID0gdGhpcy5zdGF0ZVtpbnN0YW5jZUlkXTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2UgXCIlc1wiJywgaW5zdGFuY2VJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGkucnVuUmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgaS5ydW5SZXN1bHRzUmVwb3J0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SW5zdGFuY2VSZXN1bHRzKFxuICAgIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgICBpbnN0YW5jZUlkOiBzdHJpbmdcbiAgKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldEluc3RhbmNlKGluc3RhbmNlSWQpO1xuXG4gICAgaWYgKCFpKSB7XG4gICAgICBlcnJvcignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZSBcIiVzXCInLCBpbnN0YW5jZUlkKTtcblxuICAgICAgcmV0dXJuIGdldEZhaWxlZER1bW15UmVzdWx0KGNvbmZpZ1N0YXRlLCB7XG4gICAgICAgIHNwZWNzOiBbXCJ1bmtub3duXCJdLFxuICAgICAgICBlcnJvcjogXCJDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1c2Ugc3BlYzphZnRlciByZXN1bHRzIC0gaXQgY2FuIGJlY29tZSBhdmFpbGFibGUgYmVmb3JlIHJ1biByZXN1bHRzXG4gICAgaWYgKGkuc3BlY0FmdGVyUmVzdWx0cykge1xuICAgICAgcmV0dXJuIGJhY2tmaWxsRXhjZXB0aW9uKFxuICAgICAgICBzcGVjUmVzdWx0c1RvQ3lwcmVzc1Jlc3VsdHMoY29uZmlnU3RhdGUsIGkuc3BlY0FmdGVyUmVzdWx0cylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGkucnVuUmVzdWx0cykge1xuICAgICAgcmV0dXJuIGJhY2tmaWxsRXhjZXB0aW9uKGkucnVuUmVzdWx0cyk7XG4gICAgfVxuXG4gICAgZGVidWcoJ05vIHJlc3VsdHMgZGV0ZWN0ZWQgZm9yIFwiJXNcIicsIGkuc3BlYyk7XG4gICAgcmV0dXJuIGdldEZhaWxlZER1bW15UmVzdWx0KGNvbmZpZ1N0YXRlLCB7XG4gICAgICBzcGVjczogW2kuc3BlY10sXG4gICAgICBlcnJvcjogYE5vIHJlc3VsdHMgZGV0ZWN0ZWQgZm9yIHRoZSBzcGVjIGZpbGUuIFRoYXQgdXN1YWxseSBoYXBwZW5zIGJlY2F1c2Ugb2YgY3lwcmVzcyBjcmFzaC4gU2VlIHRoZSBjb25zb2xlIG91dHB1dCBmb3IgZGV0YWlscy5gLFxuICAgIH0pO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUEsYUFBQUE7QUFBQTtBQUFBOzs7QUNLQSxJQUFNLG1CQUFtQixNQUN2QixPQUFPLGFBQWEsY0FDaEIsSUFBSSxJQUFJLFVBQVUsVUFBVSxFQUFFLE9BQzdCLFNBQVMsaUJBQWlCLFNBQVMsY0FBYyxPQUNsRCxJQUFJLElBQUksV0FBVyxTQUFTLE9BQU8sRUFBRTtBQUVwQyxJQUFNLGdCQUFnQyxpQ0FBaUI7OztBRFY5RCxzQkFBTzs7O0FFRFAsb0JBQThCO0FBRXZCLElBQU1DLGVBQVUsNkJBQWMsYUFBZTs7O0FDRnBELDJCQUFlO0FBQ2YsSUFBTSxVQUFVLHFCQUFBQyxRQUFHO0FBR25CLHFCQUFBQSxRQUFHLFFBQVEsU0FBVSxTQUFTLE1BQU0sU0FBUztBQUUzQyxNQUFJLFFBQVEsTUFBTSxTQUFTLEdBQUc7QUFFNUIsVUFBTUMsV0FBVSxRQUFRLFNBQVMsTUFBTTtBQUFBLE1BQ3JDLEdBQUc7QUFBQTtBQUFBLE1BRUgsT0FBTyxDQUFDLFFBQVEsUUFBUSxNQUFNO0FBQUEsSUFDaEMs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QTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsSUFDRixDQUFDO0FBQUE7QUFBQSxJQUVELFdBQVcsUUFBUTtBQUFBO0FBQUEsTUFFakI7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUEsTUFFQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUE7QUFBQSxNQUVBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFVBQVU7QUFBQSxJQUNWLGdCQUFnQixRQUFRO0FBQUEsTUFDdEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsUUFBUSxRQUFRO0FBQUEsTUFDZDtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFNBQVM7QUFBQTtBQUFBLElBRVQsU0FBUyxRQUFR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bmFtZXMiOiBbInJ1biIsICJyZXF1aXJlIiwgImNwIiwgInByb2Nlc3MiLCAiRXZlbnRFbWl0dGVyIiwgIkRlYnVnIiwgImVycm9yIiwgImh0dHAiLCAiSHR0cFRlcm1pbmF0b3IiLCAiaW1wb3J0X2RlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgImxvZyIsICJpbXBvcnRfYXhpb3MiLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9sb2Rhc2giLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF90c19wYXR0ZXJuIiwgImltcG9ydF9kZWJ1ZyIsICJwYXRoIiwgInV0aWwiLCAiY2hhbGsiLCAidXRpbCIsICJjaGFsayIsICJpbXBvcnRfZGVidWciLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJyZXF1aXJlIiwgInN0ZG91dCIsICJmcyIsICJleGVjYSIsICJpbXBvcnRfbG9kYXNoIiwgIl8iLCAiaXNBYnNvbHV0ZSIsICJwYXRoIiwgImRlYnVnIiwgIkRlYnVnIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfbG9kYXNoIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiaW1wb3J0X2xvZGFzaCIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgImF4aW9zIiwgIl8iLCAiYXhpb3NSZXRyeSIsICJwcmV0dHlNaWxsaXNlY29uZHMiLCAiZXJyb3IiLCAicmVxdWlyZSIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2xvZGFzaCIsICJfIiwgInBsYXRmb3JtIiwgInN0ZG91dCIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2xvZGFzaCIsICJkZWJ1ZyIsICJkZWJ1Z0ZuIiwgIl8iLCAiXyIsICJkZWJ1ZyIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2xvZGFzaCIsICJkZWJ1ZyIsICJkZWJ1Z0ZuIiwgIl8iLCAiaW1wb3J0X3BhdGgiLCAicGF0aCIsICJmcyIsICJlcnJvciIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2xvZGFzaCIsICJibHVlYmlyZCIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImN5cHJlc3MiLCAiZXJyb3IiLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF90c19wYXR0ZXJuIiwgImRlYnVnIiwgImltcG9ydF9kZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X3V0aWwiLCAiZGVidWciLCAiRGVidWciLCAiZ2V0b3MiLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9sb2Rhc2giLCAiaW1wb3J0X25hbm9pZCIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJlcnJvciIsICJfIiwgInJ1biIsICJpbXBvcnRfbG9kYXNoIiwgImltcG9ydF9wcmV0dHlfbXMiLCAiXyIsICJyIiwgInByZXR0eU1TIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9mcyIsICJmcyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJmaWxlIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInN0ZG91dCIsICJydW4iLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9kZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJwbGF0Zm9ybSIsICJlcnJvciIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X3BhdGgiLCAiaW1wb3J0X2xvZGFzaCIsICJpbXBvcnRfb3MiLCAiaW1wb3J0X3BhdGgiLCAiZmlsZSIsICJwYXRoIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAicGF0aCIsICJvcyIsICJnbG9iYnkiLCAiY29tbW9uUGF0aFByZWZpeCIsICJwbGF0Zm9ybSIsICJnZXRUZXN0QXR0ZW1wdCIsICJydW4iLCAiaW1wb3J0X2RlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInBsYXRmb3JtIiwgInJ1biIsICJwcmludFdhcm5pbmdzIiwgInBhdGgiLCAiZXJyb3IiLCAicGx1ciIsICJydW4iXQp9Cg==